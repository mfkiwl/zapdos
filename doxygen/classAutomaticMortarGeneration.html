<!-- HTML header for doxygen 1.9.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Zapdos: AutomaticMortarGeneration Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
    <a href="https://shannon-lab.github.io/zapdos" style="text-decoration:none"><div id="projectname">Zapdos</div></a><div id="projectname">
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classAutomaticMortarGeneration-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">AutomaticMortarGeneration Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This class is a container/interface for the objects involved in automatic generation of mortar spaces.  
 <a href="classAutomaticMortarGeneration.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="AutomaticMortarGeneration_8h_source.html">AutomaticMortarGeneration.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for AutomaticMortarGeneration:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classAutomaticMortarGeneration__inherit__graph.svg" width="234" height="110"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a25ec95581c8e81806bd24643af800bbd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#a25ec95581c8e81806bd24643af800bbd">MortarFilterIter</a> = std::unordered_map&lt; dof_id_type, std::set&lt; Elem *, CompareDofObjectsByID &gt; &gt;::const_iterator</td></tr>
<tr class="separator:a25ec95581c8e81806bd24643af800bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9f5f8acc9b0a8749aaa3d0f32302c8a6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#a9f5f8acc9b0a8749aaa3d0f32302c8a6">AutomaticMortarGeneration</a> (<a class="el" href="classMooseApp.html">MooseApp</a> &amp;app, MeshBase &amp;mesh_in, const std::pair&lt; <a class="el" href="AutomaticMortarGeneration_8h.html#acdf40e62836d2c708e17f9e204b0f877">BoundaryID</a>, <a class="el" href="AutomaticMortarGeneration_8h.html#acdf40e62836d2c708e17f9e204b0f877">BoundaryID</a> &gt; &amp;boundary_key, const std::pair&lt; <a class="el" href="AutomaticMortarGeneration_8h.html#afb1ef82fea6170b578d48ad9cd793486">SubdomainID</a>, <a class="el" href="AutomaticMortarGeneration_8h.html#afb1ef82fea6170b578d48ad9cd793486">SubdomainID</a> &gt; &amp;subdomain_key, bool on_displaced, bool periodic, const bool debug, const bool correct_edge_dropping, const Real minimum_projection_angle)</td></tr>
<tr class="memdesc:a9f5f8acc9b0a8749aaa3d0f32302c8a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Must be constructed with a reference to the Mesh we are generating mortar spaces for.  <a href="classAutomaticMortarGeneration.html#a9f5f8acc9b0a8749aaa3d0f32302c8a6">More...</a><br /></td></tr>
<tr class="separator:a9f5f8acc9b0a8749aaa3d0f32302c8a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b366747e19933f0beae2fbb9c0d969b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#a9b366747e19933f0beae2fbb9c0d969b">buildNodeToElemMaps</a> ()</td></tr>
<tr class="memdesc:a9b366747e19933f0beae2fbb9c0d969b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Once the secondary_requested_boundary_ids and primary_requested_boundary_ids containers have been filled in, call this function to build node-to-Elem maps for the lower-dimensional elements.  <a href="classAutomaticMortarGeneration.html#a9b366747e19933f0beae2fbb9c0d969b">More...</a><br /></td></tr>
<tr class="separator:a9b366747e19933f0beae2fbb9c0d969b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d9c7320cc6d9a995eaee8bd021397b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#a2d9c7320cc6d9a995eaee8bd021397b7">computeNodalGeometry</a> ()</td></tr>
<tr class="memdesc:a2d9c7320cc6d9a995eaee8bd021397b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and stores the nodal normal/tangent vectors in a local data structure instead of using the ExplicitSystem/NumericVector approach.  <a href="classAutomaticMortarGeneration.html#a2d9c7320cc6d9a995eaee8bd021397b7">More...</a><br /></td></tr>
<tr class="separator:a2d9c7320cc6d9a995eaee8bd021397b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ac6050a6f320045d286c92bffba156"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#a51ac6050a6f320045d286c92bffba156">projectSecondaryNodes</a> ()</td></tr>
<tr class="memdesc:a51ac6050a6f320045d286c92bffba156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project secondary nodes (find xi^(2) values) to the closest points on the primary surface.  <a href="classAutomaticMortarGeneration.html#a51ac6050a6f320045d286c92bffba156">More...</a><br /></td></tr>
<tr class="separator:a51ac6050a6f320045d286c92bffba156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d7aaf216fe1d8fabc8461756312a1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#af3d7aaf216fe1d8fabc8461756312a1f">projectPrimaryNodes</a> ()</td></tr>
<tr class="memdesc:af3d7aaf216fe1d8fabc8461756312a1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">(Inverse) project primary nodes to the points on the secondary surface where they would have come from (find (xi^(1) values)).  <a href="classAutomaticMortarGeneration.html#af3d7aaf216fe1d8fabc8461756312a1f">More...</a><br /></td></tr>
<tr class="separator:af3d7aaf216fe1d8fabc8461756312a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a49a5fc49ca76d1e89b938d3b3a202e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#a3a49a5fc49ca76d1e89b938d3b3a202e">buildMortarSegmentMesh</a> ()</td></tr>
<tr class="memdesc:a3a49a5fc49ca76d1e89b938d3b3a202e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds the mortar segment mesh once the secondary and primary node projections have been completed.  <a href="classAutomaticMortarGeneration.html#a3a49a5fc49ca76d1e89b938d3b3a202e">More...</a><br /></td></tr>
<tr class="separator:a3a49a5fc49ca76d1e89b938d3b3a202e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a533e6ee50c2892de7d5e436f524bcb83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#a533e6ee50c2892de7d5e436f524bcb83">buildMortarSegmentMesh3d</a> ()</td></tr>
<tr class="memdesc:a533e6ee50c2892de7d5e436f524bcb83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds the mortar segment mesh once the secondary and primary node projections have been completed.  <a href="classAutomaticMortarGeneration.html#a533e6ee50c2892de7d5e436f524bcb83">More...</a><br /></td></tr>
<tr class="separator:a533e6ee50c2892de7d5e436f524bcb83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a345cd37f09eebfb0b829c15f7fd4a441"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#a345cd37f09eebfb0b829c15f7fd4a441">msmStatistics</a> ()</td></tr>
<tr class="memdesc:a345cd37f09eebfb0b829c15f7fd4a441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Outputs mesh statistics for mortar segment mesh.  <a href="classAutomaticMortarGeneration.html#a345cd37f09eebfb0b829c15f7fd4a441">More...</a><br /></td></tr>
<tr class="separator:a345cd37f09eebfb0b829c15f7fd4a441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa871943ba7a8761cc220e90af9c716a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#aa871943ba7a8761cc220e90af9c716a0">clear</a> ()</td></tr>
<tr class="memdesc:aa871943ba7a8761cc220e90af9c716a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the mortar segment mesh and accompanying data structures.  <a href="classAutomaticMortarGeneration.html#aa871943ba7a8761cc220e90af9c716a0">More...</a><br /></td></tr>
<tr class="separator:aa871943ba7a8761cc220e90af9c716a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad2defa2f6ae78d1024147d1cb2d286"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#abad2defa2f6ae78d1024147d1cb2d286">onDisplaced</a> () const</td></tr>
<tr class="memdesc:abad2defa2f6ae78d1024147d1cb2d286"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns whether this object is on the displaced mesh  <a href="classAutomaticMortarGeneration.html#abad2defa2f6ae78d1024147d1cb2d286">More...</a><br /></td></tr>
<tr class="separator:abad2defa2f6ae78d1024147d1cb2d286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae200397e9841242f1bc2438b2156f253"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Point &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#ae200397e9841242f1bc2438b2156f253">getNodalNormals</a> (const Elem &amp;secondary_elem) const</td></tr>
<tr class="separator:ae200397e9841242f1bc2438b2156f253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9594ceb9068d6cf33b6e1ca2f5951fe"><td class="memItemLeft" align="right" valign="top">std::array&lt; <a class="el" href="classMooseUtils_1_1SemidynamicVector.html">MooseUtils::SemidynamicVector</a>&lt; Point, 9 &gt;, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#ac9594ceb9068d6cf33b6e1ca2f5951fe">getNodalTangents</a> (const Elem &amp;secondary_elem) const</td></tr>
<tr class="memdesc:ac9594ceb9068d6cf33b6e1ca2f5951fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the two nodal tangents, which are built on-the-fly.  <a href="classAutomaticMortarGeneration.html#ac9594ceb9068d6cf33b6e1ca2f5951fe">More...</a><br /></td></tr>
<tr class="separator:ac9594ceb9068d6cf33b6e1ca2f5951fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a41db0dea91a39a5ec0e1356b544d23"><td class="memItemLeft" align="right" valign="top">std::map&lt; unsigned int, unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#a9a41db0dea91a39a5ec0e1356b544d23">getSecondaryIpToLowerElementMap</a> (const Elem &amp;lower_secondary_elem) const</td></tr>
<tr class="memdesc:a9a41db0dea91a39a5ec0e1356b544d23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute on-the-fly mapping from secondary interior parent nodes to lower dimensional nodes.  <a href="classAutomaticMortarGeneration.html#a9a41db0dea91a39a5ec0e1356b544d23">More...</a><br /></td></tr>
<tr class="separator:a9a41db0dea91a39a5ec0e1356b544d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8f33d0072ce0d896b4f058980640488"><td class="memItemLeft" align="right" valign="top">std::map&lt; unsigned int, unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#ab8f33d0072ce0d896b4f058980640488">getPrimaryIpToLowerElementMap</a> (const Elem &amp;primary_elem, const Elem &amp;primary_elem_ip, const Elem &amp;lower_secondary_elem) const</td></tr>
<tr class="memdesc:ab8f33d0072ce0d896b4f058980640488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute on-the-fly mapping from primary interior parent nodes to its corresponding lower dimensional nodes.  <a href="classAutomaticMortarGeneration.html#ab8f33d0072ce0d896b4f058980640488">More...</a><br /></td></tr>
<tr class="separator:ab8f33d0072ce0d896b4f058980640488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71eb5cecb4437a9a0edfe8d5ce38007e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Point &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#a71eb5cecb4437a9a0edfe8d5ce38007e">getNormals</a> (const Elem &amp;secondary_elem, const std::vector&lt; Point &gt; &amp;xi1_pts) const</td></tr>
<tr class="memdesc:a71eb5cecb4437a9a0edfe8d5ce38007e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the normals at given reference points on a secondary element.  <a href="classAutomaticMortarGeneration.html#a71eb5cecb4437a9a0edfe8d5ce38007e">More...</a><br /></td></tr>
<tr class="separator:a71eb5cecb4437a9a0edfe8d5ce38007e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a061f0533b7776fd51a0dcce78a8a71b9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Point &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#a061f0533b7776fd51a0dcce78a8a71b9">getNormals</a> (const Elem &amp;secondary_elem, const std::vector&lt; Real &gt; &amp;oned_xi1_pts) const</td></tr>
<tr class="memdesc:a061f0533b7776fd51a0dcce78a8a71b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the normals at given reference points on a secondary element.  <a href="classAutomaticMortarGeneration.html#a061f0533b7776fd51a0dcce78a8a71b9">More...</a><br /></td></tr>
<tr class="separator:a061f0533b7776fd51a0dcce78a8a71b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02fad9659b03bfd39cc92b30a4a988d6"><td class="memItemLeft" align="right" valign="top">const Elem *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#a02fad9659b03bfd39cc92b30a4a988d6">getSecondaryLowerdElemFromSecondaryElem</a> (dof_id_type secondary_elem_id) const</td></tr>
<tr class="memdesc:a02fad9659b03bfd39cc92b30a4a988d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return lower dimensional secondary element given its interior parent.  <a href="classAutomaticMortarGeneration.html#a02fad9659b03bfd39cc92b30a4a988d6">More...</a><br /></td></tr>
<tr class="separator:a02fad9659b03bfd39cc92b30a4a988d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55157330468f97bbf6905ffbb92fbea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#af55157330468f97bbf6905ffbb92fbea">computeInactiveLMNodes</a> ()</td></tr>
<tr class="memdesc:af55157330468f97bbf6905ffbb92fbea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get list of secondary nodes that don't contribute to interaction with any primary element.  <a href="classAutomaticMortarGeneration.html#af55157330468f97bbf6905ffbb92fbea">More...</a><br /></td></tr>
<tr class="separator:af55157330468f97bbf6905ffbb92fbea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac36806c971038a5d13d2e5ea2c9e7f54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#ac36806c971038a5d13d2e5ea2c9e7f54">computeIncorrectEdgeDroppingInactiveLMNodes</a> ()</td></tr>
<tr class="memdesc:ac36806c971038a5d13d2e5ea2c9e7f54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes inactive secondary nodes when incorrect edge dropping behavior is enabled (any node touching a partially or fully dropped element is dropped)  <a href="classAutomaticMortarGeneration.html#ac36806c971038a5d13d2e5ea2c9e7f54">More...</a><br /></td></tr>
<tr class="separator:ac36806c971038a5d13d2e5ea2c9e7f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a545496202789a72da1ffc639dedf322a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#a545496202789a72da1ffc639dedf322a">computeInactiveLMElems</a> ()</td></tr>
<tr class="memdesc:a545496202789a72da1ffc639dedf322a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get list of secondary elems without any corresponding primary elements.  <a href="classAutomaticMortarGeneration.html#a545496202789a72da1ffc639dedf322a">More...</a><br /></td></tr>
<tr class="separator:a545496202789a72da1ffc639dedf322a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e2418ea72d399f0e9d33fd6c158e37"><td class="memItemLeft" align="right" valign="top">const std::unordered_map&lt; dof_id_type, std::unordered_set&lt; dof_id_type &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#ae7e2418ea72d399f0e9d33fd6c158e37">mortarInterfaceCoupling</a> () const</td></tr>
<tr class="separator:ae7e2418ea72d399f0e9d33fd6c158e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511ff6b012ca85a15ed00b59049140ac"><td class="memItemLeft" align="right" valign="top">const std::pair&lt; <a class="el" href="AutomaticMortarGeneration_8h.html#acdf40e62836d2c708e17f9e204b0f877">BoundaryID</a>, <a class="el" href="AutomaticMortarGeneration_8h.html#acdf40e62836d2c708e17f9e204b0f877">BoundaryID</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#a511ff6b012ca85a15ed00b59049140ac">primarySecondaryBoundaryIDPair</a> () const</td></tr>
<tr class="separator:a511ff6b012ca85a15ed00b59049140ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d61e6ddf45aeac1436b6755a33bf68"><td class="memItemLeft" align="right" valign="top">const MeshBase &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#aa4d61e6ddf45aeac1436b6755a33bf68">mortarSegmentMesh</a> () const</td></tr>
<tr class="separator:aa4d61e6ddf45aeac1436b6755a33bf68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e03eb9fe738d5bdd5800e6dd112dfd"><td class="memItemLeft" align="right" valign="top">const std::unordered_map&lt; const Elem *, <a class="el" href="structMortarSegmentInfo.html">MortarSegmentInfo</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#af1e03eb9fe738d5bdd5800e6dd112dfd">mortarSegmentMeshElemToInfo</a> () const</td></tr>
<tr class="separator:af1e03eb9fe738d5bdd5800e6dd112dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0031e96df8f32e5c456a98532509404"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#ad0031e96df8f32e5c456a98532509404">dim</a> () const</td></tr>
<tr class="separator:ad0031e96df8f32e5c456a98532509404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af638f80e4d4fe094ba084a932f465d3d"><td class="memItemLeft" align="right" valign="top">const std::unordered_set&lt; const Node * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#af638f80e4d4fe094ba084a932f465d3d">getInactiveLMNodes</a> () const</td></tr>
<tr class="separator:af638f80e4d4fe094ba084a932f465d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9b61427a0ee7b00dc386406f23f2ccd"><td class="memItemLeft" align="right" valign="top">const std::unordered_set&lt; const Elem * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#aa9b61427a0ee7b00dc386406f23f2ccd">getInactiveLMElems</a> () const</td></tr>
<tr class="separator:aa9b61427a0ee7b00dc386406f23f2ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b3cdaa794d719da7e0c330ab9dac18e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#a6b3cdaa794d719da7e0c330ab9dac18e">incorrectEdgeDropping</a> () const</td></tr>
<tr class="separator:a6b3cdaa794d719da7e0c330ab9dac18e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b69cbfeaf6799a4094c8ca1676759d6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classAutomaticMortarGeneration.html#a25ec95581c8e81806bd24643af800bbd">MortarFilterIter</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#a3b69cbfeaf6799a4094c8ca1676759d6">secondariesToMortarSegments</a> (const Node &amp;node) const</td></tr>
<tr class="separator:a3b69cbfeaf6799a4094c8ca1676759d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af11d3acd4a241fb531e4fa9ef227f469"><td class="memItemLeft" align="right" valign="top">const std::unordered_map&lt; dof_id_type, std::set&lt; Elem *, CompareDofObjectsByID &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#af11d3acd4a241fb531e4fa9ef227f469">secondariesToMortarSegments</a> () const</td></tr>
<tr class="separator:af11d3acd4a241fb531e4fa9ef227f469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a948e97177233f154ff53976dcd7a367c"><td class="memItemLeft" align="right" valign="top">const std::set&lt; <a class="el" href="AutomaticMortarGeneration_8h.html#afb1ef82fea6170b578d48ad9cd793486">SubdomainID</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#a948e97177233f154ff53976dcd7a367c">secondaryIPSubIDs</a> () const</td></tr>
<tr class="separator:a948e97177233f154ff53976dcd7a367c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab03f445cfd60649eff408ab335945380"><td class="memItemLeft" align="right" valign="top">const std::set&lt; <a class="el" href="AutomaticMortarGeneration_8h.html#afb1ef82fea6170b578d48ad9cd793486">SubdomainID</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#ab03f445cfd60649eff408ab335945380">primaryIPSubIDs</a> () const</td></tr>
<tr class="separator:ab03f445cfd60649eff408ab335945380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd30aa47635b25b913c120f2b3f3c311"><td class="memItemLeft" align="right" valign="top">const std::unordered_map&lt; dof_id_type, std::vector&lt; const Elem * &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#afd30aa47635b25b913c120f2b3f3c311">nodesToSecondaryElem</a> () const</td></tr>
<tr class="separator:afd30aa47635b25b913c120f2b3f3c311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7d494bc9dfe051e07cbbdeacc9a28d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#a7b7d494bc9dfe051e07cbbdeacc9a28d">initOutput</a> ()</td></tr>
<tr class="memdesc:a7b7d494bc9dfe051e07cbbdeacc9a28d"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize mortar-mesh based output  <a href="classAutomaticMortarGeneration.html#a7b7d494bc9dfe051e07cbbdeacc9a28d">More...</a><br /></td></tr>
<tr class="separator:a7b7d494bc9dfe051e07cbbdeacc9a28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:acd1f259e7a3d200223164c08af3a7c13"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classConsoleStream.html">ConsoleStream</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classConsoleStreamInterface.html#acd1f259e7a3d200223164c08af3a7c13">_console</a></td></tr>
<tr class="memdesc:acd1f259e7a3d200223164c08af3a7c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">An instance of helper class to write streams to the <a class="el" href="classConsole.html" title="An output object for writing to the console (screen)">Console</a> objects.  <a href="classConsoleStreamInterface.html#acd1f259e7a3d200223164c08af3a7c13">More...</a><br /></td></tr>
<tr class="separator:acd1f259e7a3d200223164c08af3a7c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a5c57df863394d8e14ba6811f6e2dbe9c"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#a5c57df863394d8e14ba6811f6e2dbe9c">system_name</a></td></tr>
<tr class="memdesc:a5c57df863394d8e14ba6811f6e2dbe9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the nodal normals system.  <a href="classAutomaticMortarGeneration.html#a5c57df863394d8e14ba6811f6e2dbe9c">More...</a><br /></td></tr>
<tr class="separator:a5c57df863394d8e14ba6811f6e2dbe9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-methods" name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a6dfaa66a5dc83c679a3c4dd7aa0bf1ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#a6dfaa66a5dc83c679a3c4dd7aa0bf1ab">buildCouplingInformation</a> ()</td></tr>
<tr class="memdesc:a6dfaa66a5dc83c679a3c4dd7aa0bf1ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">build the <code>_mortar_interface_coupling</code> data  <a href="classAutomaticMortarGeneration.html#a6dfaa66a5dc83c679a3c4dd7aa0bf1ab">More...</a><br /></td></tr>
<tr class="separator:a6dfaa66a5dc83c679a3c4dd7aa0bf1ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa99d7524d7b1ae972fe152fd0dc61e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#a8aa99d7524d7b1ae972fe152fd0dc61e">projectSecondaryNodesSinglePair</a> (<a class="el" href="AutomaticMortarGeneration_8h.html#afb1ef82fea6170b578d48ad9cd793486">SubdomainID</a> lower_dimensional_primary_subdomain_id, <a class="el" href="AutomaticMortarGeneration_8h.html#afb1ef82fea6170b578d48ad9cd793486">SubdomainID</a> lower_dimensional_secondary_subdomain_id)</td></tr>
<tr class="memdesc:a8aa99d7524d7b1ae972fe152fd0dc61e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function responsible for projecting secondary nodes onto primary elements for a single primary/secondary pair.  <a href="classAutomaticMortarGeneration.html#a8aa99d7524d7b1ae972fe152fd0dc61e">More...</a><br /></td></tr>
<tr class="separator:a8aa99d7524d7b1ae972fe152fd0dc61e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf5b2f45171eb92b58dd27d22b9715c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#accf5b2f45171eb92b58dd27d22b9715c">projectPrimaryNodesSinglePair</a> (<a class="el" href="AutomaticMortarGeneration_8h.html#afb1ef82fea6170b578d48ad9cd793486">SubdomainID</a> lower_dimensional_primary_subdomain_id, <a class="el" href="AutomaticMortarGeneration_8h.html#afb1ef82fea6170b578d48ad9cd793486">SubdomainID</a> lower_dimensional_secondary_subdomain_id)</td></tr>
<tr class="memdesc:accf5b2f45171eb92b58dd27d22b9715c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function used internally by AutomaticMortarGeneration::project_primary_nodes().  <a href="classAutomaticMortarGeneration.html#accf5b2f45171eb92b58dd27d22b9715c">More...</a><br /></td></tr>
<tr class="separator:accf5b2f45171eb92b58dd27d22b9715c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71119b033756571f4345f912300b182d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#a71119b033756571f4345f912300b182d">householderOrthogolization</a> (const Point &amp;normal, Point &amp;tangent_one, Point &amp;tangent_two) const</td></tr>
<tr class="memdesc:a71119b033756571f4345f912300b182d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Householder orthogonalization procedure to obtain proper basis for tangent and binormal vectors.  <a href="classAutomaticMortarGeneration.html#a71119b033756571f4345f912300b182d">More...</a><br /></td></tr>
<tr class="separator:a71119b033756571f4345f912300b182d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pri-attribs" name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aaad114f9251de54152c04ef277441578"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMooseApp.html">MooseApp</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#aaad114f9251de54152c04ef277441578">_app</a></td></tr>
<tr class="memdesc:aaad114f9251de54152c04ef277441578"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="namespaceMoose.html" title="MOOSE now contains C++17 code, so give a reasonable error message stating what the user can do to add...">Moose</a> app.  <a href="classAutomaticMortarGeneration.html#aaad114f9251de54152c04ef277441578">More...</a><br /></td></tr>
<tr class="separator:aaad114f9251de54152c04ef277441578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a933e2cc029eab5574d2afcac61acf4e7"><td class="memItemLeft" align="right" valign="top">MeshBase &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a></td></tr>
<tr class="memdesc:a933e2cc029eab5574d2afcac61acf4e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to the mesh stored in equation_systems.  <a href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">More...</a><br /></td></tr>
<tr class="separator:a933e2cc029eab5574d2afcac61acf4e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d4166e27bcb186c75c320b232652cf1"><td class="memItemLeft" align="right" valign="top">std::set&lt; <a class="el" href="AutomaticMortarGeneration_8h.html#acdf40e62836d2c708e17f9e204b0f877">BoundaryID</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#a1d4166e27bcb186c75c320b232652cf1">_secondary_requested_boundary_ids</a></td></tr>
<tr class="memdesc:a1d4166e27bcb186c75c320b232652cf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boundary ids corresponding to all the secondary surfaces.  <a href="classAutomaticMortarGeneration.html#a1d4166e27bcb186c75c320b232652cf1">More...</a><br /></td></tr>
<tr class="separator:a1d4166e27bcb186c75c320b232652cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67507605b6ed18765d5ffd1243ff619"><td class="memItemLeft" align="right" valign="top">std::set&lt; <a class="el" href="AutomaticMortarGeneration_8h.html#acdf40e62836d2c708e17f9e204b0f877">BoundaryID</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#ad67507605b6ed18765d5ffd1243ff619">_primary_requested_boundary_ids</a></td></tr>
<tr class="memdesc:ad67507605b6ed18765d5ffd1243ff619"><td class="mdescLeft">&#160;</td><td class="mdescRight">The boundary ids corresponding to all the primary surfaces.  <a href="classAutomaticMortarGeneration.html#ad67507605b6ed18765d5ffd1243ff619">More...</a><br /></td></tr>
<tr class="separator:ad67507605b6ed18765d5ffd1243ff619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e1a5b919de8cfdc39c8af4098fb450"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; <a class="el" href="AutomaticMortarGeneration_8h.html#acdf40e62836d2c708e17f9e204b0f877">BoundaryID</a>, <a class="el" href="AutomaticMortarGeneration_8h.html#acdf40e62836d2c708e17f9e204b0f877">BoundaryID</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#a36e1a5b919de8cfdc39c8af4098fb450">_primary_secondary_boundary_id_pairs</a></td></tr>
<tr class="memdesc:a36e1a5b919de8cfdc39c8af4098fb450"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of primary/secondary boundary id pairs corresponding to each side of the mortar interface.  <a href="classAutomaticMortarGeneration.html#a36e1a5b919de8cfdc39c8af4098fb450">More...</a><br /></td></tr>
<tr class="separator:a36e1a5b919de8cfdc39c8af4098fb450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad443aa196d2c81d195b29ddeee1d5e"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; dof_id_type, std::vector&lt; const Elem * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#a1ad443aa196d2c81d195b29ddeee1d5e">_nodes_to_secondary_elem_map</a></td></tr>
<tr class="memdesc:a1ad443aa196d2c81d195b29ddeee1d5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map from nodes to connected lower-dimensional elements on the secondary/primary subdomains.  <a href="classAutomaticMortarGeneration.html#a1ad443aa196d2c81d195b29ddeee1d5e">More...</a><br /></td></tr>
<tr class="separator:a1ad443aa196d2c81d195b29ddeee1d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee9b6e4f8bd88603e22117085758f70"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; dof_id_type, std::vector&lt; const Elem * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#a1ee9b6e4f8bd88603e22117085758f70">_nodes_to_primary_elem_map</a></td></tr>
<tr class="separator:a1ee9b6e4f8bd88603e22117085758f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb4cc3e3102675e52675a95347ad8e95"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; std::pair&lt; const Node *, const Elem * &gt;, std::pair&lt; Real, const Elem * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#abb4cc3e3102675e52675a95347ad8e95">_secondary_node_and_elem_to_xi2_primary_elem</a></td></tr>
<tr class="memdesc:abb4cc3e3102675e52675a95347ad8e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to the map above, but associates a (Secondary Node, Secondary Elem) pair to a (xi^(2), primary Elem) pair.  <a href="classAutomaticMortarGeneration.html#abb4cc3e3102675e52675a95347ad8e95">More...</a><br /></td></tr>
<tr class="separator:abb4cc3e3102675e52675a95347ad8e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac174eedb02e9681baf439360903700d4"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::tuple&lt; dof_id_type, const Node *, const Elem * &gt;, std::pair&lt; Real, const Elem * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#ac174eedb02e9681baf439360903700d4">_primary_node_and_elem_to_xi1_secondary_elem</a></td></tr>
<tr class="memdesc:ac174eedb02e9681baf439360903700d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same type of container, but for mapping (Primary Node ID, Primary Node, Primary Elem) -&gt; (xi^(1), Secondary Elem) where they are inverse-projected along the nodal normal direction.  <a href="classAutomaticMortarGeneration.html#ac174eedb02e9681baf439360903700d4">More...</a><br /></td></tr>
<tr class="separator:ac174eedb02e9681baf439360903700d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3bb17ea3f054b18cc8044bb10d55d9"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; MeshBase &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a></td></tr>
<tr class="memdesc:a9c3bb17ea3f054b18cc8044bb10d55d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">1D Mesh of mortar segment elements which gets built by the call to build_mortar_segment_mesh().  <a href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">More...</a><br /></td></tr>
<tr class="separator:a9c3bb17ea3f054b18cc8044bb10d55d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd91d3cf8bef528976fe6f932622d2d"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; const Elem *, <a class="el" href="structMortarSegmentInfo.html">MortarSegmentInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#abbd91d3cf8bef528976fe6f932622d2d">_msm_elem_to_info</a></td></tr>
<tr class="memdesc:abbd91d3cf8bef528976fe6f932622d2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map between Elems in the mortar segment mesh and their info structs.  <a href="classAutomaticMortarGeneration.html#abbd91d3cf8bef528976fe6f932622d2d">More...</a><br /></td></tr>
<tr class="separator:abbd91d3cf8bef528976fe6f932622d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a169550fc1a82fca976e386edae0d254d"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; const Elem *, unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#a169550fc1a82fca976e386edae0d254d">_lower_elem_to_side_id</a></td></tr>
<tr class="memdesc:a169550fc1a82fca976e386edae0d254d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keeps track of the mapping between lower-dimensional elements and the side_id of the interior_parent which they are.  <a href="classAutomaticMortarGeneration.html#a169550fc1a82fca976e386edae0d254d">More...</a><br /></td></tr>
<tr class="separator:a169550fc1a82fca976e386edae0d254d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a969d4ab038fc8d447e966cd1e1600091"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; <a class="el" href="AutomaticMortarGeneration_8h.html#afb1ef82fea6170b578d48ad9cd793486">SubdomainID</a>, <a class="el" href="AutomaticMortarGeneration_8h.html#afb1ef82fea6170b578d48ad9cd793486">SubdomainID</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#a969d4ab038fc8d447e966cd1e1600091">_primary_secondary_subdomain_id_pairs</a></td></tr>
<tr class="memdesc:a969d4ab038fc8d447e966cd1e1600091"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of primary/secondary subdomain id pairs corresponding to each side of the mortar interface.  <a href="classAutomaticMortarGeneration.html#a969d4ab038fc8d447e966cd1e1600091">More...</a><br /></td></tr>
<tr class="separator:a969d4ab038fc8d447e966cd1e1600091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c6fd297125023195e7bfb3714846c5"><td class="memItemLeft" align="right" valign="top">std::set&lt; <a class="el" href="AutomaticMortarGeneration_8h.html#afb1ef82fea6170b578d48ad9cd793486">SubdomainID</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#a59c6fd297125023195e7bfb3714846c5">_secondary_boundary_subdomain_ids</a></td></tr>
<tr class="memdesc:a59c6fd297125023195e7bfb3714846c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The secondary/primary lower-dimensional boundary subdomain ids are the secondary/primary <em>boundary</em> ids.  <a href="classAutomaticMortarGeneration.html#a59c6fd297125023195e7bfb3714846c5">More...</a><br /></td></tr>
<tr class="separator:a59c6fd297125023195e7bfb3714846c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe701da36a67d2d9546f9db735b1faf"><td class="memItemLeft" align="right" valign="top">std::set&lt; <a class="el" href="AutomaticMortarGeneration_8h.html#afb1ef82fea6170b578d48ad9cd793486">SubdomainID</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#acbe701da36a67d2d9546f9db735b1faf">_primary_boundary_subdomain_ids</a></td></tr>
<tr class="separator:acbe701da36a67d2d9546f9db735b1faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2357a3aacfa2cae90078e3b6293bf26"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; dof_id_type, std::unordered_set&lt; dof_id_type &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#ab2357a3aacfa2cae90078e3b6293bf26">_mortar_interface_coupling</a></td></tr>
<tr class="memdesc:ab2357a3aacfa2cae90078e3b6293bf26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used by the <a class="el" href="classAugmentSparsityOnInterface.html">AugmentSparsityOnInterface</a> functor to determine whether a given Elem is coupled to any others across the gap, and to explicitly set up the dependence between interior_parent() elements on the secondary side and their lower-dimensional sides which are on the interface.  <a href="classAutomaticMortarGeneration.html#ab2357a3aacfa2cae90078e3b6293bf26">More...</a><br /></td></tr>
<tr class="separator:ab2357a3aacfa2cae90078e3b6293bf26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06fb539aea2e63f3b48a6e1d41a2f568"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; const Node *, Point &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#a06fb539aea2e63f3b48a6e1d41a2f568">_secondary_node_to_nodal_normal</a></td></tr>
<tr class="memdesc:a06fb539aea2e63f3b48a6e1d41a2f568"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for storing the nodal normal vector associated with each secondary node.  <a href="classAutomaticMortarGeneration.html#a06fb539aea2e63f3b48a6e1d41a2f568">More...</a><br /></td></tr>
<tr class="separator:a06fb539aea2e63f3b48a6e1d41a2f568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8120c89f18fdff39621fa512087a2da3"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; const Node *, std::array&lt; Point, 2 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#a8120c89f18fdff39621fa512087a2da3">_secondary_node_to_hh_nodal_tangents</a></td></tr>
<tr class="memdesc:a8120c89f18fdff39621fa512087a2da3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for storing the nodal tangent/binormal vectors associated with each secondary node (Householder approach).  <a href="classAutomaticMortarGeneration.html#a8120c89f18fdff39621fa512087a2da3">More...</a><br /></td></tr>
<tr class="separator:a8120c89f18fdff39621fa512087a2da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb676f79ae207404fb5d224ac768df42"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; dof_id_type, const Elem * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#acb676f79ae207404fb5d224ac768df42">_secondary_element_to_secondary_lowerd_element</a></td></tr>
<tr class="memdesc:acb676f79ae207404fb5d224ac768df42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map from full dimensional secondary element id to lower dimensional secondary element.  <a href="classAutomaticMortarGeneration.html#acb676f79ae207404fb5d224ac768df42">More...</a><br /></td></tr>
<tr class="separator:acb676f79ae207404fb5d224ac768df42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c757e0025c7dbfb78485e79067fb138"><td class="memItemLeft" align="right" valign="top">std::unordered_set&lt; const Node * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#a3c757e0025c7dbfb78485e79067fb138">_inactive_local_lm_nodes</a></td></tr>
<tr class="separator:a3c757e0025c7dbfb78485e79067fb138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3445ab0b94ce0dc9c01a1234321ebaa"><td class="memItemLeft" align="right" valign="top">std::unordered_set&lt; const Elem * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#ac3445ab0b94ce0dc9c01a1234321ebaa">_inactive_local_lm_elems</a></td></tr>
<tr class="memdesc:ac3445ab0b94ce0dc9c01a1234321ebaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">List of inactive lagrange multiplier nodes (for elemental variables)  <a href="classAutomaticMortarGeneration.html#ac3445ab0b94ce0dc9c01a1234321ebaa">More...</a><br /></td></tr>
<tr class="separator:ac3445ab0b94ce0dc9c01a1234321ebaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0da3b7d9e404238718805e12452d74d"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; dof_id_type, std::set&lt; Elem *, CompareDofObjectsByID &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#af0da3b7d9e404238718805e12452d74d">_secondary_elems_to_mortar_segments</a></td></tr>
<tr class="memdesc:af0da3b7d9e404238718805e12452d74d"><td class="mdescLeft">&#160;</td><td class="mdescRight">We maintain a mapping from lower-dimensional secondary elements in the original mesh to (sets of) elements in mortar_segment_mesh.  <a href="classAutomaticMortarGeneration.html#af0da3b7d9e404238718805e12452d74d">More...</a><br /></td></tr>
<tr class="separator:af0da3b7d9e404238718805e12452d74d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7254faea651acd63b60b408ab560a0e5"><td class="memItemLeft" align="right" valign="top">std::set&lt; <a class="el" href="AutomaticMortarGeneration_8h.html#afb1ef82fea6170b578d48ad9cd793486">SubdomainID</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#a7254faea651acd63b60b408ab560a0e5">_secondary_ip_sub_ids</a></td></tr>
<tr class="memdesc:a7254faea651acd63b60b408ab560a0e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">All the secondary interior parent subdomain IDs associated with the mortar mesh.  <a href="classAutomaticMortarGeneration.html#a7254faea651acd63b60b408ab560a0e5">More...</a><br /></td></tr>
<tr class="separator:a7254faea651acd63b60b408ab560a0e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac99e408cefd4da80efa2649ef1d32e93"><td class="memItemLeft" align="right" valign="top">std::set&lt; <a class="el" href="AutomaticMortarGeneration_8h.html#afb1ef82fea6170b578d48ad9cd793486">SubdomainID</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#ac99e408cefd4da80efa2649ef1d32e93">_primary_ip_sub_ids</a></td></tr>
<tr class="memdesc:ac99e408cefd4da80efa2649ef1d32e93"><td class="mdescLeft">&#160;</td><td class="mdescRight">All the primary interior parent subdomain IDs associated with the mortar mesh.  <a href="classAutomaticMortarGeneration.html#ac99e408cefd4da80efa2649ef1d32e93">More...</a><br /></td></tr>
<tr class="separator:ac99e408cefd4da80efa2649ef1d32e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958de5b754ec676f463c50d2f16b5d0c"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#a958de5b754ec676f463c50d2f16b5d0c">_debug</a></td></tr>
<tr class="memdesc:a958de5b754ec676f463c50d2f16b5d0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether to print debug output.  <a href="classAutomaticMortarGeneration.html#a958de5b754ec676f463c50d2f16b5d0c">More...</a><br /></td></tr>
<tr class="separator:a958de5b754ec676f463c50d2f16b5d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1faa015bf0201e49ab822e50b713fc1"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#ac1faa015bf0201e49ab822e50b713fc1">_on_displaced</a></td></tr>
<tr class="memdesc:ac1faa015bf0201e49ab822e50b713fc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether this object is on the displaced mesh.  <a href="classAutomaticMortarGeneration.html#ac1faa015bf0201e49ab822e50b713fc1">More...</a><br /></td></tr>
<tr class="separator:ac1faa015bf0201e49ab822e50b713fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a509e5164f1c4cd0f981eaa901c37c632"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#a509e5164f1c4cd0f981eaa901c37c632">_periodic</a></td></tr>
<tr class="memdesc:a509e5164f1c4cd0f981eaa901c37c632"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether this object will be generating a mortar segment mesh for periodic constraints.  <a href="classAutomaticMortarGeneration.html#a509e5164f1c4cd0f981eaa901c37c632">More...</a><br /></td></tr>
<tr class="separator:a509e5164f1c4cd0f981eaa901c37c632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4462365906bd50aeb9a76b07a5ff34d"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#ac4462365906bd50aeb9a76b07a5ff34d">_distributed</a></td></tr>
<tr class="memdesc:ac4462365906bd50aeb9a76b07a5ff34d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the mortar segment mesh is distributed.  <a href="classAutomaticMortarGeneration.html#ac4462365906bd50aeb9a76b07a5ff34d">More...</a><br /></td></tr>
<tr class="separator:ac4462365906bd50aeb9a76b07a5ff34d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04e775677691747d25e1a5f05496fa5a"><td class="memItemLeft" align="right" valign="top">Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#a04e775677691747d25e1a5f05496fa5a">_newton_tolerance</a> = 1e-12</td></tr>
<tr class="memdesc:a04e775677691747d25e1a5f05496fa5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Newton solve tolerance for node projections.  <a href="classAutomaticMortarGeneration.html#a04e775677691747d25e1a5f05496fa5a">More...</a><br /></td></tr>
<tr class="separator:a04e775677691747d25e1a5f05496fa5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f6f147b1b0a4b00e7c6739dd17b98c"><td class="memItemLeft" align="right" valign="top">Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#a25f6f147b1b0a4b00e7c6739dd17b98c">_xi_tolerance</a> = 1e-6</td></tr>
<tr class="memdesc:a25f6f147b1b0a4b00e7c6739dd17b98c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tolerance for checking projection xi values.  <a href="classAutomaticMortarGeneration.html#a25f6f147b1b0a4b00e7c6739dd17b98c">More...</a><br /></td></tr>
<tr class="separator:a25f6f147b1b0a4b00e7c6739dd17b98c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689b49e6bae35fa2ba975b844c4ec82e"><td class="memItemLeft" align="right" valign="top">const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#a689b49e6bae35fa2ba975b844c4ec82e">_correct_edge_dropping</a></td></tr>
<tr class="memdesc:a689b49e6bae35fa2ba975b844c4ec82e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag to enable regressed treatment of edge dropping where all LM DoFs on edge dropping element are strongly set to 0.  <a href="classAutomaticMortarGeneration.html#a689b49e6bae35fa2ba975b844c4ec82e">More...</a><br /></td></tr>
<tr class="separator:a689b49e6bae35fa2ba975b844c4ec82e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ca257dd4090b3a8d801a439dcae0ca"><td class="memItemLeft" align="right" valign="top">const Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#af5ca257dd4090b3a8d801a439dcae0ca">_minimum_projection_angle</a></td></tr>
<tr class="memdesc:af5ca257dd4090b3a8d801a439dcae0ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameter to control which angle (in degrees) is admissible for the creation of mortar segments.  <a href="classAutomaticMortarGeneration.html#af5ca257dd4090b3a8d801a439dcae0ca">More...</a><br /></td></tr>
<tr class="separator:af5ca257dd4090b3a8d801a439dcae0ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a19330f38987cd9318f38d932c5a2ad"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classInputParameters.html">InputParameters</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#a3a19330f38987cd9318f38d932c5a2ad">_output_params</a></td></tr>
<tr class="memdesc:a3a19330f38987cd9318f38d932c5a2ad"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classStorage.html">Storage</a> for the input parameters used by the mortar nodal geometry output.  <a href="classAutomaticMortarGeneration.html#a3a19330f38987cd9318f38d932c5a2ad">More...</a><br /></td></tr>
<tr class="separator:a3a19330f38987cd9318f38d932c5a2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:abfa0eb2fcdd908fd95d33c4818f08855"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#abfa0eb2fcdd908fd95d33c4818f08855">MortarNodalGeometryOutput</a></td></tr>
<tr class="separator:abfa0eb2fcdd908fd95d33c4818f08855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a702fe0b6991a787d7257f8263a618b"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAutomaticMortarGeneration.html#a1a702fe0b6991a787d7257f8263a618b">AugmentSparsityOnInterface</a></td></tr>
<tr class="separator:a1a702fe0b6991a787d7257f8263a618b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >This class is a container/interface for the objects involved in automatic generation of mortar spaces. </p>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00056">56</a> of file <a class="el" href="AutomaticMortarGeneration_8h_source.html">AutomaticMortarGeneration.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a25ec95581c8e81806bd24643af800bbd" name="a25ec95581c8e81806bd24643af800bbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25ec95581c8e81806bd24643af800bbd">&#9670;&#160;</a></span>MortarFilterIter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classAutomaticMortarGeneration.html#a25ec95581c8e81806bd24643af800bbd">AutomaticMortarGeneration::MortarFilterIter</a> =  std::unordered_map&lt;dof_id_type, std::set&lt;Elem *, CompareDofObjectsByID&gt; &gt;::const_iterator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00299">299</a> of file <a class="el" href="AutomaticMortarGeneration_8h_source.html">AutomaticMortarGeneration.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9f5f8acc9b0a8749aaa3d0f32302c8a6" name="a9f5f8acc9b0a8749aaa3d0f32302c8a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f5f8acc9b0a8749aaa3d0f32302c8a6">&#9670;&#160;</a></span>AutomaticMortarGeneration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AutomaticMortarGeneration::AutomaticMortarGeneration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMooseApp.html">MooseApp</a> &amp;&#160;</td>
          <td class="paramname"><em>app</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MeshBase &amp;&#160;</td>
          <td class="paramname"><em>mesh_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; <a class="el" href="AutomaticMortarGeneration_8h.html#acdf40e62836d2c708e17f9e204b0f877">BoundaryID</a>, <a class="el" href="AutomaticMortarGeneration_8h.html#acdf40e62836d2c708e17f9e204b0f877">BoundaryID</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; <a class="el" href="AutomaticMortarGeneration_8h.html#afb1ef82fea6170b578d48ad9cd793486">SubdomainID</a>, <a class="el" href="AutomaticMortarGeneration_8h.html#afb1ef82fea6170b578d48ad9cd793486">SubdomainID</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>subdomain_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>on_displaced</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>periodic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>debug</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>correct_edge_dropping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real&#160;</td>
          <td class="paramname"><em>minimum_projection_angle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Must be constructed with a reference to the Mesh we are generating mortar spaces for. </p>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00213">213</a> of file <a class="el" href="AutomaticMortarGeneration_8C_source.html">AutomaticMortarGeneration.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  223</span>  : <a class="code hl_class" href="classConsoleStreamInterface.html">ConsoleStreamInterface</a>(app),</div>
<div class="line"><span class="lineno">  224</span>    <a class="code hl_variable" href="classAutomaticMortarGeneration.html#aaad114f9251de54152c04ef277441578">_app</a>(app),</div>
<div class="line"><span class="lineno">  225</span>    <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>(mesh_in),</div>
<div class="line"><span class="lineno">  226</span>    <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a958de5b754ec676f463c50d2f16b5d0c">_debug</a>(debug),</div>
<div class="line"><span class="lineno">  227</span>    <a class="code hl_variable" href="classAutomaticMortarGeneration.html#ac1faa015bf0201e49ab822e50b713fc1">_on_displaced</a>(on_displaced),</div>
<div class="line"><span class="lineno">  228</span>    <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a509e5164f1c4cd0f981eaa901c37c632">_periodic</a>(periodic),</div>
<div class="line"><span class="lineno">  229</span>    <a class="code hl_variable" href="classAutomaticMortarGeneration.html#ac4462365906bd50aeb9a76b07a5ff34d">_distributed</a>(!<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.is_replicated()),</div>
<div class="line"><span class="lineno">  230</span>    <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a689b49e6bae35fa2ba975b844c4ec82e">_correct_edge_dropping</a>(correct_edge_dropping),</div>
<div class="line"><span class="lineno">  231</span>    <a class="code hl_variable" href="classAutomaticMortarGeneration.html#af5ca257dd4090b3a8d801a439dcae0ca">_minimum_projection_angle</a>(minimum_projection_angle)</div>
<div class="line"><span class="lineno">  232</span>{</div>
<div class="line"><span class="lineno">  233</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a36e1a5b919de8cfdc39c8af4098fb450">_primary_secondary_boundary_id_pairs</a>.push_back(boundary_key);</div>
<div class="line"><span class="lineno">  234</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#ad67507605b6ed18765d5ffd1243ff619">_primary_requested_boundary_ids</a>.insert(boundary_key.first);</div>
<div class="line"><span class="lineno">  235</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a1d4166e27bcb186c75c320b232652cf1">_secondary_requested_boundary_ids</a>.insert(boundary_key.second);</div>
<div class="line"><span class="lineno">  236</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a969d4ab038fc8d447e966cd1e1600091">_primary_secondary_subdomain_id_pairs</a>.push_back(subdomain_key);</div>
<div class="line"><span class="lineno">  237</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#acbe701da36a67d2d9546f9db735b1faf">_primary_boundary_subdomain_ids</a>.insert(subdomain_key.first);</div>
<div class="line"><span class="lineno">  238</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a59c6fd297125023195e7bfb3714846c5">_secondary_boundary_subdomain_ids</a>.insert(subdomain_key.second);</div>
<div class="line"><span class="lineno">  239</span> </div>
<div class="line"><span class="lineno">  240</span>  <span class="keywordflow">if</span> (<a class="code hl_variable" href="classAutomaticMortarGeneration.html#ac4462365906bd50aeb9a76b07a5ff34d">_distributed</a>)</div>
<div class="line"><span class="lineno">  241</span>    <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a> = std::make_unique&lt;DistributedMesh&gt;(<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.comm());</div>
<div class="line"><span class="lineno">  242</span>  <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  243</span>    <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a> = std::make_unique&lt;ReplicatedMesh&gt;(<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.comm());</div>
<div class="line"><span class="lineno">  244</span>}</div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a1d4166e27bcb186c75c320b232652cf1"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a1d4166e27bcb186c75c320b232652cf1">AutomaticMortarGeneration::_secondary_requested_boundary_ids</a></div><div class="ttdeci">std::set&lt; BoundaryID &gt; _secondary_requested_boundary_ids</div><div class="ttdoc">The boundary ids corresponding to all the secondary surfaces.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00356">AutomaticMortarGeneration.h:356</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a36e1a5b919de8cfdc39c8af4098fb450"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a36e1a5b919de8cfdc39c8af4098fb450">AutomaticMortarGeneration::_primary_secondary_boundary_id_pairs</a></div><div class="ttdeci">std::vector&lt; std::pair&lt; BoundaryID, BoundaryID &gt; &gt; _primary_secondary_boundary_id_pairs</div><div class="ttdoc">A list of primary/secondary boundary id pairs corresponding to each side of the mortar interface.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00363">AutomaticMortarGeneration.h:363</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a509e5164f1c4cd0f981eaa901c37c632"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a509e5164f1c4cd0f981eaa901c37c632">AutomaticMortarGeneration::_periodic</a></div><div class="ttdeci">const bool _periodic</div><div class="ttdoc">Whether this object will be generating a mortar segment mesh for periodic constraints.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00484">AutomaticMortarGeneration.h:484</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a59c6fd297125023195e7bfb3714846c5"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a59c6fd297125023195e7bfb3714846c5">AutomaticMortarGeneration::_secondary_boundary_subdomain_ids</a></div><div class="ttdeci">std::set&lt; SubdomainID &gt; _secondary_boundary_subdomain_ids</div><div class="ttdoc">The secondary/primary lower-dimensional boundary subdomain ids are the secondary/primary boundary ids...</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00416">AutomaticMortarGeneration.h:416</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a689b49e6bae35fa2ba975b844c4ec82e"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a689b49e6bae35fa2ba975b844c4ec82e">AutomaticMortarGeneration::_correct_edge_dropping</a></div><div class="ttdeci">const bool _correct_edge_dropping</div><div class="ttdoc">Flag to enable regressed treatment of edge dropping where all LM DoFs on edge dropping element are st...</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00499">AutomaticMortarGeneration.h:499</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a933e2cc029eab5574d2afcac61acf4e7"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">AutomaticMortarGeneration::_mesh</a></div><div class="ttdeci">MeshBase &amp; _mesh</div><div class="ttdoc">Reference to the mesh stored in equation_systems.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00353">AutomaticMortarGeneration.h:353</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a958de5b754ec676f463c50d2f16b5d0c"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a958de5b754ec676f463c50d2f16b5d0c">AutomaticMortarGeneration::_debug</a></div><div class="ttdeci">const bool _debug</div><div class="ttdoc">Whether to print debug output.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00478">AutomaticMortarGeneration.h:478</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a969d4ab038fc8d447e966cd1e1600091"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a969d4ab038fc8d447e966cd1e1600091">AutomaticMortarGeneration::_primary_secondary_subdomain_id_pairs</a></div><div class="ttdeci">std::vector&lt; std::pair&lt; SubdomainID, SubdomainID &gt; &gt; _primary_secondary_subdomain_id_pairs</div><div class="ttdoc">A list of primary/secondary subdomain id pairs corresponding to each side of the mortar interface.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00412">AutomaticMortarGeneration.h:412</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a9c3bb17ea3f054b18cc8044bb10d55d9"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">AutomaticMortarGeneration::_mortar_segment_mesh</a></div><div class="ttdeci">std::unique_ptr&lt; MeshBase &gt; _mortar_segment_mesh</div><div class="ttdoc">1D Mesh of mortar segment elements which gets built by the call to build_mortar_segment_mesh().</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00399">AutomaticMortarGeneration.h:399</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_aaad114f9251de54152c04ef277441578"><div class="ttname"><a href="classAutomaticMortarGeneration.html#aaad114f9251de54152c04ef277441578">AutomaticMortarGeneration::_app</a></div><div class="ttdeci">MooseApp &amp; _app</div><div class="ttdoc">The Moose app.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00350">AutomaticMortarGeneration.h:350</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_ac1faa015bf0201e49ab822e50b713fc1"><div class="ttname"><a href="classAutomaticMortarGeneration.html#ac1faa015bf0201e49ab822e50b713fc1">AutomaticMortarGeneration::_on_displaced</a></div><div class="ttdeci">const bool _on_displaced</div><div class="ttdoc">Whether this object is on the displaced mesh.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00481">AutomaticMortarGeneration.h:481</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_ac4462365906bd50aeb9a76b07a5ff34d"><div class="ttname"><a href="classAutomaticMortarGeneration.html#ac4462365906bd50aeb9a76b07a5ff34d">AutomaticMortarGeneration::_distributed</a></div><div class="ttdeci">const bool _distributed</div><div class="ttdoc">Whether the mortar segment mesh is distributed.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00487">AutomaticMortarGeneration.h:487</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_acbe701da36a67d2d9546f9db735b1faf"><div class="ttname"><a href="classAutomaticMortarGeneration.html#acbe701da36a67d2d9546f9db735b1faf">AutomaticMortarGeneration::_primary_boundary_subdomain_ids</a></div><div class="ttdeci">std::set&lt; SubdomainID &gt; _primary_boundary_subdomain_ids</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00417">AutomaticMortarGeneration.h:417</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_ad67507605b6ed18765d5ffd1243ff619"><div class="ttname"><a href="classAutomaticMortarGeneration.html#ad67507605b6ed18765d5ffd1243ff619">AutomaticMortarGeneration::_primary_requested_boundary_ids</a></div><div class="ttdeci">std::set&lt; BoundaryID &gt; _primary_requested_boundary_ids</div><div class="ttdoc">The boundary ids corresponding to all the primary surfaces.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00359">AutomaticMortarGeneration.h:359</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_af5ca257dd4090b3a8d801a439dcae0ca"><div class="ttname"><a href="classAutomaticMortarGeneration.html#af5ca257dd4090b3a8d801a439dcae0ca">AutomaticMortarGeneration::_minimum_projection_angle</a></div><div class="ttdeci">const Real _minimum_projection_angle</div><div class="ttdoc">Parameter to control which angle (in degrees) is admissible for the creation of mortar segments.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00505">AutomaticMortarGeneration.h:505</a></div></div>
<div class="ttc" id="aclassConsoleStreamInterface_html"><div class="ttname"><a href="classConsoleStreamInterface.html">ConsoleStreamInterface</a></div><div class="ttdoc">An inteface for the _console for outputting to the Console object.</div><div class="ttdef"><b>Definition:</b> <a href="ConsoleStreamInterface_8h_source.html#l00021">ConsoleStreamInterface.h:22</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6dfaa66a5dc83c679a3c4dd7aa0bf1ab" name="a6dfaa66a5dc83c679a3c4dd7aa0bf1ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dfaa66a5dc83c679a3c4dd7aa0bf1ab">&#9670;&#160;</a></span>buildCouplingInformation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AutomaticMortarGeneration::buildCouplingInformation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>build the <code>_mortar_interface_coupling</code> data </p>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01350">1350</a> of file <a class="el" href="AutomaticMortarGeneration_8C_source.html">AutomaticMortarGeneration.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1351</span>{</div>
<div class="line"><span class="lineno"> 1352</span>  std::unordered_map&lt;processor_id_type, std::vector&lt;std::pair&lt;dof_id_type, dof_id_type&gt;&gt;&gt;</div>
<div class="line"><span class="lineno"> 1353</span>      coupling_info;</div>
<div class="line"><span class="lineno"> 1354</span> </div>
<div class="line"><span class="lineno"> 1355</span>  <span class="comment">// Loop over the msm_elem_to_info object and build a bi-directional</span></div>
<div class="line"><span class="lineno"> 1356</span>  <span class="comment">// multimap from secondary elements to the primary Elems which they are</span></div>
<div class="line"><span class="lineno"> 1357</span>  <span class="comment">// coupled to and vice-versa. This is used in the</span></div>
<div class="line"><span class="lineno"> 1358</span>  <span class="comment">// AugmentSparsityOnInterface functor to determine whether a given</span></div>
<div class="line"><span class="lineno"> 1359</span>  <span class="comment">// secondary Elem is coupled across the mortar interface to a primary</span></div>
<div class="line"><span class="lineno"> 1360</span>  <span class="comment">// element.</span></div>
<div class="line"><span class="lineno"> 1361</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; pr : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#abbd91d3cf8bef528976fe6f932622d2d">_msm_elem_to_info</a>)</div>
<div class="line"><span class="lineno"> 1362</span>  {</div>
<div class="line"><span class="lineno"> 1363</span>    <span class="keyword">const</span> Elem * secondary_elem = pr.second.secondary_elem;</div>
<div class="line"><span class="lineno"> 1364</span>    <span class="keyword">const</span> Elem * primary_elem = pr.second.primary_elem;</div>
<div class="line"><span class="lineno"> 1365</span> </div>
<div class="line"><span class="lineno"> 1366</span>    <span class="comment">// LowerSecondary</span></div>
<div class="line"><span class="lineno"> 1367</span>    coupling_info[secondary_elem-&gt;processor_id()].emplace_back(</div>
<div class="line"><span class="lineno"> 1368</span>        secondary_elem-&gt;id(), secondary_elem-&gt;interior_parent()-&gt;id());</div>
<div class="line"><span class="lineno"> 1369</span>    <span class="keywordflow">if</span> (secondary_elem-&gt;processor_id() != <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.processor_id())</div>
<div class="line"><span class="lineno"> 1370</span>      <span class="comment">// We want to keep information for nonlocal lower-dimensional secondary element point</span></div>
<div class="line"><span class="lineno"> 1371</span>      <span class="comment">// neighbors for mortar nodal aux kernels</span></div>
<div class="line"><span class="lineno"> 1372</span>      <a class="code hl_variable" href="classAutomaticMortarGeneration.html#ab2357a3aacfa2cae90078e3b6293bf26">_mortar_interface_coupling</a>[secondary_elem-&gt;id()].insert(</div>
<div class="line"><span class="lineno"> 1373</span>          secondary_elem-&gt;interior_parent()-&gt;id());</div>
<div class="line"><span class="lineno"> 1374</span> </div>
<div class="line"><span class="lineno"> 1375</span>    <span class="comment">// LowerPrimary</span></div>
<div class="line"><span class="lineno"> 1376</span>    coupling_info[secondary_elem-&gt;processor_id()].emplace_back(</div>
<div class="line"><span class="lineno"> 1377</span>        secondary_elem-&gt;id(), primary_elem-&gt;interior_parent()-&gt;id());</div>
<div class="line"><span class="lineno"> 1378</span>    <span class="keywordflow">if</span> (secondary_elem-&gt;processor_id() != <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.processor_id())</div>
<div class="line"><span class="lineno"> 1379</span>      <span class="comment">// We want to keep information for nonlocal lower-dimensional secondary element point</span></div>
<div class="line"><span class="lineno"> 1380</span>      <span class="comment">// neighbors for mortar nodal aux kernels</span></div>
<div class="line"><span class="lineno"> 1381</span>      <a class="code hl_variable" href="classAutomaticMortarGeneration.html#ab2357a3aacfa2cae90078e3b6293bf26">_mortar_interface_coupling</a>[secondary_elem-&gt;id()].insert(</div>
<div class="line"><span class="lineno"> 1382</span>          primary_elem-&gt;interior_parent()-&gt;id());</div>
<div class="line"><span class="lineno"> 1383</span> </div>
<div class="line"><span class="lineno"> 1384</span>    <span class="comment">// Lower-LowerDimensionalPrimary</span></div>
<div class="line"><span class="lineno"> 1385</span>    coupling_info[secondary_elem-&gt;processor_id()].emplace_back(secondary_elem-&gt;id(),</div>
<div class="line"><span class="lineno"> 1386</span>                                                               primary_elem-&gt;id());</div>
<div class="line"><span class="lineno"> 1387</span>    <span class="keywordflow">if</span> (secondary_elem-&gt;processor_id() != <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.processor_id())</div>
<div class="line"><span class="lineno"> 1388</span>      <span class="comment">// We want to keep information for nonlocal lower-dimensional secondary element point</span></div>
<div class="line"><span class="lineno"> 1389</span>      <span class="comment">// neighbors for mortar nodal aux kernels</span></div>
<div class="line"><span class="lineno"> 1390</span>      <a class="code hl_variable" href="classAutomaticMortarGeneration.html#ab2357a3aacfa2cae90078e3b6293bf26">_mortar_interface_coupling</a>[secondary_elem-&gt;id()].insert(primary_elem-&gt;id());</div>
<div class="line"><span class="lineno"> 1391</span> </div>
<div class="line"><span class="lineno"> 1392</span>    <span class="comment">// SecondaryLower</span></div>
<div class="line"><span class="lineno"> 1393</span>    coupling_info[secondary_elem-&gt;interior_parent()-&gt;processor_id()].emplace_back(</div>
<div class="line"><span class="lineno"> 1394</span>        secondary_elem-&gt;interior_parent()-&gt;id(), secondary_elem-&gt;id());</div>
<div class="line"><span class="lineno"> 1395</span> </div>
<div class="line"><span class="lineno"> 1396</span>    <span class="comment">// SecondaryPrimary</span></div>
<div class="line"><span class="lineno"> 1397</span>    coupling_info[secondary_elem-&gt;interior_parent()-&gt;processor_id()].emplace_back(</div>
<div class="line"><span class="lineno"> 1398</span>        secondary_elem-&gt;interior_parent()-&gt;id(), primary_elem-&gt;interior_parent()-&gt;id());</div>
<div class="line"><span class="lineno"> 1399</span> </div>
<div class="line"><span class="lineno"> 1400</span>    <span class="comment">// PrimaryLower</span></div>
<div class="line"><span class="lineno"> 1401</span>    coupling_info[primary_elem-&gt;interior_parent()-&gt;processor_id()].emplace_back(</div>
<div class="line"><span class="lineno"> 1402</span>        primary_elem-&gt;interior_parent()-&gt;id(), secondary_elem-&gt;id());</div>
<div class="line"><span class="lineno"> 1403</span> </div>
<div class="line"><span class="lineno"> 1404</span>    <span class="comment">// PrimarySecondary</span></div>
<div class="line"><span class="lineno"> 1405</span>    coupling_info[primary_elem-&gt;interior_parent()-&gt;processor_id()].emplace_back(</div>
<div class="line"><span class="lineno"> 1406</span>        primary_elem-&gt;interior_parent()-&gt;id(), secondary_elem-&gt;interior_parent()-&gt;id());</div>
<div class="line"><span class="lineno"> 1407</span>  }</div>
<div class="line"><span class="lineno"> 1408</span> </div>
<div class="line"><span class="lineno"> 1409</span>  <span class="comment">// Push the coupling information</span></div>
<div class="line"><span class="lineno"> 1410</span>  <span class="keyword">auto</span> action_functor =</div>
<div class="line"><span class="lineno"> 1411</span>      [<span class="keyword">this</span>](processor_id_type,</div>
<div class="line"><span class="lineno"> 1412</span>             <span class="keyword">const</span> std::vector&lt;std::pair&lt;dof_id_type, dof_id_type&gt;&gt; &amp; coupling_info)</div>
<div class="line"><span class="lineno"> 1413</span>  {</div>
<div class="line"><span class="lineno"> 1414</span>    <span class="keywordflow">for</span> (<span class="keyword">auto</span> [i, j] : coupling_info)</div>
<div class="line"><span class="lineno"> 1415</span>      <a class="code hl_variable" href="classAutomaticMortarGeneration.html#ab2357a3aacfa2cae90078e3b6293bf26">_mortar_interface_coupling</a>[i].insert(j);</div>
<div class="line"><span class="lineno"> 1416</span>  };</div>
<div class="line"><span class="lineno"> 1417</span>  TIMPI::push_parallel_vector_data(<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.comm(), coupling_info, action_functor);</div>
<div class="line"><span class="lineno"> 1418</span>}</div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_ab2357a3aacfa2cae90078e3b6293bf26"><div class="ttname"><a href="classAutomaticMortarGeneration.html#ab2357a3aacfa2cae90078e3b6293bf26">AutomaticMortarGeneration::_mortar_interface_coupling</a></div><div class="ttdeci">std::unordered_map&lt; dof_id_type, std::unordered_set&lt; dof_id_type &gt; &gt; _mortar_interface_coupling</div><div class="ttdoc">Used by the AugmentSparsityOnInterface functor to determine whether a given Elem is coupled to any ot...</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00427">AutomaticMortarGeneration.h:427</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_abbd91d3cf8bef528976fe6f932622d2d"><div class="ttname"><a href="classAutomaticMortarGeneration.html#abbd91d3cf8bef528976fe6f932622d2d">AutomaticMortarGeneration::_msm_elem_to_info</a></div><div class="ttdeci">std::unordered_map&lt; const Elem *, MortarSegmentInfo &gt; _msm_elem_to_info</div><div class="ttdoc">Map between Elems in the mortar segment mesh and their info structs.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00404">AutomaticMortarGeneration.h:404</a></div></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00433">buildMortarSegmentMesh()</a>, and <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00930">buildMortarSegmentMesh3d()</a>.</p>

</div>
</div>
<a id="a3a49a5fc49ca76d1e89b938d3b3a202e" name="a3a49a5fc49ca76d1e89b938d3b3a202e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a49a5fc49ca76d1e89b938d3b3a202e">&#9670;&#160;</a></span>buildMortarSegmentMesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AutomaticMortarGeneration::buildMortarSegmentMesh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds the mortar segment mesh once the secondary and primary node projections have been completed. </p>
<p >Inputs:</p><ul>
<li>mesh</li>
<li>primary_node_and_elem_to_xi1_secondary_elem</li>
<li>secondary_node_and_elem_to_xi2_primary_elem</li>
<li>nodes_to_primary_elem_map</li>
</ul>
<p >Outputs:</p><ul>
<li>mortar_segment_mesh</li>
<li>msm_elem_to_info</li>
</ul>
<p >Defined in the file build_mortar_segment_mesh.C. </p>
<p >This was a change to how inactive LM DoFs are handled. Now mortar segment elements are not used in assembly if there is no corresponding primary element and inactive LM DoFs (those with no contribution to an active primary element) are zeroed.</p>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00433">433</a> of file <a class="el" href="AutomaticMortarGeneration_8C_source.html">AutomaticMortarGeneration.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  434</span>{</div>
<div class="line"><span class="lineno">  435</span>  dof_id_type local_id_index = 0;</div>
<div class="line"><span class="lineno">  436</span>  std::size_t node_unique_id_offset = 0;</div>
<div class="line"><span class="lineno">  437</span> </div>
<div class="line"><span class="lineno">  438</span>  <span class="comment">// Create an offset by the maximum number of mortar segment elements that can be created *plus*</span></div>
<div class="line"><span class="lineno">  439</span>  <span class="comment">// the number of lower-dimensional secondary subdomain elements. Recall that the number of mortar</span></div>
<div class="line"><span class="lineno">  440</span>  <span class="comment">// segments created is a function of node projection, *and* that if we split elems we will delete</span></div>
<div class="line"><span class="lineno">  441</span>  <span class="comment">// that elem which has already taken a unique id</span></div>
<div class="line"><span class="lineno">  442</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; pr : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a36e1a5b919de8cfdc39c8af4098fb450">_primary_secondary_boundary_id_pairs</a>)</div>
<div class="line"><span class="lineno">  443</span>  {</div>
<div class="line"><span class="lineno">  444</span>    <span class="keyword">const</span> <span class="keyword">auto</span> primary_bnd_id = pr.first;</div>
<div class="line"><span class="lineno">  445</span>    <span class="keyword">const</span> <span class="keyword">auto</span> secondary_bnd_id = pr.second;</div>
<div class="line"><span class="lineno">  446</span>    <span class="keyword">const</span> <span class="keyword">auto</span> num_primary_nodes =</div>
<div class="line"><span class="lineno">  447</span>        std::distance(<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.bid_nodes_begin(primary_bnd_id), <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.bid_nodes_end(primary_bnd_id));</div>
<div class="line"><span class="lineno">  448</span>    <span class="keyword">const</span> <span class="keyword">auto</span> num_secondary_nodes = std::distance(<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.bid_nodes_begin(secondary_bnd_id),</div>
<div class="line"><span class="lineno">  449</span>                                                   <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.bid_nodes_end(secondary_bnd_id));</div>
<div class="line"><span class="lineno">  450</span>    mooseAssert(num_primary_nodes,</div>
<div class="line"><span class="lineno">  451</span>                <span class="stringliteral">&quot;There are no primary nodes on boundary ID &quot;</span></div>
<div class="line"><span class="lineno">  452</span>                    &lt;&lt; primary_bnd_id &lt;&lt; <span class="stringliteral">&quot;. Does that bondary ID even exist on the mesh?&quot;</span>);</div>
<div class="line"><span class="lineno">  453</span>    mooseAssert(num_secondary_nodes,</div>
<div class="line"><span class="lineno">  454</span>                <span class="stringliteral">&quot;There are no secondary nodes on boundary ID &quot;</span></div>
<div class="line"><span class="lineno">  455</span>                    &lt;&lt; secondary_bnd_id &lt;&lt; <span class="stringliteral">&quot;. Does that bondary ID even exist on the mesh?&quot;</span>);</div>
<div class="line"><span class="lineno">  456</span> </div>
<div class="line"><span class="lineno">  457</span>    node_unique_id_offset += num_primary_nodes + 2 * num_secondary_nodes;</div>
<div class="line"><span class="lineno">  458</span>  }</div>
<div class="line"><span class="lineno">  459</span> </div>
<div class="line"><span class="lineno">  460</span>  <span class="comment">// 1.) Add all lower-dimensional secondary side elements as the &quot;initial&quot; mortar segments.</span></div>
<div class="line"><span class="lineno">  461</span>  <span class="keywordflow">for</span> (MeshBase::const_element_iterator el = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.active_elements_begin(),</div>
<div class="line"><span class="lineno">  462</span>                                        end_el = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.active_elements_end();</div>
<div class="line"><span class="lineno">  463</span>       el != end_el;</div>
<div class="line"><span class="lineno">  464</span>       ++el)</div>
<div class="line"><span class="lineno">  465</span>  {</div>
<div class="line"><span class="lineno">  466</span>    <span class="keyword">const</span> Elem * secondary_elem = *el;</div>
<div class="line"><span class="lineno">  467</span> </div>
<div class="line"><span class="lineno">  468</span>    <span class="comment">// If this is not one of the lower-dimensional secondary side elements, go on to the next one.</span></div>
<div class="line"><span class="lineno">  469</span>    <span class="keywordflow">if</span> (!this-&gt;<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a59c6fd297125023195e7bfb3714846c5">_secondary_boundary_subdomain_ids</a>.count(secondary_elem-&gt;subdomain_id()))</div>
<div class="line"><span class="lineno">  470</span>      <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno">  471</span> </div>
<div class="line"><span class="lineno">  472</span>    std::vector&lt;Node *&gt; new_nodes;</div>
<div class="line"><span class="lineno">  473</span>    <span class="keywordflow">for</span> (MooseIndex(secondary_elem-&gt;n_nodes()) n = 0; n &lt; secondary_elem-&gt;n_nodes(); ++n)</div>
<div class="line"><span class="lineno">  474</span>    {</div>
<div class="line"><span class="lineno">  475</span>      new_nodes.push_back(<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;add_point(</div>
<div class="line"><span class="lineno">  476</span>          secondary_elem-&gt;point(n), secondary_elem-&gt;node_id(n), secondary_elem-&gt;processor_id()));</div>
<div class="line"><span class="lineno">  477</span>      Node * <span class="keyword">const</span> new_node = new_nodes.back();</div>
<div class="line"><span class="lineno">  478</span>      new_node-&gt;set_unique_id(new_node-&gt;id() + node_unique_id_offset);</div>
<div class="line"><span class="lineno">  479</span>    }</div>
<div class="line"><span class="lineno">  480</span> </div>
<div class="line"><span class="lineno">  481</span>    std::unique_ptr&lt;Elem&gt; new_elem;</div>
<div class="line"><span class="lineno">  482</span>    <span class="keywordflow">if</span> (secondary_elem-&gt;default_order() == SECOND)</div>
<div class="line"><span class="lineno">  483</span>      new_elem = std::make_unique&lt;Edge3&gt;();</div>
<div class="line"><span class="lineno">  484</span>    <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  485</span>      new_elem = std::make_unique&lt;Edge2&gt;();</div>
<div class="line"><span class="lineno">  486</span> </div>
<div class="line"><span class="lineno">  487</span>    new_elem-&gt;processor_id() = secondary_elem-&gt;processor_id();</div>
<div class="line"><span class="lineno">  488</span>    new_elem-&gt;subdomain_id() = secondary_elem-&gt;subdomain_id();</div>
<div class="line"><span class="lineno">  489</span>    new_elem-&gt;set_id(local_id_index++);</div>
<div class="line"><span class="lineno">  490</span>    new_elem-&gt;set_unique_id(new_elem-&gt;id());</div>
<div class="line"><span class="lineno">  491</span> </div>
<div class="line"><span class="lineno">  492</span>    <span class="keywordflow">for</span> (MooseIndex(new_elem-&gt;n_nodes()) n = 0; n &lt; new_elem-&gt;n_nodes(); ++n)</div>
<div class="line"><span class="lineno">  493</span>      new_elem-&gt;set_node(n) = new_nodes[n];</div>
<div class="line"><span class="lineno">  494</span> </div>
<div class="line"><span class="lineno">  495</span>    Elem * new_elem_ptr = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;add_elem(new_elem.release());</div>
<div class="line"><span class="lineno">  496</span> </div>
<div class="line"><span class="lineno">  497</span>    <span class="comment">// The xi^(1) values for this mortar segment are initially -1 and 1.</span></div>
<div class="line"><span class="lineno">  498</span>    <a class="code hl_struct" href="structMortarSegmentInfo.html">MortarSegmentInfo</a> msinfo;</div>
<div class="line"><span class="lineno">  499</span>    msinfo.<a class="code hl_variable" href="structMortarSegmentInfo.html#ad4205fbab31bbda066622c55c8e93b87">xi1_a</a> = -1;</div>
<div class="line"><span class="lineno">  500</span>    msinfo.<a class="code hl_variable" href="structMortarSegmentInfo.html#a648c7f480b2ce6404b1db1d21642b919">xi1_b</a> = +1;</div>
<div class="line"><span class="lineno">  501</span>    msinfo.<a class="code hl_variable" href="structMortarSegmentInfo.html#afa8c2918a473f0dad90d5c68dad00eb4">secondary_elem</a> = secondary_elem;</div>
<div class="line"><span class="lineno">  502</span> </div>
<div class="line"><span class="lineno">  503</span>    <span class="keyword">auto</span> new_container_it0 = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#abb4cc3e3102675e52675a95347ad8e95">_secondary_node_and_elem_to_xi2_primary_elem</a>.find(</div>
<div class="line"><span class="lineno">  504</span>             std::make_pair(secondary_elem-&gt;node_ptr(0), secondary_elem)),</div>
<div class="line"><span class="lineno">  505</span>         new_container_it1 = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#abb4cc3e3102675e52675a95347ad8e95">_secondary_node_and_elem_to_xi2_primary_elem</a>.find(</div>
<div class="line"><span class="lineno">  506</span>             std::make_pair(secondary_elem-&gt;node_ptr(1), secondary_elem));</div>
<div class="line"><span class="lineno">  507</span> </div>
<div class="line"><span class="lineno">  508</span>    <span class="keywordtype">bool</span> new_container_node0_found =</div>
<div class="line"><span class="lineno">  509</span>             (new_container_it0 != <a class="code hl_variable" href="classAutomaticMortarGeneration.html#abb4cc3e3102675e52675a95347ad8e95">_secondary_node_and_elem_to_xi2_primary_elem</a>.end()),</div>
<div class="line"><span class="lineno">  510</span>         new_container_node1_found =</div>
<div class="line"><span class="lineno">  511</span>             (new_container_it1 != <a class="code hl_variable" href="classAutomaticMortarGeneration.html#abb4cc3e3102675e52675a95347ad8e95">_secondary_node_and_elem_to_xi2_primary_elem</a>.end());</div>
<div class="line"><span class="lineno">  512</span> </div>
<div class="line"><span class="lineno">  513</span>    <span class="keyword">const</span> Elem * node0_primary_candidate = <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno">  514</span>    <span class="keyword">const</span> Elem * node1_primary_candidate = <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno">  515</span> </div>
<div class="line"><span class="lineno">  516</span>    <span class="keywordflow">if</span> (new_container_node0_found)</div>
<div class="line"><span class="lineno">  517</span>    {</div>
<div class="line"><span class="lineno">  518</span>      <span class="keyword">const</span> <span class="keyword">auto</span> &amp; xi2_primary_elem_pair = new_container_it0-&gt;second;</div>
<div class="line"><span class="lineno">  519</span>      msinfo.<a class="code hl_variable" href="structMortarSegmentInfo.html#abcfb0183363f3e21b43f9ffd3dc477b4">xi2_a</a> = xi2_primary_elem_pair.first;</div>
<div class="line"><span class="lineno">  520</span>      node0_primary_candidate = xi2_primary_elem_pair.second;</div>
<div class="line"><span class="lineno">  521</span>    }</div>
<div class="line"><span class="lineno">  522</span> </div>
<div class="line"><span class="lineno">  523</span>    <span class="keywordflow">if</span> (new_container_node1_found)</div>
<div class="line"><span class="lineno">  524</span>    {</div>
<div class="line"><span class="lineno">  525</span>      <span class="keyword">const</span> <span class="keyword">auto</span> &amp; xi2_primary_elem_pair = new_container_it1-&gt;second;</div>
<div class="line"><span class="lineno">  526</span>      msinfo.<a class="code hl_variable" href="structMortarSegmentInfo.html#a4fe559d3196b77718c1052ab7c1aa4d3">xi2_b</a> = xi2_primary_elem_pair.first;</div>
<div class="line"><span class="lineno">  527</span>      node1_primary_candidate = xi2_primary_elem_pair.second;</div>
<div class="line"><span class="lineno">  528</span>    }</div>
<div class="line"><span class="lineno">  529</span> </div>
<div class="line"><span class="lineno">  530</span>    <span class="comment">// If both node0 and node1 agree on the primary element they are</span></div>
<div class="line"><span class="lineno">  531</span>    <span class="comment">// projected into, then this mortar segment fits entirely within</span></div>
<div class="line"><span class="lineno">  532</span>    <span class="comment">// a single primary element, and we can go ahead and set the</span></div>
<div class="line"><span class="lineno">  533</span>    <span class="comment">// msinfo.primary_elem pointer now.</span></div>
<div class="line"><span class="lineno">  534</span>    <span class="keywordflow">if</span> (node0_primary_candidate == node1_primary_candidate)</div>
<div class="line"><span class="lineno">  535</span>      msinfo.<a class="code hl_variable" href="structMortarSegmentInfo.html#a3316fbff8584e06e3c973d3f3e6ff05f">primary_elem</a> = node0_primary_candidate;</div>
<div class="line"><span class="lineno">  536</span> </div>
<div class="line"><span class="lineno">  537</span>    <span class="comment">// Associate this MSM elem with the MortarSegmentInfo.</span></div>
<div class="line"><span class="lineno">  538</span>    <a class="code hl_variable" href="classAutomaticMortarGeneration.html#abbd91d3cf8bef528976fe6f932622d2d">_msm_elem_to_info</a>.emplace(new_elem_ptr, msinfo);</div>
<div class="line"><span class="lineno">  539</span> </div>
<div class="line"><span class="lineno">  540</span>    <span class="comment">// Maintain the mapping between secondary elems and mortar segment elems contained within them.</span></div>
<div class="line"><span class="lineno">  541</span>    <span class="comment">// Initially, only the original secondary_elem is present.</span></div>
<div class="line"><span class="lineno">  542</span>    <a class="code hl_variable" href="classAutomaticMortarGeneration.html#af0da3b7d9e404238718805e12452d74d">_secondary_elems_to_mortar_segments</a>[secondary_elem-&gt;id()].insert(new_elem_ptr);</div>
<div class="line"><span class="lineno">  543</span>  }</div>
<div class="line"><span class="lineno">  544</span> </div>
<div class="line"><span class="lineno">  545</span>  <span class="comment">// 2.) Insert new nodes from primary side and split mortar segments as necessary.</span></div>
<div class="line"><span class="lineno">  546</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; pr : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#ac174eedb02e9681baf439360903700d4">_primary_node_and_elem_to_xi1_secondary_elem</a>)</div>
<div class="line"><span class="lineno">  547</span>  {</div>
<div class="line"><span class="lineno">  548</span>    <span class="keyword">auto</span> key = pr.first;</div>
<div class="line"><span class="lineno">  549</span>    <span class="keyword">auto</span> val = pr.second;</div>
<div class="line"><span class="lineno">  550</span> </div>
<div class="line"><span class="lineno">  551</span>    <span class="keyword">const</span> Node * primary_node = std::get&lt;1&gt;(key);</div>
<div class="line"><span class="lineno">  552</span>    Real xi1 = val.first;</div>
<div class="line"><span class="lineno">  553</span>    <span class="keyword">const</span> Elem * secondary_elem = val.second;</div>
<div class="line"><span class="lineno">  554</span> </div>
<div class="line"><span class="lineno">  555</span>    <span class="comment">// If this is an aligned node, we don&#39;t need to do anything.</span></div>
<div class="line"><span class="lineno">  556</span>    <span class="keywordflow">if</span> (std::abs(std::abs(xi1) - 1.) &lt; <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a25f6f147b1b0a4b00e7c6739dd17b98c">_xi_tolerance</a>)</div>
<div class="line"><span class="lineno">  557</span>      <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno">  558</span> </div>
<div class="line"><span class="lineno">  559</span>    <span class="keyword">auto</span> &amp;&amp; order = secondary_elem-&gt;default_order();</div>
<div class="line"><span class="lineno">  560</span> </div>
<div class="line"><span class="lineno">  561</span>    <span class="comment">// Determine physical location of new point to be inserted.</span></div>
<div class="line"><span class="lineno">  562</span>    Point new_pt(0);</div>
<div class="line"><span class="lineno">  563</span>    <span class="keywordflow">for</span> (MooseIndex(secondary_elem-&gt;n_nodes()) n = 0; n &lt; secondary_elem-&gt;n_nodes(); ++n)</div>
<div class="line"><span class="lineno">  564</span>      new_pt += <a class="code hl_function" href="namespaceMoose.html#a9ed3373b5072c07f1f010afb75ac20c9">Moose::fe_lagrange_1D_shape</a>(order, n, xi1) * secondary_elem-&gt;point(n);</div>
<div class="line"><span class="lineno">  565</span> </div>
<div class="line"><span class="lineno">  566</span>    <span class="comment">// Find the current mortar segment that will have to be split.</span></div>
<div class="line"><span class="lineno">  567</span>    <span class="keyword">auto</span> &amp; mortar_segment_set = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#af0da3b7d9e404238718805e12452d74d">_secondary_elems_to_mortar_segments</a>[secondary_elem-&gt;id()];</div>
<div class="line"><span class="lineno">  568</span>    Elem * current_mortar_segment = <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno">  569</span>    <a class="code hl_struct" href="structMortarSegmentInfo.html">MortarSegmentInfo</a> * info = <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno">  570</span> </div>
<div class="line"><span class="lineno">  571</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; mortar_segment_candidate : mortar_segment_set)</div>
<div class="line"><span class="lineno">  572</span>    {</div>
<div class="line"><span class="lineno">  573</span>      <span class="keywordflow">try</span></div>
<div class="line"><span class="lineno">  574</span>      {</div>
<div class="line"><span class="lineno">  575</span>        info = &amp;<a class="code hl_variable" href="classAutomaticMortarGeneration.html#abbd91d3cf8bef528976fe6f932622d2d">_msm_elem_to_info</a>.at(mortar_segment_candidate);</div>
<div class="line"><span class="lineno">  576</span>      }</div>
<div class="line"><span class="lineno">  577</span>      <span class="keywordflow">catch</span> (std::out_of_range &amp;)</div>
<div class="line"><span class="lineno">  578</span>      {</div>
<div class="line"><span class="lineno">  579</span>        <a class="code hl_function" href="MooseError_8h.html#aa959168eed29caa7aaa85ffc1319a9ad">mooseError</a>(<span class="stringliteral">&quot;MortarSegmentInfo not found for the mortar segment candidate&quot;</span>);</div>
<div class="line"><span class="lineno">  580</span>      }</div>
<div class="line"><span class="lineno">  581</span>      <span class="keywordflow">if</span> (info-&gt;<a class="code hl_variable" href="structMortarSegmentInfo.html#ad4205fbab31bbda066622c55c8e93b87">xi1_a</a> &lt;= xi1 &amp;&amp; xi1 &lt;= info-&gt;xi1_b)</div>
<div class="line"><span class="lineno">  582</span>      {</div>
<div class="line"><span class="lineno">  583</span>        current_mortar_segment = mortar_segment_candidate;</div>
<div class="line"><span class="lineno">  584</span>        <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  585</span>      }</div>
<div class="line"><span class="lineno">  586</span>    }</div>
<div class="line"><span class="lineno">  587</span> </div>
<div class="line"><span class="lineno">  588</span>    <span class="comment">// Make sure we found one.</span></div>
<div class="line"><span class="lineno">  589</span>    <span class="keywordflow">if</span> (current_mortar_segment == <span class="keyword">nullptr</span>)</div>
<div class="line"><span class="lineno">  590</span>      <a class="code hl_function" href="MooseError_8h.html#aa959168eed29caa7aaa85ffc1319a9ad">mooseError</a>(<span class="stringliteral">&quot;Unable to find appropriate mortar segment during linear search!&quot;</span>);</div>
<div class="line"><span class="lineno">  591</span> </div>
<div class="line"><span class="lineno">  592</span>    <span class="comment">// If node lands on endpoint of segment, don&#39;t split.</span></div>
<div class="line"><span class="lineno">  593</span>    <span class="comment">// Jacob: This condition was getting missed by the &lt; comparison a few lines above. To fix it I</span></div>
<div class="line"><span class="lineno">  594</span>    <span class="comment">// just made it &lt;= and put this condition in to handle equality different. It probably could be</span></div>
<div class="line"><span class="lineno">  595</span>    <span class="comment">// done with a tolerance but the the toleranced equality is already handled later when we drop</span></div>
<div class="line"><span class="lineno">  596</span>    <span class="comment">// segments with small volume.</span></div>
<div class="line"><span class="lineno">  597</span>    <span class="keywordflow">if</span> (info-&gt;<a class="code hl_variable" href="structMortarSegmentInfo.html#ad4205fbab31bbda066622c55c8e93b87">xi1_a</a> == xi1 || xi1 == info-&gt;<a class="code hl_variable" href="structMortarSegmentInfo.html#a648c7f480b2ce6404b1db1d21642b919">xi1_b</a>)</div>
<div class="line"><span class="lineno">  598</span>      <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno">  599</span> </div>
<div class="line"><span class="lineno">  600</span>    <span class="keyword">const</span> <span class="keyword">auto</span> new_id = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;max_node_id() + 1;</div>
<div class="line"><span class="lineno">  601</span>    mooseAssert(<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;comm().verify(new_id),</div>
<div class="line"><span class="lineno">  602</span>                <span class="stringliteral">&quot;new_id must be the same on all processes&quot;</span>);</div>
<div class="line"><span class="lineno">  603</span>    Node * <span class="keyword">const</span> new_node =</div>
<div class="line"><span class="lineno">  604</span>        <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;add_point(new_pt, new_id, secondary_elem-&gt;processor_id());</div>
<div class="line"><span class="lineno">  605</span>    new_node-&gt;set_unique_id(new_id + node_unique_id_offset);</div>
<div class="line"><span class="lineno">  606</span> </div>
<div class="line"><span class="lineno">  607</span>    <span class="comment">// Reconstruct the nodal normal at xi1. This will help us</span></div>
<div class="line"><span class="lineno">  608</span>    <span class="comment">// determine the orientation of the primary elems relative to the</span></div>
<div class="line"><span class="lineno">  609</span>    <span class="comment">// new mortar segments.</span></div>
<div class="line"><span class="lineno">  610</span>    <span class="keyword">const</span> Point normal = <a class="code hl_function" href="classAutomaticMortarGeneration.html#a71eb5cecb4437a9a0edfe8d5ce38007e">getNormals</a>(*secondary_elem, std::vector&lt;Real&gt;({xi1}))[0];</div>
<div class="line"><span class="lineno">  611</span> </div>
<div class="line"><span class="lineno">  612</span>    <span class="comment">// Get the set of primary_node neighbors.</span></div>
<div class="line"><span class="lineno">  613</span>    <span class="keywordflow">if</span> (this-&gt;<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a1ee9b6e4f8bd88603e22117085758f70">_nodes_to_primary_elem_map</a>.find(primary_node-&gt;id()) ==</div>
<div class="line"><span class="lineno">  614</span>        this-&gt;_nodes_to_primary_elem_map.end())</div>
<div class="line"><span class="lineno">  615</span>      <a class="code hl_function" href="MooseError_8h.html#aa959168eed29caa7aaa85ffc1319a9ad">mooseError</a>(<span class="stringliteral">&quot;We should already have built this primary node to elem pair!&quot;</span>);</div>
<div class="line"><span class="lineno">  616</span>    <span class="keyword">const</span> std::vector&lt;const Elem *&gt; &amp; primary_node_neighbors =</div>
<div class="line"><span class="lineno">  617</span>        this-&gt;<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a1ee9b6e4f8bd88603e22117085758f70">_nodes_to_primary_elem_map</a>[primary_node-&gt;id()];</div>
<div class="line"><span class="lineno">  618</span> </div>
<div class="line"><span class="lineno">  619</span>    <span class="comment">// Sanity check</span></div>
<div class="line"><span class="lineno">  620</span>    <span class="keywordflow">if</span> (primary_node_neighbors.size() == 0 || primary_node_neighbors.size() &gt; 2)</div>
<div class="line"><span class="lineno">  621</span>      <a class="code hl_function" href="MooseError_8h.html#aa959168eed29caa7aaa85ffc1319a9ad">mooseError</a>(<span class="stringliteral">&quot;We must have either 1 or 2 primary side nodal neighbors, but we had &quot;</span>,</div>
<div class="line"><span class="lineno">  622</span>                 primary_node_neighbors.size());</div>
<div class="line"><span class="lineno">  623</span> </div>
<div class="line"><span class="lineno">  624</span>    <span class="comment">// Primary Elem pointers which we will eventually assign to the</span></div>
<div class="line"><span class="lineno">  625</span>    <span class="comment">// mortar segments being created.  We start by assuming</span></div>
<div class="line"><span class="lineno">  626</span>    <span class="comment">// primary_node_neighbor[0] is on the &quot;left&quot; and</span></div>
<div class="line"><span class="lineno">  627</span>    <span class="comment">// primary_node_neighbor[1]/&quot;nothing&quot; is on the &quot;right&quot; and then</span></div>
<div class="line"><span class="lineno">  628</span>    <span class="comment">// swap them if that&#39;s not the case.</span></div>
<div class="line"><span class="lineno">  629</span>    <span class="keyword">const</span> Elem * left_primary_elem = primary_node_neighbors[0];</div>
<div class="line"><span class="lineno">  630</span>    <span class="keyword">const</span> Elem * right_primary_elem =</div>
<div class="line"><span class="lineno">  631</span>        (primary_node_neighbors.size() == 2) ? primary_node_neighbors[1] : <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno">  632</span> </div>
<div class="line"><span class="lineno">  633</span>    Real left_xi2 = <a class="code hl_variable" href="structMortarSegmentInfo.html#ae240d424b2112e4d23e66597318160ca">MortarSegmentInfo::invalid_xi</a>, right_xi2 = <a class="code hl_variable" href="structMortarSegmentInfo.html#ae240d424b2112e4d23e66597318160ca">MortarSegmentInfo::invalid_xi</a>;</div>
<div class="line"><span class="lineno">  634</span> </div>
<div class="line"><span class="lineno">  635</span>    <span class="comment">// Storage for z-component of cross products for determining</span></div>
<div class="line"><span class="lineno">  636</span>    <span class="comment">// orientation.</span></div>
<div class="line"><span class="lineno">  637</span>    std::array&lt;Real, 2&gt; secondary_node_cps;</div>
<div class="line"><span class="lineno">  638</span>    std::vector&lt;Real&gt; primary_node_cps(primary_node_neighbors.size());</div>
<div class="line"><span class="lineno">  639</span> </div>
<div class="line"><span class="lineno">  640</span>    <span class="comment">// Store z-component of left and right secondary node cross products with the nodal normal.</span></div>
<div class="line"><span class="lineno">  641</span>    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nid = 0; nid &lt; 2; ++nid)</div>
<div class="line"><span class="lineno">  642</span>      secondary_node_cps[nid] = normal.cross(secondary_elem-&gt;point(nid) - new_pt)(2);</div>
<div class="line"><span class="lineno">  643</span> </div>
<div class="line"><span class="lineno">  644</span>    <span class="keywordflow">for</span> (MooseIndex(primary_node_neighbors) mnn = 0; mnn &lt; primary_node_neighbors.size(); ++mnn)</div>
<div class="line"><span class="lineno">  645</span>    {</div>
<div class="line"><span class="lineno">  646</span>      <span class="keyword">const</span> Elem * primary_neigh = primary_node_neighbors[mnn];</div>
<div class="line"><span class="lineno">  647</span>      Point opposite = (primary_neigh-&gt;node_ptr(0) == primary_node) ? primary_neigh-&gt;point(1)</div>
<div class="line"><span class="lineno">  648</span>                                                                    : primary_neigh-&gt;point(0);</div>
<div class="line"><span class="lineno">  649</span>      Point cp = normal.cross(opposite - new_pt);</div>
<div class="line"><span class="lineno">  650</span>      primary_node_cps[mnn] = cp(2);</div>
<div class="line"><span class="lineno">  651</span>    }</div>
<div class="line"><span class="lineno">  652</span> </div>
<div class="line"><span class="lineno">  653</span>    <span class="comment">// We will verify that only 1 orientation is actually valid.</span></div>
<div class="line"><span class="lineno">  654</span>    <span class="keywordtype">bool</span> orientation1_valid = <span class="keyword">false</span>, orientation2_valid = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  655</span> </div>
<div class="line"><span class="lineno">  656</span>    <span class="keywordflow">if</span> (primary_node_neighbors.size() == 2)</div>
<div class="line"><span class="lineno">  657</span>    {</div>
<div class="line"><span class="lineno">  658</span>      <span class="comment">// 2 primary neighbor case</span></div>
<div class="line"><span class="lineno">  659</span>      orientation1_valid = (secondary_node_cps[0] * primary_node_cps[0] &gt; 0.) &amp;&amp;</div>
<div class="line"><span class="lineno">  660</span>                           (secondary_node_cps[1] * primary_node_cps[1] &gt; 0.);</div>
<div class="line"><span class="lineno">  661</span> </div>
<div class="line"><span class="lineno">  662</span>      orientation2_valid = (secondary_node_cps[0] * primary_node_cps[1] &gt; 0.) &amp;&amp;</div>
<div class="line"><span class="lineno">  663</span>                           (secondary_node_cps[1] * primary_node_cps[0] &gt; 0.);</div>
<div class="line"><span class="lineno">  664</span>    }</div>
<div class="line"><span class="lineno">  665</span>    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (primary_node_neighbors.size() == 1)</div>
<div class="line"><span class="lineno">  666</span>    {</div>
<div class="line"><span class="lineno">  667</span>      <span class="comment">// 1 primary neighbor case</span></div>
<div class="line"><span class="lineno">  668</span>      orientation1_valid = (secondary_node_cps[0] * primary_node_cps[0] &gt; 0.);</div>
<div class="line"><span class="lineno">  669</span>      orientation2_valid = (secondary_node_cps[1] * primary_node_cps[0] &gt; 0.);</div>
<div class="line"><span class="lineno">  670</span>    }</div>
<div class="line"><span class="lineno">  671</span>    <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  672</span>      <a class="code hl_function" href="MooseError_8h.html#aa959168eed29caa7aaa85ffc1319a9ad">mooseError</a>(<span class="stringliteral">&quot;Invalid primary node neighbors size &quot;</span>, primary_node_neighbors.size());</div>
<div class="line"><span class="lineno">  673</span> </div>
<div class="line"><span class="lineno">  674</span>    <span class="comment">// Verify that both orientations are not simultaneously valid/invalid. If they are not, then we</span></div>
<div class="line"><span class="lineno">  675</span>    <span class="comment">// are going to throw an exception instead of erroring out since we can easily reach this point</span></div>
<div class="line"><span class="lineno">  676</span>    <span class="comment">// if we have one bad linear solve. It&#39;s better in general to catch the error and then try a</span></div>
<div class="line"><span class="lineno">  677</span>    <span class="comment">// smaller time-step</span></div>
<div class="line"><span class="lineno">  678</span>    <span class="keywordflow">if</span> (orientation1_valid &amp;&amp; orientation2_valid)</div>
<div class="line"><span class="lineno">  679</span>      <span class="keywordflow">throw</span> <a class="code hl_class" href="classMooseException.html">MooseException</a>(</div>
<div class="line"><span class="lineno">  680</span>          <span class="stringliteral">&quot;AutomaticMortarGeneration: Both orientations cannot simultaneously be valid.&quot;</span>);</div>
<div class="line"><span class="lineno">  681</span> </div>
<div class="line"><span class="lineno">  682</span>    <span class="comment">// We are going to treat the case where both orientations are invalid as a case in which we</span></div>
<div class="line"><span class="lineno">  683</span>    <span class="comment">// should not be splitting the mortar mesh to incorporate primary mesh elements.</span></div>
<div class="line"><span class="lineno">  684</span>    <span class="comment">// In practice, this case has appeared for very oblique projections, so we assume these cases</span></div>
<div class="line"><span class="lineno">  685</span>    <span class="comment">// will not be considered in mortar thermomechanical contact.</span></div>
<div class="line"><span class="lineno">  686</span>    <span class="keywordflow">if</span> (!orientation1_valid &amp;&amp; !orientation2_valid)</div>
<div class="line"><span class="lineno">  687</span>    {</div>
<div class="line"><span class="lineno">  688</span>      mooseDoOnce(<a class="code hl_function" href="MooseError_8h.html#a3d351254665674621ecbd38f57bb28ae">mooseWarning</a>(</div>
<div class="line"><span class="lineno">  689</span>          <span class="stringliteral">&quot;AutomaticMortarGeneration: Unable to determine valid secondary-primary orientation. &quot;</span></div>
<div class="line"><span class="lineno">  690</span>          <span class="stringliteral">&quot;Consequently we will consider projection of the primary node invalid and not split the &quot;</span></div>
<div class="line"><span class="lineno">  691</span>          <span class="stringliteral">&quot;mortar segment. &quot;</span></div>
<div class="line"><span class="lineno">  692</span>          <span class="stringliteral">&quot;This situation can indicate there are very oblique projections between primary (mortar) &quot;</span></div>
<div class="line"><span class="lineno">  693</span>          <span class="stringliteral">&quot;and secondary (non-mortar) surfaces for a good problem set up. It can also mean your &quot;</span></div>
<div class="line"><span class="lineno">  694</span>          <span class="stringliteral">&quot;time step is too large. This message is only printed once.&quot;</span>));</div>
<div class="line"><span class="lineno">  695</span>      <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno">  696</span>    }</div>
<div class="line"><span class="lineno">  697</span> </div>
<div class="line"><span class="lineno">  698</span>    <span class="comment">// Make an Elem on the left</span></div>
<div class="line"><span class="lineno">  699</span>    std::unique_ptr&lt;Elem&gt; new_elem_left;</div>
<div class="line"><span class="lineno">  700</span>    <span class="keywordflow">if</span> (order == SECOND)</div>
<div class="line"><span class="lineno">  701</span>      new_elem_left = std::make_unique&lt;Edge3&gt;();</div>
<div class="line"><span class="lineno">  702</span>    <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  703</span>      new_elem_left = std::make_unique&lt;Edge2&gt;();</div>
<div class="line"><span class="lineno">  704</span> </div>
<div class="line"><span class="lineno">  705</span>    new_elem_left-&gt;processor_id() = current_mortar_segment-&gt;processor_id();</div>
<div class="line"><span class="lineno">  706</span>    new_elem_left-&gt;subdomain_id() = current_mortar_segment-&gt;subdomain_id();</div>
<div class="line"><span class="lineno">  707</span>    new_elem_left-&gt;set_id(local_id_index++);</div>
<div class="line"><span class="lineno">  708</span>    new_elem_left-&gt;set_unique_id(new_elem_left-&gt;id());</div>
<div class="line"><span class="lineno">  709</span>    new_elem_left-&gt;set_node(0) = current_mortar_segment-&gt;node_ptr(0);</div>
<div class="line"><span class="lineno">  710</span>    new_elem_left-&gt;set_node(1) = new_node;</div>
<div class="line"><span class="lineno">  711</span> </div>
<div class="line"><span class="lineno">  712</span>    <span class="comment">// Make an Elem on the right</span></div>
<div class="line"><span class="lineno">  713</span>    std::unique_ptr&lt;Elem&gt; new_elem_right;</div>
<div class="line"><span class="lineno">  714</span>    <span class="keywordflow">if</span> (order == SECOND)</div>
<div class="line"><span class="lineno">  715</span>      new_elem_right = std::make_unique&lt;Edge3&gt;();</div>
<div class="line"><span class="lineno">  716</span>    <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  717</span>      new_elem_right = std::make_unique&lt;Edge2&gt;();</div>
<div class="line"><span class="lineno">  718</span> </div>
<div class="line"><span class="lineno">  719</span>    new_elem_right-&gt;processor_id() = current_mortar_segment-&gt;processor_id();</div>
<div class="line"><span class="lineno">  720</span>    new_elem_right-&gt;subdomain_id() = current_mortar_segment-&gt;subdomain_id();</div>
<div class="line"><span class="lineno">  721</span>    new_elem_right-&gt;set_id(local_id_index++);</div>
<div class="line"><span class="lineno">  722</span>    new_elem_right-&gt;set_unique_id(new_elem_right-&gt;id());</div>
<div class="line"><span class="lineno">  723</span>    new_elem_right-&gt;set_node(0) = new_node;</div>
<div class="line"><span class="lineno">  724</span>    new_elem_right-&gt;set_node(1) = current_mortar_segment-&gt;node_ptr(1);</div>
<div class="line"><span class="lineno">  725</span> </div>
<div class="line"><span class="lineno">  726</span>    <span class="keywordflow">if</span> (order == SECOND)</div>
<div class="line"><span class="lineno">  727</span>    {</div>
<div class="line"><span class="lineno">  728</span>      <span class="comment">// left</span></div>
<div class="line"><span class="lineno">  729</span>      Point left_interior_point(0);</div>
<div class="line"><span class="lineno">  730</span>      Real left_interior_xi = (xi1 + info-&gt;<a class="code hl_variable" href="structMortarSegmentInfo.html#ad4205fbab31bbda066622c55c8e93b87">xi1_a</a>) / 2;</div>
<div class="line"><span class="lineno">  731</span> </div>
<div class="line"><span class="lineno">  732</span>      <span class="comment">// This is eta for the current mortar segment that we&#39;re splitting</span></div>
<div class="line"><span class="lineno">  733</span>      Real current_left_interior_eta =</div>
<div class="line"><span class="lineno">  734</span>          (2. * left_interior_xi - info-&gt;<a class="code hl_variable" href="structMortarSegmentInfo.html#ad4205fbab31bbda066622c55c8e93b87">xi1_a</a> - info-&gt;<a class="code hl_variable" href="structMortarSegmentInfo.html#a648c7f480b2ce6404b1db1d21642b919">xi1_b</a>) / (info-&gt;<a class="code hl_variable" href="structMortarSegmentInfo.html#a648c7f480b2ce6404b1db1d21642b919">xi1_b</a> - info-&gt;<a class="code hl_variable" href="structMortarSegmentInfo.html#ad4205fbab31bbda066622c55c8e93b87">xi1_a</a>);</div>
<div class="line"><span class="lineno">  735</span> </div>
<div class="line"><span class="lineno">  736</span>      <span class="keywordflow">for</span> (MooseIndex(current_mortar_segment-&gt;n_nodes()) n = 0;</div>
<div class="line"><span class="lineno">  737</span>           n &lt; current_mortar_segment-&gt;n_nodes();</div>
<div class="line"><span class="lineno">  738</span>           ++n)</div>
<div class="line"><span class="lineno">  739</span>        left_interior_point += <a class="code hl_function" href="namespaceMoose.html#a9ed3373b5072c07f1f010afb75ac20c9">Moose::fe_lagrange_1D_shape</a>(order, n, current_left_interior_eta) *</div>
<div class="line"><span class="lineno">  740</span>                               current_mortar_segment-&gt;point(n);</div>
<div class="line"><span class="lineno">  741</span> </div>
<div class="line"><span class="lineno">  742</span>      <span class="keyword">const</span> <span class="keyword">auto</span> new_interior_left_id = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;max_node_id() + 1;</div>
<div class="line"><span class="lineno">  743</span>      mooseAssert(<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;comm().verify(new_interior_left_id),</div>
<div class="line"><span class="lineno">  744</span>                  <span class="stringliteral">&quot;new_id must be the same on all processes&quot;</span>);</div>
<div class="line"><span class="lineno">  745</span>      Node * <span class="keyword">const</span> new_interior_node_left = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;add_point(</div>
<div class="line"><span class="lineno">  746</span>          left_interior_point, new_interior_left_id, new_elem_left-&gt;processor_id());</div>
<div class="line"><span class="lineno">  747</span>      new_elem_left-&gt;set_node(2) = new_interior_node_left;</div>
<div class="line"><span class="lineno">  748</span>      new_interior_node_left-&gt;set_unique_id(new_interior_left_id + node_unique_id_offset);</div>
<div class="line"><span class="lineno">  749</span> </div>
<div class="line"><span class="lineno">  750</span>      <span class="comment">// right</span></div>
<div class="line"><span class="lineno">  751</span>      Point right_interior_point(0);</div>
<div class="line"><span class="lineno">  752</span>      Real right_interior_xi = (xi1 + info-&gt;<a class="code hl_variable" href="structMortarSegmentInfo.html#a648c7f480b2ce6404b1db1d21642b919">xi1_b</a>) / 2;</div>
<div class="line"><span class="lineno">  753</span>      <span class="comment">// This is eta for the current mortar segment that we&#39;re splitting</span></div>
<div class="line"><span class="lineno">  754</span>      Real current_right_interior_eta =</div>
<div class="line"><span class="lineno">  755</span>          (2. * right_interior_xi - info-&gt;<a class="code hl_variable" href="structMortarSegmentInfo.html#ad4205fbab31bbda066622c55c8e93b87">xi1_a</a> - info-&gt;<a class="code hl_variable" href="structMortarSegmentInfo.html#a648c7f480b2ce6404b1db1d21642b919">xi1_b</a>) / (info-&gt;<a class="code hl_variable" href="structMortarSegmentInfo.html#a648c7f480b2ce6404b1db1d21642b919">xi1_b</a> - info-&gt;<a class="code hl_variable" href="structMortarSegmentInfo.html#ad4205fbab31bbda066622c55c8e93b87">xi1_a</a>);</div>
<div class="line"><span class="lineno">  756</span> </div>
<div class="line"><span class="lineno">  757</span>      <span class="keywordflow">for</span> (MooseIndex(current_mortar_segment-&gt;n_nodes()) n = 0;</div>
<div class="line"><span class="lineno">  758</span>           n &lt; current_mortar_segment-&gt;n_nodes();</div>
<div class="line"><span class="lineno">  759</span>           ++n)</div>
<div class="line"><span class="lineno">  760</span>        right_interior_point += <a class="code hl_function" href="namespaceMoose.html#a9ed3373b5072c07f1f010afb75ac20c9">Moose::fe_lagrange_1D_shape</a>(order, n, current_right_interior_eta) *</div>
<div class="line"><span class="lineno">  761</span>                                current_mortar_segment-&gt;point(n);</div>
<div class="line"><span class="lineno">  762</span> </div>
<div class="line"><span class="lineno">  763</span>      <span class="keyword">const</span> <span class="keyword">auto</span> new_interior_id_right = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;max_node_id() + 1;</div>
<div class="line"><span class="lineno">  764</span>      mooseAssert(<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;comm().verify(new_interior_id_right),</div>
<div class="line"><span class="lineno">  765</span>                  <span class="stringliteral">&quot;new_id must be the same on all processes&quot;</span>);</div>
<div class="line"><span class="lineno">  766</span>      Node * <span class="keyword">const</span> new_interior_node_right = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;add_point(</div>
<div class="line"><span class="lineno">  767</span>          right_interior_point, new_interior_id_right, new_elem_right-&gt;processor_id());</div>
<div class="line"><span class="lineno">  768</span>      new_elem_right-&gt;set_node(2) = new_interior_node_right;</div>
<div class="line"><span class="lineno">  769</span>      new_interior_node_right-&gt;set_unique_id(new_interior_id_right + node_unique_id_offset);</div>
<div class="line"><span class="lineno">  770</span>    }</div>
<div class="line"><span class="lineno">  771</span> </div>
<div class="line"><span class="lineno">  772</span>    <span class="comment">// If orientation 2 was valid, swap the left and right primaries.</span></div>
<div class="line"><span class="lineno">  773</span>    <span class="keywordflow">if</span> (orientation2_valid)</div>
<div class="line"><span class="lineno">  774</span>      std::swap(left_primary_elem, right_primary_elem);</div>
<div class="line"><span class="lineno">  775</span> </div>
<div class="line"><span class="lineno">  776</span>    <span class="comment">// Now that we know left_primary_elem and right_primary_elem, we can determine left_xi2 and</span></div>
<div class="line"><span class="lineno">  777</span>    <span class="comment">// right_xi2.</span></div>
<div class="line"><span class="lineno">  778</span>    <span class="keywordflow">if</span> (left_primary_elem)</div>
<div class="line"><span class="lineno">  779</span>      left_xi2 = (primary_node == left_primary_elem-&gt;node_ptr(0)) ? -1 : +1;</div>
<div class="line"><span class="lineno">  780</span>    <span class="keywordflow">if</span> (right_primary_elem)</div>
<div class="line"><span class="lineno">  781</span>      right_xi2 = (primary_node == right_primary_elem-&gt;node_ptr(0)) ? -1 : +1;</div>
<div class="line"><span class="lineno">  782</span> </div>
<div class="line"><span class="lineno">  783</span>    <span class="comment">// Grab the MortarSegmentInfo object associated with this</span></div>
<div class="line"><span class="lineno">  784</span>    <span class="comment">// segment. We can use &quot;at()&quot; here since we want this to fail if</span></div>
<div class="line"><span class="lineno">  785</span>    <span class="comment">// current_mortar_segment is not found... Since we&#39;re going to</span></div>
<div class="line"><span class="lineno">  786</span>    <span class="comment">// erase this entry from the map momentarily, we make an actual</span></div>
<div class="line"><span class="lineno">  787</span>    <span class="comment">// copy rather than grabbing a reference.</span></div>
<div class="line"><span class="lineno">  788</span>    <span class="keyword">auto</span> msm_it = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#abbd91d3cf8bef528976fe6f932622d2d">_msm_elem_to_info</a>.find(current_mortar_segment);</div>
<div class="line"><span class="lineno">  789</span>    <span class="keywordflow">if</span> (msm_it == <a class="code hl_variable" href="classAutomaticMortarGeneration.html#abbd91d3cf8bef528976fe6f932622d2d">_msm_elem_to_info</a>.end())</div>
<div class="line"><span class="lineno">  790</span>      <a class="code hl_function" href="MooseError_8h.html#aa959168eed29caa7aaa85ffc1319a9ad">mooseError</a>(<span class="stringliteral">&quot;MortarSegmentInfo not found for current_mortar_segment.&quot;</span>);</div>
<div class="line"><span class="lineno">  791</span>    <a class="code hl_struct" href="structMortarSegmentInfo.html">MortarSegmentInfo</a> current_msinfo = msm_it-&gt;second;</div>
<div class="line"><span class="lineno">  792</span> </div>
<div class="line"><span class="lineno">  793</span>    <span class="comment">// add_left</span></div>
<div class="line"><span class="lineno">  794</span>    {</div>
<div class="line"><span class="lineno">  795</span>      Elem * msm_new_elem = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;add_elem(new_elem_left.release());</div>
<div class="line"><span class="lineno">  796</span> </div>
<div class="line"><span class="lineno">  797</span>      <span class="comment">// Create new MortarSegmentInfo objects for new_elem_left</span></div>
<div class="line"><span class="lineno">  798</span>      <a class="code hl_struct" href="structMortarSegmentInfo.html">MortarSegmentInfo</a> new_msinfo_left;</div>
<div class="line"><span class="lineno">  799</span> </div>
<div class="line"><span class="lineno">  800</span>      <span class="comment">// The new MortarSegmentInfo info objects inherit their &quot;outer&quot;</span></div>
<div class="line"><span class="lineno">  801</span>      <span class="comment">// information from current_msinfo and the rest is determined by</span></div>
<div class="line"><span class="lineno">  802</span>      <span class="comment">// the Node being inserted.</span></div>
<div class="line"><span class="lineno">  803</span>      new_msinfo_left.<a class="code hl_variable" href="structMortarSegmentInfo.html#ad4205fbab31bbda066622c55c8e93b87">xi1_a</a> = current_msinfo.<a class="code hl_variable" href="structMortarSegmentInfo.html#ad4205fbab31bbda066622c55c8e93b87">xi1_a</a>;</div>
<div class="line"><span class="lineno">  804</span>      new_msinfo_left.<a class="code hl_variable" href="structMortarSegmentInfo.html#abcfb0183363f3e21b43f9ffd3dc477b4">xi2_a</a> = current_msinfo.<a class="code hl_variable" href="structMortarSegmentInfo.html#abcfb0183363f3e21b43f9ffd3dc477b4">xi2_a</a>;</div>
<div class="line"><span class="lineno">  805</span>      new_msinfo_left.<a class="code hl_variable" href="structMortarSegmentInfo.html#afa8c2918a473f0dad90d5c68dad00eb4">secondary_elem</a> = secondary_elem;</div>
<div class="line"><span class="lineno">  806</span>      new_msinfo_left.<a class="code hl_variable" href="structMortarSegmentInfo.html#a648c7f480b2ce6404b1db1d21642b919">xi1_b</a> = xi1;</div>
<div class="line"><span class="lineno">  807</span>      new_msinfo_left.<a class="code hl_variable" href="structMortarSegmentInfo.html#a4fe559d3196b77718c1052ab7c1aa4d3">xi2_b</a> = left_xi2;</div>
<div class="line"><span class="lineno">  808</span>      new_msinfo_left.<a class="code hl_variable" href="structMortarSegmentInfo.html#a3316fbff8584e06e3c973d3f3e6ff05f">primary_elem</a> = left_primary_elem;</div>
<div class="line"><span class="lineno">  809</span> </div>
<div class="line"><span class="lineno">  810</span>      <span class="comment">// Add new msinfo objects to the map.</span></div>
<div class="line"><span class="lineno">  811</span>      <a class="code hl_variable" href="classAutomaticMortarGeneration.html#abbd91d3cf8bef528976fe6f932622d2d">_msm_elem_to_info</a>.emplace(msm_new_elem, new_msinfo_left);</div>
<div class="line"><span class="lineno">  812</span> </div>
<div class="line"><span class="lineno">  813</span>      <span class="comment">// We need to insert new_elem_left in</span></div>
<div class="line"><span class="lineno">  814</span>      <span class="comment">// the mortar_segment_set for this secondary_elem.</span></div>
<div class="line"><span class="lineno">  815</span>      mortar_segment_set.insert(msm_new_elem);</div>
<div class="line"><span class="lineno">  816</span>    }</div>
<div class="line"><span class="lineno">  817</span> </div>
<div class="line"><span class="lineno">  818</span>    <span class="comment">// add_right</span></div>
<div class="line"><span class="lineno">  819</span>    {</div>
<div class="line"><span class="lineno">  820</span>      Elem * msm_new_elem = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;add_elem(new_elem_right.release());</div>
<div class="line"><span class="lineno">  821</span> </div>
<div class="line"><span class="lineno">  822</span>      <span class="comment">// Create new MortarSegmentInfo objects for new_elem_right</span></div>
<div class="line"><span class="lineno">  823</span>      <a class="code hl_struct" href="structMortarSegmentInfo.html">MortarSegmentInfo</a> new_msinfo_right;</div>
<div class="line"><span class="lineno">  824</span> </div>
<div class="line"><span class="lineno">  825</span>      new_msinfo_right.<a class="code hl_variable" href="structMortarSegmentInfo.html#a648c7f480b2ce6404b1db1d21642b919">xi1_b</a> = current_msinfo.<a class="code hl_variable" href="structMortarSegmentInfo.html#a648c7f480b2ce6404b1db1d21642b919">xi1_b</a>;</div>
<div class="line"><span class="lineno">  826</span>      new_msinfo_right.<a class="code hl_variable" href="structMortarSegmentInfo.html#a4fe559d3196b77718c1052ab7c1aa4d3">xi2_b</a> = current_msinfo.<a class="code hl_variable" href="structMortarSegmentInfo.html#a4fe559d3196b77718c1052ab7c1aa4d3">xi2_b</a>;</div>
<div class="line"><span class="lineno">  827</span>      new_msinfo_right.<a class="code hl_variable" href="structMortarSegmentInfo.html#afa8c2918a473f0dad90d5c68dad00eb4">secondary_elem</a> = secondary_elem;</div>
<div class="line"><span class="lineno">  828</span>      new_msinfo_right.<a class="code hl_variable" href="structMortarSegmentInfo.html#ad4205fbab31bbda066622c55c8e93b87">xi1_a</a> = xi1;</div>
<div class="line"><span class="lineno">  829</span>      new_msinfo_right.<a class="code hl_variable" href="structMortarSegmentInfo.html#abcfb0183363f3e21b43f9ffd3dc477b4">xi2_a</a> = right_xi2;</div>
<div class="line"><span class="lineno">  830</span>      new_msinfo_right.<a class="code hl_variable" href="structMortarSegmentInfo.html#a3316fbff8584e06e3c973d3f3e6ff05f">primary_elem</a> = right_primary_elem;</div>
<div class="line"><span class="lineno">  831</span> </div>
<div class="line"><span class="lineno">  832</span>      <a class="code hl_variable" href="classAutomaticMortarGeneration.html#abbd91d3cf8bef528976fe6f932622d2d">_msm_elem_to_info</a>.emplace(msm_new_elem, new_msinfo_right);</div>
<div class="line"><span class="lineno">  833</span> </div>
<div class="line"><span class="lineno">  834</span>      mortar_segment_set.insert(msm_new_elem);</div>
<div class="line"><span class="lineno">  835</span>    }</div>
<div class="line"><span class="lineno">  836</span> </div>
<div class="line"><span class="lineno">  837</span>    <span class="comment">// Erase the MortarSegmentInfo object for current_mortar_segment from the map.</span></div>
<div class="line"><span class="lineno">  838</span>    <a class="code hl_variable" href="classAutomaticMortarGeneration.html#abbd91d3cf8bef528976fe6f932622d2d">_msm_elem_to_info</a>.erase(msm_it);</div>
<div class="line"><span class="lineno">  839</span> </div>
<div class="line"><span class="lineno">  840</span>    <span class="comment">// current_mortar_segment must be erased from the</span></div>
<div class="line"><span class="lineno">  841</span>    <span class="comment">// mortar_segment_set since it has now been split.</span></div>
<div class="line"><span class="lineno">  842</span>    mortar_segment_set.erase(current_mortar_segment);</div>
<div class="line"><span class="lineno">  843</span> </div>
<div class="line"><span class="lineno">  844</span>    <span class="comment">// The original mortar segment has been split, so erase it from</span></div>
<div class="line"><span class="lineno">  845</span>    <span class="comment">// the mortar segment mesh.</span></div>
<div class="line"><span class="lineno">  846</span>    <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;delete_elem(current_mortar_segment);</div>
<div class="line"><span class="lineno">  847</span>  }</div>
<div class="line"><span class="lineno">  848</span> </div>
<div class="line"><span class="lineno">  849</span>  <span class="comment">// Remove all MSM elements without a primary contribution</span></div>
<div class="line"><span class="lineno">  855</span><span class="comment"></span>  <span class="keywordflow">for</span> (<span class="keyword">auto</span> msm_elem : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;active_element_ptr_range())</div>
<div class="line"><span class="lineno">  856</span>  {</div>
<div class="line"><span class="lineno">  857</span>    <a class="code hl_struct" href="structMortarSegmentInfo.html">MortarSegmentInfo</a> &amp; msinfo = libmesh_map_find(<a class="code hl_variable" href="classAutomaticMortarGeneration.html#abbd91d3cf8bef528976fe6f932622d2d">_msm_elem_to_info</a>, msm_elem);</div>
<div class="line"><span class="lineno">  858</span>    Elem * primary_elem = <span class="keyword">const_cast&lt;</span>Elem *<span class="keyword">&gt;</span>(msinfo.<a class="code hl_variable" href="structMortarSegmentInfo.html#a3316fbff8584e06e3c973d3f3e6ff05f">primary_elem</a>);</div>
<div class="line"><span class="lineno">  859</span>    <span class="keywordflow">if</span> (primary_elem == <span class="keyword">nullptr</span> || std::abs(msinfo.<a class="code hl_variable" href="structMortarSegmentInfo.html#abcfb0183363f3e21b43f9ffd3dc477b4">xi2_a</a>) &gt; 1.0 + TOLERANCE ||</div>
<div class="line"><span class="lineno">  860</span>        std::abs(msinfo.<a class="code hl_variable" href="structMortarSegmentInfo.html#a4fe559d3196b77718c1052ab7c1aa4d3">xi2_b</a>) &gt; 1.0 + TOLERANCE)</div>
<div class="line"><span class="lineno">  861</span>    {</div>
<div class="line"><span class="lineno">  862</span>      <span class="comment">// Erase from secondary to msms map</span></div>
<div class="line"><span class="lineno">  863</span>      <span class="keyword">auto</span> it = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#af0da3b7d9e404238718805e12452d74d">_secondary_elems_to_mortar_segments</a>.find(msinfo.<a class="code hl_variable" href="structMortarSegmentInfo.html#afa8c2918a473f0dad90d5c68dad00eb4">secondary_elem</a>-&gt;id());</div>
<div class="line"><span class="lineno">  864</span>      mooseAssert(it != <a class="code hl_variable" href="classAutomaticMortarGeneration.html#af0da3b7d9e404238718805e12452d74d">_secondary_elems_to_mortar_segments</a>.end(),</div>
<div class="line"><span class="lineno">  865</span>                  <span class="stringliteral">&quot;We should have found the element&quot;</span>);</div>
<div class="line"><span class="lineno">  866</span>      <span class="keyword">auto</span> &amp; msm_set = it-&gt;second;</div>
<div class="line"><span class="lineno">  867</span>      msm_set.erase(msm_elem);</div>
<div class="line"><span class="lineno">  868</span>      <span class="comment">// We may be creating nodes with only one element neighbor where before this removal there</span></div>
<div class="line"><span class="lineno">  869</span>      <span class="comment">// were two. But the nodal normal used in computations will reflect the two-neighbor geometry.</span></div>
<div class="line"><span class="lineno">  870</span>      <span class="comment">// For a lower-d secondary mesh corner, that will imply the corner node will have a tilted</span></div>
<div class="line"><span class="lineno">  871</span>      <span class="comment">// normal vector (same for tangents) despite the mortar segment mesh not including its</span></div>
<div class="line"><span class="lineno">  872</span>      <span class="comment">// vertical neighboring element. It is the secondary element neighbors (not mortar segment</span></div>
<div class="line"><span class="lineno">  873</span>      <span class="comment">// mesh neighbors) that determine the nodal normal field.</span></div>
<div class="line"><span class="lineno">  874</span>      <span class="keywordflow">if</span> (msm_set.empty())</div>
<div class="line"><span class="lineno">  875</span>        <a class="code hl_variable" href="classAutomaticMortarGeneration.html#af0da3b7d9e404238718805e12452d74d">_secondary_elems_to_mortar_segments</a>.erase(it);</div>
<div class="line"><span class="lineno">  876</span> </div>
<div class="line"><span class="lineno">  877</span>      <span class="comment">// Erase msinfo</span></div>
<div class="line"><span class="lineno">  878</span>      <a class="code hl_variable" href="classAutomaticMortarGeneration.html#abbd91d3cf8bef528976fe6f932622d2d">_msm_elem_to_info</a>.erase(msm_elem);</div>
<div class="line"><span class="lineno">  879</span> </div>
<div class="line"><span class="lineno">  880</span>      <span class="comment">// Remove element from mortar segment mesh</span></div>
<div class="line"><span class="lineno">  881</span>      <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;delete_elem(msm_elem);</div>
<div class="line"><span class="lineno">  882</span>    }</div>
<div class="line"><span class="lineno">  883</span>    <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  884</span>    {</div>
<div class="line"><span class="lineno">  885</span>      <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a7254faea651acd63b60b408ab560a0e5">_secondary_ip_sub_ids</a>.insert(msinfo.<a class="code hl_variable" href="structMortarSegmentInfo.html#afa8c2918a473f0dad90d5c68dad00eb4">secondary_elem</a>-&gt;interior_parent()-&gt;subdomain_id());</div>
<div class="line"><span class="lineno">  886</span>      <a class="code hl_variable" href="classAutomaticMortarGeneration.html#ac99e408cefd4da80efa2649ef1d32e93">_primary_ip_sub_ids</a>.insert(msinfo.<a class="code hl_variable" href="structMortarSegmentInfo.html#a3316fbff8584e06e3c973d3f3e6ff05f">primary_elem</a>-&gt;interior_parent()-&gt;subdomain_id());</div>
<div class="line"><span class="lineno">  887</span>    }</div>
<div class="line"><span class="lineno">  888</span>  }</div>
<div class="line"><span class="lineno">  889</span> </div>
<div class="line"><span class="lineno">  890</span>  std::unordered_set&lt;Node *&gt; msm_connected_nodes;</div>
<div class="line"><span class="lineno">  891</span> </div>
<div class="line"><span class="lineno">  892</span>  <span class="comment">// Deleting elements may produce isolated nodes.</span></div>
<div class="line"><span class="lineno">  893</span>  <span class="comment">// Loops for identifying and removing such nodes from mortar segment mesh.</span></div>
<div class="line"><span class="lineno">  894</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; element : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;element_ptr_range())</div>
<div class="line"><span class="lineno">  895</span>    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; n : element-&gt;node_ref_range())</div>
<div class="line"><span class="lineno">  896</span>      msm_connected_nodes.insert(&amp;n);</div>
<div class="line"><span class="lineno">  897</span> </div>
<div class="line"><span class="lineno">  898</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; node : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;node_ptr_range())</div>
<div class="line"><span class="lineno">  899</span>    <span class="keywordflow">if</span> (!msm_connected_nodes.count(node))</div>
<div class="line"><span class="lineno">  900</span>      <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;delete_node(node);</div>
<div class="line"><span class="lineno">  901</span> </div>
<div class="line"><span class="lineno">  902</span><span class="preprocessor">#ifdef DEBUG</span></div>
<div class="line"><span class="lineno">  903</span>  <span class="comment">// Verify that all segments without primary contribution have been deleted</span></div>
<div class="line"><span class="lineno">  904</span>  <span class="keywordflow">for</span> (<span class="keyword">auto</span> msm_elem : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;active_element_ptr_range())</div>
<div class="line"><span class="lineno">  905</span>  {</div>
<div class="line"><span class="lineno">  906</span>    <span class="keyword">const</span> <a class="code hl_struct" href="structMortarSegmentInfo.html">MortarSegmentInfo</a> &amp; msinfo = libmesh_map_find(<a class="code hl_variable" href="classAutomaticMortarGeneration.html#abbd91d3cf8bef528976fe6f932622d2d">_msm_elem_to_info</a>, msm_elem);</div>
<div class="line"><span class="lineno">  907</span>    mooseAssert(msinfo.<a class="code hl_variable" href="structMortarSegmentInfo.html#a3316fbff8584e06e3c973d3f3e6ff05f">primary_elem</a> != <span class="keyword">nullptr</span>,</div>
<div class="line"><span class="lineno">  908</span>                <span class="stringliteral">&quot;All mortar segment elements should have valid &quot;</span></div>
<div class="line"><span class="lineno">  909</span>                <span class="stringliteral">&quot;primary element.&quot;</span>);</div>
<div class="line"><span class="lineno">  910</span>  }</div>
<div class="line"><span class="lineno">  911</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno">  912</span> </div>
<div class="line"><span class="lineno">  913</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;cache_elem_data();</div>
<div class="line"><span class="lineno">  914</span> </div>
<div class="line"><span class="lineno">  915</span>  <span class="comment">// (Optionally) Write the mortar segment mesh to file for inspection</span></div>
<div class="line"><span class="lineno">  916</span>  <span class="keywordflow">if</span> (<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a958de5b754ec676f463c50d2f16b5d0c">_debug</a>)</div>
<div class="line"><span class="lineno">  917</span>  {</div>
<div class="line"><span class="lineno">  918</span>    ExodusII_IO mortar_segment_mesh_writer(*<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>);</div>
<div class="line"><span class="lineno">  919</span> </div>
<div class="line"><span class="lineno">  920</span>    <span class="comment">// Default to non-HDF5 output for wider compatibility</span></div>
<div class="line"><span class="lineno">  921</span>    mortar_segment_mesh_writer.set_hdf5_writing(<span class="keyword">false</span>);</div>
<div class="line"><span class="lineno">  922</span> </div>
<div class="line"><span class="lineno">  923</span>    mortar_segment_mesh_writer.write(<span class="stringliteral">&quot;mortar_segment_mesh.e&quot;</span>);</div>
<div class="line"><span class="lineno">  924</span>  }</div>
<div class="line"><span class="lineno">  925</span> </div>
<div class="line"><span class="lineno">  926</span>  <a class="code hl_function" href="classAutomaticMortarGeneration.html#a6dfaa66a5dc83c679a3c4dd7aa0bf1ab">buildCouplingInformation</a>();</div>
<div class="line"><span class="lineno">  927</span>}</div>
<div class="ttc" id="aMooseError_8h_html_a3d351254665674621ecbd38f57bb28ae"><div class="ttname"><a href="MooseError_8h.html#a3d351254665674621ecbd38f57bb28ae">mooseWarning</a></div><div class="ttdeci">void mooseWarning(Args &amp;&amp;... args)</div><div class="ttdoc">Emit a warning message with the given stringified, concatenated args.</div><div class="ttdef"><b>Definition:</b> <a href="MooseError_8h_source.html#l00296">MooseError.h:296</a></div></div>
<div class="ttc" id="aMooseError_8h_html_aa959168eed29caa7aaa85ffc1319a9ad"><div class="ttname"><a href="MooseError_8h.html#aa959168eed29caa7aaa85ffc1319a9ad">mooseError</a></div><div class="ttdeci">void mooseError(Args &amp;&amp;... args)</div><div class="ttdoc">Emit an error message with the given stringified, concatenated args and terminate the application.</div><div class="ttdef"><b>Definition:</b> <a href="MooseError_8h_source.html#l00284">MooseError.h:284</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a1ee9b6e4f8bd88603e22117085758f70"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a1ee9b6e4f8bd88603e22117085758f70">AutomaticMortarGeneration::_nodes_to_primary_elem_map</a></div><div class="ttdeci">std::unordered_map&lt; dof_id_type, std::vector&lt; const Elem * &gt; &gt; _nodes_to_primary_elem_map</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00367">AutomaticMortarGeneration.h:367</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a25f6f147b1b0a4b00e7c6739dd17b98c"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a25f6f147b1b0a4b00e7c6739dd17b98c">AutomaticMortarGeneration::_xi_tolerance</a></div><div class="ttdeci">Real _xi_tolerance</div><div class="ttdoc">Tolerance for checking projection xi values.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00495">AutomaticMortarGeneration.h:495</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a6dfaa66a5dc83c679a3c4dd7aa0bf1ab"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a6dfaa66a5dc83c679a3c4dd7aa0bf1ab">AutomaticMortarGeneration::buildCouplingInformation</a></div><div class="ttdeci">void buildCouplingInformation()</div><div class="ttdoc">build the _mortar_interface_coupling data</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8C_source.html#l01350">AutomaticMortarGeneration.C:1350</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a71eb5cecb4437a9a0edfe8d5ce38007e"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a71eb5cecb4437a9a0edfe8d5ce38007e">AutomaticMortarGeneration::getNormals</a></div><div class="ttdeci">std::vector&lt; Point &gt; getNormals(const Elem &amp;secondary_elem, const std::vector&lt; Point &gt; &amp;xi1_pts) const</div><div class="ttdoc">Compute the normals at given reference points on a secondary element.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8C_source.html#l00404">AutomaticMortarGeneration.C:404</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a7254faea651acd63b60b408ab560a0e5"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a7254faea651acd63b60b408ab560a0e5">AutomaticMortarGeneration::_secondary_ip_sub_ids</a></div><div class="ttdeci">std::set&lt; SubdomainID &gt; _secondary_ip_sub_ids</div><div class="ttdoc">All the secondary interior parent subdomain IDs associated with the mortar mesh.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00452">AutomaticMortarGeneration.h:452</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_abb4cc3e3102675e52675a95347ad8e95"><div class="ttname"><a href="classAutomaticMortarGeneration.html#abb4cc3e3102675e52675a95347ad8e95">AutomaticMortarGeneration::_secondary_node_and_elem_to_xi2_primary_elem</a></div><div class="ttdeci">std::unordered_map&lt; std::pair&lt; const Node *, const Elem * &gt;, std::pair&lt; Real, const Elem * &gt; &gt; _secondary_node_and_elem_to_xi2_primary_elem</div><div class="ttdoc">Similar to the map above, but associates a (Secondary Node, Secondary Elem) pair to a (xi^(2),...</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00387">AutomaticMortarGeneration.h:387</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_ac174eedb02e9681baf439360903700d4"><div class="ttname"><a href="classAutomaticMortarGeneration.html#ac174eedb02e9681baf439360903700d4">AutomaticMortarGeneration::_primary_node_and_elem_to_xi1_secondary_elem</a></div><div class="ttdeci">std::map&lt; std::tuple&lt; dof_id_type, const Node *, const Elem * &gt;, std::pair&lt; Real, const Elem * &gt; &gt; _primary_node_and_elem_to_xi1_secondary_elem</div><div class="ttdoc">Same type of container, but for mapping (Primary Node ID, Primary Node, Primary Elem) -&gt; (xi^(1),...</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00395">AutomaticMortarGeneration.h:395</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_ac99e408cefd4da80efa2649ef1d32e93"><div class="ttname"><a href="classAutomaticMortarGeneration.html#ac99e408cefd4da80efa2649ef1d32e93">AutomaticMortarGeneration::_primary_ip_sub_ids</a></div><div class="ttdeci">std::set&lt; SubdomainID &gt; _primary_ip_sub_ids</div><div class="ttdoc">All the primary interior parent subdomain IDs associated with the mortar mesh.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00455">AutomaticMortarGeneration.h:455</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_af0da3b7d9e404238718805e12452d74d"><div class="ttname"><a href="classAutomaticMortarGeneration.html#af0da3b7d9e404238718805e12452d74d">AutomaticMortarGeneration::_secondary_elems_to_mortar_segments</a></div><div class="ttdeci">std::unordered_map&lt; dof_id_type, std::set&lt; Elem *, CompareDofObjectsByID &gt; &gt; _secondary_elems_to_mortar_segments</div><div class="ttdoc">We maintain a mapping from lower-dimensional secondary elements in the original mesh to (sets of) ele...</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00449">AutomaticMortarGeneration.h:449</a></div></div>
<div class="ttc" id="aclassMooseException_html"><div class="ttname"><a href="classMooseException.html">MooseException</a></div><div class="ttdoc">Provides a way for users to bail out of the current solve.</div><div class="ttdef"><b>Definition:</b> <a href="MooseException_8h_source.html#l00020">MooseException.h:21</a></div></div>
<div class="ttc" id="anamespaceMoose_html_a9ed3373b5072c07f1f010afb75ac20c9"><div class="ttname"><a href="namespaceMoose.html#a9ed3373b5072c07f1f010afb75ac20c9">Moose::fe_lagrange_1D_shape</a></div><div class="ttdeci">T fe_lagrange_1D_shape(const Order order, const unsigned int i, const T &amp;xi)</div><div class="ttdef"><b>Definition:</b> <a href="MooseLagrangeHelpers_8h_source.html#l00022">MooseLagrangeHelpers.h:22</a></div></div>
<div class="ttc" id="astructMortarSegmentInfo_html"><div class="ttname"><a href="structMortarSegmentInfo.html">MortarSegmentInfo</a></div><div class="ttdoc">Holds xi^(1), xi^(2), and other data for a given mortar segment.</div><div class="ttdef"><b>Definition:</b> <a href="MortarSegmentInfo_8h_source.html#l00031">MortarSegmentInfo.h:32</a></div></div>
<div class="ttc" id="astructMortarSegmentInfo_html_a3316fbff8584e06e3c973d3f3e6ff05f"><div class="ttname"><a href="structMortarSegmentInfo.html#a3316fbff8584e06e3c973d3f3e6ff05f">MortarSegmentInfo::primary_elem</a></div><div class="ttdeci">const Elem * primary_elem</div><div class="ttdef"><b>Definition:</b> <a href="MortarSegmentInfo_8h_source.html#l00068">MortarSegmentInfo.h:68</a></div></div>
<div class="ttc" id="astructMortarSegmentInfo_html_a4fe559d3196b77718c1052ab7c1aa4d3"><div class="ttname"><a href="structMortarSegmentInfo.html#a4fe559d3196b77718c1052ab7c1aa4d3">MortarSegmentInfo::xi2_b</a></div><div class="ttdeci">Real xi2_b</div><div class="ttdef"><b>Definition:</b> <a href="MortarSegmentInfo_8h_source.html#l00066">MortarSegmentInfo.h:66</a></div></div>
<div class="ttc" id="astructMortarSegmentInfo_html_a648c7f480b2ce6404b1db1d21642b919"><div class="ttname"><a href="structMortarSegmentInfo.html#a648c7f480b2ce6404b1db1d21642b919">MortarSegmentInfo::xi1_b</a></div><div class="ttdeci">Real xi1_b</div><div class="ttdef"><b>Definition:</b> <a href="MortarSegmentInfo_8h_source.html#l00065">MortarSegmentInfo.h:65</a></div></div>
<div class="ttc" id="astructMortarSegmentInfo_html_abcfb0183363f3e21b43f9ffd3dc477b4"><div class="ttname"><a href="structMortarSegmentInfo.html#abcfb0183363f3e21b43f9ffd3dc477b4">MortarSegmentInfo::xi2_a</a></div><div class="ttdeci">Real xi2_a</div><div class="ttdef"><b>Definition:</b> <a href="MortarSegmentInfo_8h_source.html#l00066">MortarSegmentInfo.h:66</a></div></div>
<div class="ttc" id="astructMortarSegmentInfo_html_ad4205fbab31bbda066622c55c8e93b87"><div class="ttname"><a href="structMortarSegmentInfo.html#ad4205fbab31bbda066622c55c8e93b87">MortarSegmentInfo::xi1_a</a></div><div class="ttdeci">Real xi1_a</div><div class="ttdef"><b>Definition:</b> <a href="MortarSegmentInfo_8h_source.html#l00065">MortarSegmentInfo.h:65</a></div></div>
<div class="ttc" id="astructMortarSegmentInfo_html_ae240d424b2112e4d23e66597318160ca"><div class="ttname"><a href="structMortarSegmentInfo.html#ae240d424b2112e4d23e66597318160ca">MortarSegmentInfo::invalid_xi</a></div><div class="ttdeci">static const Real invalid_xi</div><div class="ttdef"><b>Definition:</b> <a href="MortarSegmentInfo_8h_source.html#l00072">MortarSegmentInfo.h:72</a></div></div>
<div class="ttc" id="astructMortarSegmentInfo_html_afa8c2918a473f0dad90d5c68dad00eb4"><div class="ttname"><a href="structMortarSegmentInfo.html#afa8c2918a473f0dad90d5c68dad00eb4">MortarSegmentInfo::secondary_elem</a></div><div class="ttdeci">const Elem * secondary_elem</div><div class="ttdef"><b>Definition:</b> <a href="MortarSegmentInfo_8h_source.html#l00067">MortarSegmentInfo.h:67</a></div></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="MortarData_8C_source.html#l00160">MortarData::update()</a>.</p>

</div>
</div>
<a id="a533e6ee50c2892de7d5e436f524bcb83" name="a533e6ee50c2892de7d5e436f524bcb83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a533e6ee50c2892de7d5e436f524bcb83">&#9670;&#160;</a></span>buildMortarSegmentMesh3d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AutomaticMortarGeneration::buildMortarSegmentMesh3d </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds the mortar segment mesh once the secondary and primary node projections have been completed. </p>
<p >Inputs:</p><ul>
<li>mesh</li>
</ul>
<p >Outputs:</p><ul>
<li>mortar_segment_mesh</li>
<li>msm_elem_to_info </li>
</ul>
<p >Step 1: Build mortar segments for all secondary elements</p>
<p >Step 1.1: Linearize secondary face elements</p>
<p >For first order face elements (Tri3 and Quad4) elements are simply linearized around center For second order (Tri6 and Quad9) and third order (Tri7) face elements, elements are sub-divided into four first order elements then each of the sub-elements is linearized around their respective centers For Quad8 elements, they are sub-divided into one quad and four triangle elements and each sub-element is linearized around their respective centers</p>
<p >Step 1.2: Coarse screening using a k-d tree to find nodes on the primary interface that are 'close to' a center point of the secondary element.</p>
<p >Step 1.3: Loop through primary candidate nodes, create mortar segments</p>
<p >Once an element with non-trivial projection onto secondary element identified, switch to breadth-first search (drop all current candidates and add only neighbors of elements with non-trivial overlap)</p>
<p >Step 1.3.2: Sub-divide primary element candidate, then project onto secondary sub-elements, perform polygon clipping, and triangulate to form mortar segments</p>
<p >Step 1.3.3: Create mortar segments and add to mortar segment mesh</p>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00930">930</a> of file <a class="el" href="AutomaticMortarGeneration_8C_source.html">AutomaticMortarGeneration.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  931</span>{</div>
<div class="line"><span class="lineno">  932</span>  <span class="comment">// Add an integer flag to mortar segment mesh to keep track of which subelem</span></div>
<div class="line"><span class="lineno">  933</span>  <span class="comment">// of second order primal elements mortar segments correspond to</span></div>
<div class="line"><span class="lineno">  934</span>  <span class="keyword">auto</span> secondary_sub_elem = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;add_elem_integer(<span class="stringliteral">&quot;secondary_sub_elem&quot;</span>);</div>
<div class="line"><span class="lineno">  935</span>  <span class="keyword">auto</span> primary_sub_elem = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;add_elem_integer(<span class="stringliteral">&quot;primary_sub_elem&quot;</span>);</div>
<div class="line"><span class="lineno">  936</span> </div>
<div class="line"><span class="lineno">  937</span>  dof_id_type local_id_index = 0;</div>
<div class="line"><span class="lineno">  938</span> </div>
<div class="line"><span class="lineno">  939</span>  <span class="comment">// Loop through mortar secondary and primary pairs to create mortar segment mesh between each</span></div>
<div class="line"><span class="lineno">  940</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; pr : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a969d4ab038fc8d447e966cd1e1600091">_primary_secondary_subdomain_id_pairs</a>)</div>
<div class="line"><span class="lineno">  941</span>  {</div>
<div class="line"><span class="lineno">  942</span>    <span class="keyword">const</span> <span class="keyword">auto</span> primary_subd_id = pr.first;</div>
<div class="line"><span class="lineno">  943</span>    <span class="keyword">const</span> <span class="keyword">auto</span> secondary_subd_id = pr.second;</div>
<div class="line"><span class="lineno">  944</span> </div>
<div class="line"><span class="lineno">  945</span>    <span class="comment">// Build k-d tree for use in Step 1.2 for primary interface coarse screening</span></div>
<div class="line"><span class="lineno">  946</span>    <a class="code hl_class" href="classNanoflannMeshSubdomainAdaptor.html">NanoflannMeshSubdomainAdaptor&lt;3&gt;</a> mesh_adaptor(<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>, primary_subd_id);</div>
<div class="line"><span class="lineno">  947</span>    <a class="code hl_typedef" href="NanoflannMeshAdaptor_8h.html#a3a70df33047194961ce21a0133717038">subdomain_kd_tree_t</a> kd_tree(</div>
<div class="line"><span class="lineno">  948</span>        3, mesh_adaptor, nanoflann::KDTreeSingleIndexAdaptorParams(<span class="comment">/*max leaf=*/</span>10));</div>
<div class="line"><span class="lineno">  949</span> </div>
<div class="line"><span class="lineno">  950</span>    <span class="comment">// Construct the KD tree.</span></div>
<div class="line"><span class="lineno">  951</span>    kd_tree.buildIndex();</div>
<div class="line"><span class="lineno">  952</span> </div>
<div class="line"><span class="lineno">  953</span>    <span class="comment">// Define expression for getting sub-elements nodes (for sub-dividing secondary elements)</span></div>
<div class="line"><span class="lineno">  954</span>    <span class="keyword">auto</span> get_sub_elem_nodes = [](<span class="keyword">const</span> ElemType type,</div>
<div class="line"><span class="lineno">  955</span>                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sub_elem) -&gt; std::vector&lt;unsigned int&gt;</div>
<div class="line"><span class="lineno">  956</span>    {</div>
<div class="line"><span class="lineno">  957</span>      <span class="keywordflow">switch</span> (type)</div>
<div class="line"><span class="lineno">  958</span>      {</div>
<div class="line"><span class="lineno">  959</span>        <span class="keywordflow">case</span> TRI3:</div>
<div class="line"><span class="lineno">  960</span>          <span class="keywordflow">return</span> {{0, 1, 2}};</div>
<div class="line"><span class="lineno">  961</span>        <span class="keywordflow">case</span> QUAD4:</div>
<div class="line"><span class="lineno">  962</span>          <span class="keywordflow">return</span> {{0, 1, 2, 3}};</div>
<div class="line"><span class="lineno">  963</span>        <span class="keywordflow">case</span> TRI6:</div>
<div class="line"><span class="lineno">  964</span>        <span class="keywordflow">case</span> TRI7:</div>
<div class="line"><span class="lineno">  965</span>          <span class="keywordflow">switch</span> (sub_elem)</div>
<div class="line"><span class="lineno">  966</span>          {</div>
<div class="line"><span class="lineno">  967</span>            <span class="keywordflow">case</span> 0:</div>
<div class="line"><span class="lineno">  968</span>              <span class="keywordflow">return</span> {{0, 3, 5}};</div>
<div class="line"><span class="lineno">  969</span>            <span class="keywordflow">case</span> 1:</div>
<div class="line"><span class="lineno">  970</span>              <span class="keywordflow">return</span> {{3, 4, 5}};</div>
<div class="line"><span class="lineno">  971</span>            <span class="keywordflow">case</span> 2:</div>
<div class="line"><span class="lineno">  972</span>              <span class="keywordflow">return</span> {{3, 1, 4}};</div>
<div class="line"><span class="lineno">  973</span>            <span class="keywordflow">case</span> 3:</div>
<div class="line"><span class="lineno">  974</span>              <span class="keywordflow">return</span> {{5, 4, 2}};</div>
<div class="line"><span class="lineno">  975</span>            <span class="keywordflow">default</span>:</div>
<div class="line"><span class="lineno">  976</span>              <a class="code hl_function" href="MooseError_8h.html#aa959168eed29caa7aaa85ffc1319a9ad">mooseError</a>(<span class="stringliteral">&quot;get_sub_elem_nodes: Invalid sub_elem: &quot;</span>, sub_elem);</div>
<div class="line"><span class="lineno">  977</span>          }</div>
<div class="line"><span class="lineno">  978</span>        <span class="keywordflow">case</span> QUAD8:</div>
<div class="line"><span class="lineno">  979</span>          <span class="keywordflow">switch</span> (sub_elem)</div>
<div class="line"><span class="lineno">  980</span>          {</div>
<div class="line"><span class="lineno">  981</span>            <span class="keywordflow">case</span> 0:</div>
<div class="line"><span class="lineno">  982</span>              <span class="keywordflow">return</span> {{0, 4, 7}};</div>
<div class="line"><span class="lineno">  983</span>            <span class="keywordflow">case</span> 1:</div>
<div class="line"><span class="lineno">  984</span>              <span class="keywordflow">return</span> {{4, 1, 5}};</div>
<div class="line"><span class="lineno">  985</span>            <span class="keywordflow">case</span> 2:</div>
<div class="line"><span class="lineno">  986</span>              <span class="keywordflow">return</span> {{5, 2, 6}};</div>
<div class="line"><span class="lineno">  987</span>            <span class="keywordflow">case</span> 3:</div>
<div class="line"><span class="lineno">  988</span>              <span class="keywordflow">return</span> {{7, 6, 3}};</div>
<div class="line"><span class="lineno">  989</span>            <span class="keywordflow">case</span> 4:</div>
<div class="line"><span class="lineno">  990</span>              <span class="keywordflow">return</span> {{4, 5, 6, 7}};</div>
<div class="line"><span class="lineno">  991</span>            <span class="keywordflow">default</span>:</div>
<div class="line"><span class="lineno">  992</span>              <a class="code hl_function" href="MooseError_8h.html#aa959168eed29caa7aaa85ffc1319a9ad">mooseError</a>(<span class="stringliteral">&quot;get_sub_elem_nodes: Invalid sub_elem: &quot;</span>, sub_elem);</div>
<div class="line"><span class="lineno">  993</span>          }</div>
<div class="line"><span class="lineno">  994</span>        <span class="keywordflow">case</span> QUAD9:</div>
<div class="line"><span class="lineno">  995</span>          <span class="keywordflow">switch</span> (sub_elem)</div>
<div class="line"><span class="lineno">  996</span>          {</div>
<div class="line"><span class="lineno">  997</span>            <span class="keywordflow">case</span> 0:</div>
<div class="line"><span class="lineno">  998</span>              <span class="keywordflow">return</span> {{0, 4, 8, 7}};</div>
<div class="line"><span class="lineno">  999</span>            <span class="keywordflow">case</span> 1:</div>
<div class="line"><span class="lineno"> 1000</span>              <span class="keywordflow">return</span> {{4, 1, 5, 8}};</div>
<div class="line"><span class="lineno"> 1001</span>            <span class="keywordflow">case</span> 2:</div>
<div class="line"><span class="lineno"> 1002</span>              <span class="keywordflow">return</span> {{8, 5, 2, 6}};</div>
<div class="line"><span class="lineno"> 1003</span>            <span class="keywordflow">case</span> 3:</div>
<div class="line"><span class="lineno"> 1004</span>              <span class="keywordflow">return</span> {{7, 8, 6, 3}};</div>
<div class="line"><span class="lineno"> 1005</span>            <span class="keywordflow">default</span>:</div>
<div class="line"><span class="lineno"> 1006</span>              <a class="code hl_function" href="MooseError_8h.html#aa959168eed29caa7aaa85ffc1319a9ad">mooseError</a>(<span class="stringliteral">&quot;get_sub_elem_nodes: Invalid sub_elem: &quot;</span>, sub_elem);</div>
<div class="line"><span class="lineno"> 1007</span>          }</div>
<div class="line"><span class="lineno"> 1008</span>        <span class="keywordflow">default</span>:</div>
<div class="line"><span class="lineno"> 1009</span>          <a class="code hl_function" href="MooseError_8h.html#aa959168eed29caa7aaa85ffc1319a9ad">mooseError</a>(<span class="stringliteral">&quot;get_sub_elem_inds: Face element type: &quot;</span>,</div>
<div class="line"><span class="lineno"> 1010</span>                     libMesh::Utility::enum_to_string&lt;ElemType&gt;(type),</div>
<div class="line"><span class="lineno"> 1011</span>                     <span class="stringliteral">&quot; invalid for 3D mortar&quot;</span>);</div>
<div class="line"><span class="lineno"> 1012</span>      }</div>
<div class="line"><span class="lineno"> 1013</span>    };</div>
<div class="line"><span class="lineno"> 1014</span> </div>
<div class="line"><span class="lineno"> 1018</span>    <span class="keywordflow">for</span> (MeshBase::const_element_iterator el = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.active_local_elements_begin(),</div>
<div class="line"><span class="lineno"> 1019</span>                                          end_el = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.active_local_elements_end();</div>
<div class="line"><span class="lineno"> 1020</span>         el != end_el;</div>
<div class="line"><span class="lineno"> 1021</span>         ++el)</div>
<div class="line"><span class="lineno"> 1022</span>    {</div>
<div class="line"><span class="lineno"> 1023</span>      <span class="keyword">const</span> Elem * secondary_side_elem = *el;</div>
<div class="line"><span class="lineno"> 1024</span> </div>
<div class="line"><span class="lineno"> 1025</span>      <span class="keyword">const</span> Real secondary_volume = secondary_side_elem-&gt;volume();</div>
<div class="line"><span class="lineno"> 1026</span> </div>
<div class="line"><span class="lineno"> 1027</span>      <span class="comment">// If this Elem is not in the current secondary subdomain, go on to the next one.</span></div>
<div class="line"><span class="lineno"> 1028</span>      <span class="keywordflow">if</span> (secondary_side_elem-&gt;subdomain_id() != secondary_subd_id)</div>
<div class="line"><span class="lineno"> 1029</span>        <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno"> 1030</span> </div>
<div class="line"><span class="lineno"> 1031</span>      <span class="keyword">auto</span> [secondary_elem_to_msm_map_it, insertion_happened] =</div>
<div class="line"><span class="lineno"> 1032</span>          <a class="code hl_variable" href="classAutomaticMortarGeneration.html#af0da3b7d9e404238718805e12452d74d">_secondary_elems_to_mortar_segments</a>.emplace(secondary_side_elem-&gt;id(),</div>
<div class="line"><span class="lineno"> 1033</span>                                                      std::set&lt;Elem *, CompareDofObjectsByID&gt;{});</div>
<div class="line"><span class="lineno"> 1034</span>      libmesh_ignore(insertion_happened);</div>
<div class="line"><span class="lineno"> 1035</span>      <span class="keyword">auto</span> &amp; secondary_to_msm_element_set = secondary_elem_to_msm_map_it-&gt;second;</div>
<div class="line"><span class="lineno"> 1036</span> </div>
<div class="line"><span class="lineno"> 1037</span>      std::vector&lt;std::unique_ptr&lt;MortarSegmentHelper&gt;&gt; mortar_segment_helper(</div>
<div class="line"><span class="lineno"> 1038</span>          secondary_side_elem-&gt;n_sub_elem());</div>
<div class="line"><span class="lineno"> 1039</span>      <span class="keyword">const</span> <span class="keyword">auto</span> nodal_normals = <a class="code hl_function" href="classAutomaticMortarGeneration.html#ae200397e9841242f1bc2438b2156f253">getNodalNormals</a>(*secondary_side_elem);</div>
<div class="line"><span class="lineno"> 1040</span> </div>
<div class="line"><span class="lineno"> 1051</span>      <span class="keywordflow">for</span> (<span class="keyword">auto</span> sel : make_range(secondary_side_elem-&gt;n_sub_elem()))</div>
<div class="line"><span class="lineno"> 1052</span>      {</div>
<div class="line"><span class="lineno"> 1053</span>        <span class="comment">// Get indices of sub-element nodes in element</span></div>
<div class="line"><span class="lineno"> 1054</span>        <span class="keyword">auto</span> sub_elem_nodes = get_sub_elem_nodes(secondary_side_elem-&gt;type(), sel);</div>
<div class="line"><span class="lineno"> 1055</span> </div>
<div class="line"><span class="lineno"> 1056</span>        <span class="comment">// Secondary sub-element center, normal, and nodes</span></div>
<div class="line"><span class="lineno"> 1057</span>        Point center;</div>
<div class="line"><span class="lineno"> 1058</span>        Point normal;</div>
<div class="line"><span class="lineno"> 1059</span>        std::vector&lt;Point&gt; nodes(sub_elem_nodes.size());</div>
<div class="line"><span class="lineno"> 1060</span> </div>
<div class="line"><span class="lineno"> 1061</span>        <span class="comment">// Loop through sub_element nodes, collect points and compute center and normal</span></div>
<div class="line"><span class="lineno"> 1062</span>        <span class="keywordflow">for</span> (<span class="keyword">auto</span> iv : make_range(sub_elem_nodes.size()))</div>
<div class="line"><span class="lineno"> 1063</span>        {</div>
<div class="line"><span class="lineno"> 1064</span>          <span class="keyword">const</span> <span class="keyword">auto</span> n = sub_elem_nodes[iv];</div>
<div class="line"><span class="lineno"> 1065</span>          nodes[iv] = secondary_side_elem-&gt;point(n);</div>
<div class="line"><span class="lineno"> 1066</span>          center += secondary_side_elem-&gt;point(n);</div>
<div class="line"><span class="lineno"> 1067</span>          normal += nodal_normals[n];</div>
<div class="line"><span class="lineno"> 1068</span>        }</div>
<div class="line"><span class="lineno"> 1069</span>        center /= sub_elem_nodes.size();</div>
<div class="line"><span class="lineno"> 1070</span>        normal = normal.unit();</div>
<div class="line"><span class="lineno"> 1071</span> </div>
<div class="line"><span class="lineno"> 1072</span>        <span class="comment">// Build and store linearized sub-elements for later use</span></div>
<div class="line"><span class="lineno"> 1073</span>        mortar_segment_helper[sel] = std::make_unique&lt;MortarSegmentHelper&gt;(nodes, center, normal);</div>
<div class="line"><span class="lineno"> 1074</span>      }</div>
<div class="line"><span class="lineno"> 1075</span> </div>
<div class="line"><span class="lineno"> 1081</span>      <span class="comment">// Search point for performing Nanoflann (k-d tree) searches.</span></div>
<div class="line"><span class="lineno"> 1082</span>      <span class="comment">// In each case we use the center point of the original element (not sub-elements for second</span></div>
<div class="line"><span class="lineno"> 1083</span>      <span class="comment">// order elements). This is to do search for all sub-elements simultaneously</span></div>
<div class="line"><span class="lineno"> 1084</span>      std::array&lt;Real, 3&gt; query_pt;</div>
<div class="line"><span class="lineno"> 1085</span>      Point center_point;</div>
<div class="line"><span class="lineno"> 1086</span>      <span class="keywordflow">switch</span> (secondary_side_elem-&gt;type())</div>
<div class="line"><span class="lineno"> 1087</span>      {</div>
<div class="line"><span class="lineno"> 1088</span>        <span class="keywordflow">case</span> TRI3:</div>
<div class="line"><span class="lineno"> 1089</span>        <span class="keywordflow">case</span> QUAD4:</div>
<div class="line"><span class="lineno"> 1090</span>          center_point = mortar_segment_helper[0]-&gt;center();</div>
<div class="line"><span class="lineno"> 1091</span>          query_pt = {{center_point(0), center_point(1), center_point(2)}};</div>
<div class="line"><span class="lineno"> 1092</span>          <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 1093</span>        <span class="keywordflow">case</span> TRI6:</div>
<div class="line"><span class="lineno"> 1094</span>        <span class="keywordflow">case</span> TRI7:</div>
<div class="line"><span class="lineno"> 1095</span>          center_point = mortar_segment_helper[1]-&gt;center();</div>
<div class="line"><span class="lineno"> 1096</span>          query_pt = {{center_point(0), center_point(1), center_point(2)}};</div>
<div class="line"><span class="lineno"> 1097</span>          <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 1098</span>        <span class="keywordflow">case</span> QUAD8:</div>
<div class="line"><span class="lineno"> 1099</span>          center_point = mortar_segment_helper[4]-&gt;center();</div>
<div class="line"><span class="lineno"> 1100</span>          query_pt = {{center_point(0), center_point(1), center_point(2)}};</div>
<div class="line"><span class="lineno"> 1101</span>          <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 1102</span>        <span class="keywordflow">case</span> QUAD9:</div>
<div class="line"><span class="lineno"> 1103</span>          center_point = secondary_side_elem-&gt;point(8);</div>
<div class="line"><span class="lineno"> 1104</span>          query_pt = {{center_point(0), center_point(1), center_point(2)}};</div>
<div class="line"><span class="lineno"> 1105</span>          <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 1106</span>        <span class="keywordflow">default</span>:</div>
<div class="line"><span class="lineno"> 1107</span>          <a class="code hl_function" href="MooseError_8h.html#aa959168eed29caa7aaa85ffc1319a9ad">mooseError</a>(</div>
<div class="line"><span class="lineno"> 1108</span>              <span class="stringliteral">&quot;Face element type: &quot;</span>, secondary_side_elem-&gt;type(), <span class="stringliteral">&quot;not supported for 3D mortar&quot;</span>);</div>
<div class="line"><span class="lineno"> 1109</span>      }</div>
<div class="line"><span class="lineno"> 1110</span> </div>
<div class="line"><span class="lineno"> 1111</span>      <span class="comment">// The number of results we want to get. These results will only be used to find</span></div>
<div class="line"><span class="lineno"> 1112</span>      <span class="comment">// a single element with non-trivial overlap, after an element is identified a breadth</span></div>
<div class="line"><span class="lineno"> 1113</span>      <span class="comment">// first search is done on neighbors</span></div>
<div class="line"><span class="lineno"> 1114</span>      <span class="keyword">const</span> std::size_t num_results = 3;</div>
<div class="line"><span class="lineno"> 1115</span> </div>
<div class="line"><span class="lineno"> 1116</span>      <span class="comment">// Initialize result_set and do the search.</span></div>
<div class="line"><span class="lineno"> 1117</span>      std::vector&lt;size_t&gt; ret_index(num_results);</div>
<div class="line"><span class="lineno"> 1118</span>      std::vector&lt;Real&gt; out_dist_sqr(num_results);</div>
<div class="line"><span class="lineno"> 1119</span>      nanoflann::KNNResultSet&lt;Real&gt; result_set(num_results);</div>
<div class="line"><span class="lineno"> 1120</span>      result_set.init(&amp;ret_index[0], &amp;out_dist_sqr[0]);</div>
<div class="line"><span class="lineno"> 1121</span>      kd_tree.findNeighbors(result_set, &amp;query_pt[0], <a class="code hl_typedef" href="namespacenanoflann.html#a7475277cf1d06434e352ade6f35de645">nanoflann::SearchParameters</a>());</div>
<div class="line"><span class="lineno"> 1122</span> </div>
<div class="line"><span class="lineno"> 1123</span>      <span class="comment">// Initialize list of processed primary elements, we don&#39;t want to revisit processed elements</span></div>
<div class="line"><span class="lineno"> 1124</span>      std::set&lt;const Elem *, CompareDofObjectsByID&gt; processed_primary_elems;</div>
<div class="line"><span class="lineno"> 1125</span> </div>
<div class="line"><span class="lineno"> 1126</span>      <span class="comment">// Initialize candidate set and flag for switching between coarse screening and breadth-first</span></div>
<div class="line"><span class="lineno"> 1127</span>      <span class="comment">// search</span></div>
<div class="line"><span class="lineno"> 1128</span>      <span class="keywordtype">bool</span> primary_elem_found = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno"> 1129</span>      std::set&lt;const Elem *, CompareDofObjectsByID&gt; primary_elem_candidates;</div>
<div class="line"><span class="lineno"> 1130</span> </div>
<div class="line"><span class="lineno"> 1131</span>      <span class="comment">// Loop candidate nodes (returned by Nanoflann) and add all adjoining elems to candidate set</span></div>
<div class="line"><span class="lineno"> 1132</span>      <span class="keywordflow">for</span> (<span class="keyword">auto</span> r : make_range(result_set.size()))</div>
<div class="line"><span class="lineno"> 1133</span>      {</div>
<div class="line"><span class="lineno"> 1134</span>        <span class="comment">// Verify that the squared distance we compute is the same as nanoflann&#39;s</span></div>
<div class="line"><span class="lineno"> 1135</span>        mooseAssert(std::abs((<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.point(ret_index[r]) - center_point).norm_sq() -</div>
<div class="line"><span class="lineno"> 1136</span>                             out_dist_sqr[r]) &lt;= TOLERANCE,</div>
<div class="line"><span class="lineno"> 1137</span>                    <span class="stringliteral">&quot;Lower-dimensional element squared distance verification failed.&quot;</span>);</div>
<div class="line"><span class="lineno"> 1138</span> </div>
<div class="line"><span class="lineno"> 1139</span>        <span class="comment">// Get list of elems connected to node</span></div>
<div class="line"><span class="lineno"> 1140</span>        std::vector&lt;const Elem *&gt; &amp; node_elems =</div>
<div class="line"><span class="lineno"> 1141</span>            this-&gt;<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a1ee9b6e4f8bd88603e22117085758f70">_nodes_to_primary_elem_map</a>.at(<span class="keyword">static_cast&lt;</span>dof_id_type<span class="keyword">&gt;</span>(ret_index[r]));</div>
<div class="line"><span class="lineno"> 1142</span> </div>
<div class="line"><span class="lineno"> 1143</span>        <span class="comment">// Uniquely add elems to candidate set</span></div>
<div class="line"><span class="lineno"> 1144</span>        <span class="keywordflow">for</span> (<span class="keyword">auto</span> elem : node_elems)</div>
<div class="line"><span class="lineno"> 1145</span>          primary_elem_candidates.insert(elem);</div>
<div class="line"><span class="lineno"> 1146</span>      }</div>
<div class="line"><span class="lineno"> 1147</span> </div>
<div class="line"><span class="lineno"> 1155</span>      <span class="keywordflow">while</span> (!primary_elem_candidates.empty())</div>
<div class="line"><span class="lineno"> 1156</span>      {</div>
<div class="line"><span class="lineno"> 1157</span>        <span class="keyword">const</span> Elem * primary_elem_candidate = *primary_elem_candidates.begin();</div>
<div class="line"><span class="lineno"> 1158</span> </div>
<div class="line"><span class="lineno"> 1159</span>        <span class="comment">// If we&#39;ve already processed this candidate, we don&#39;t need to check it again.</span></div>
<div class="line"><span class="lineno"> 1160</span>        <span class="keywordflow">if</span> (processed_primary_elems.count(primary_elem_candidate))</div>
<div class="line"><span class="lineno"> 1161</span>          <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno"> 1162</span> </div>
<div class="line"><span class="lineno"> 1163</span>        <span class="comment">// Initialize set of nodes used to construct mortar segment elements</span></div>
<div class="line"><span class="lineno"> 1164</span>        std::vector&lt;Point&gt; nodal_points;</div>
<div class="line"><span class="lineno"> 1165</span> </div>
<div class="line"><span class="lineno"> 1166</span>        <span class="comment">// Initialize map from mortar segment elements to nodes</span></div>
<div class="line"><span class="lineno"> 1167</span>        std::vector&lt;std::vector&lt;unsigned int&gt;&gt; elem_to_node_map;</div>
<div class="line"><span class="lineno"> 1168</span> </div>
<div class="line"><span class="lineno"> 1169</span>        <span class="comment">// Initialize list of secondary and primary sub-elements that formed each mortar segment</span></div>
<div class="line"><span class="lineno"> 1170</span>        std::vector&lt;std::pair&lt;unsigned int, unsigned int&gt;&gt; sub_elem_map;</div>
<div class="line"><span class="lineno"> 1171</span> </div>
<div class="line"><span class="lineno"> 1176</span>        <span class="keywordflow">for</span> (<span class="keyword">auto</span> p_el : make_range(primary_elem_candidate-&gt;n_sub_elem()))</div>
<div class="line"><span class="lineno"> 1177</span>        {</div>
<div class="line"><span class="lineno"> 1178</span>          <span class="comment">// Get nodes of primary sub-elements</span></div>
<div class="line"><span class="lineno"> 1179</span>          <span class="keyword">auto</span> sub_elem_nodes = get_sub_elem_nodes(primary_elem_candidate-&gt;type(), p_el);</div>
<div class="line"><span class="lineno"> 1180</span> </div>
<div class="line"><span class="lineno"> 1181</span>          <span class="comment">// Get list of primary sub-element vertex nodes</span></div>
<div class="line"><span class="lineno"> 1182</span>          std::vector&lt;Point&gt; primary_sub_elem(sub_elem_nodes.size());</div>
<div class="line"><span class="lineno"> 1183</span>          <span class="keywordflow">for</span> (<span class="keyword">auto</span> iv : make_range(sub_elem_nodes.size()))</div>
<div class="line"><span class="lineno"> 1184</span>          {</div>
<div class="line"><span class="lineno"> 1185</span>            <span class="keyword">const</span> <span class="keyword">auto</span> n = sub_elem_nodes[iv];</div>
<div class="line"><span class="lineno"> 1186</span>            primary_sub_elem[iv] = primary_elem_candidate-&gt;point(n);</div>
<div class="line"><span class="lineno"> 1187</span>          }</div>
<div class="line"><span class="lineno"> 1188</span> </div>
<div class="line"><span class="lineno"> 1189</span>          <span class="comment">// Loop through secondary sub-elements</span></div>
<div class="line"><span class="lineno"> 1190</span>          <span class="keywordflow">for</span> (<span class="keyword">auto</span> s_el : make_range(secondary_side_elem-&gt;n_sub_elem()))</div>
<div class="line"><span class="lineno"> 1191</span>          {</div>
<div class="line"><span class="lineno"> 1192</span>            <span class="comment">// Mortar segment helpers were defined for each secondary sub-element, they will:</span></div>
<div class="line"><span class="lineno"> 1193</span>            <span class="comment">//  1. Project primary sub-element onto linearized secondary sub-element</span></div>
<div class="line"><span class="lineno"> 1194</span>            <span class="comment">//  2. Clip projected primary sub-element against secondary sub-element</span></div>
<div class="line"><span class="lineno"> 1195</span>            <span class="comment">//  3. Triangulate clipped polygon to form mortar segments</span></div>
<div class="line"><span class="lineno"> 1196</span>            <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 1197</span>            <span class="comment">// Mortar segment helpers append a list of mortar segment nodes and connectivities that</span></div>
<div class="line"><span class="lineno"> 1198</span>            <span class="comment">// can be directly used to build mortar segments</span></div>
<div class="line"><span class="lineno"> 1199</span>            mortar_segment_helper[s_el]-&gt;getMortarSegments(</div>
<div class="line"><span class="lineno"> 1200</span>                primary_sub_elem, nodal_points, elem_to_node_map);</div>
<div class="line"><span class="lineno"> 1201</span> </div>
<div class="line"><span class="lineno"> 1202</span>            <span class="comment">// Keep track of which secondary and primary sub-elements created segment</span></div>
<div class="line"><span class="lineno"> 1203</span>            <span class="keywordflow">for</span> (<span class="keyword">auto</span> i = sub_elem_map.size(); i &lt; elem_to_node_map.size(); ++i)</div>
<div class="line"><span class="lineno"> 1204</span>              sub_elem_map.push_back(std::make_pair(s_el, p_el));</div>
<div class="line"><span class="lineno"> 1205</span>          }</div>
<div class="line"><span class="lineno"> 1206</span>        }</div>
<div class="line"><span class="lineno"> 1207</span> </div>
<div class="line"><span class="lineno"> 1208</span>        <span class="comment">// Mark primary element as processed and remove from candidate list</span></div>
<div class="line"><span class="lineno"> 1209</span>        processed_primary_elems.insert(primary_elem_candidate);</div>
<div class="line"><span class="lineno"> 1210</span>        primary_elem_candidates.erase(primary_elem_candidate);</div>
<div class="line"><span class="lineno"> 1211</span> </div>
<div class="line"><span class="lineno"> 1212</span>        <span class="comment">// If overlap of polygons was non-trivial (created mortar segment elements)</span></div>
<div class="line"><span class="lineno"> 1213</span>        <span class="keywordflow">if</span> (!elem_to_node_map.empty())</div>
<div class="line"><span class="lineno"> 1214</span>        {</div>
<div class="line"><span class="lineno"> 1215</span>          <span class="comment">// If this is the first element with non-trivial overlap, set flag</span></div>
<div class="line"><span class="lineno"> 1216</span>          <span class="comment">// Candidates will now be neighbors of elements that had non-trivial overlap</span></div>
<div class="line"><span class="lineno"> 1217</span>          <span class="comment">// (i.e. we&#39;ll do a breadth first search now)</span></div>
<div class="line"><span class="lineno"> 1218</span>          <span class="keywordflow">if</span> (!primary_elem_found)</div>
<div class="line"><span class="lineno"> 1219</span>          {</div>
<div class="line"><span class="lineno"> 1220</span>            primary_elem_found = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 1221</span>            primary_elem_candidates.clear();</div>
<div class="line"><span class="lineno"> 1222</span>          }</div>
<div class="line"><span class="lineno"> 1223</span> </div>
<div class="line"><span class="lineno"> 1224</span>          <span class="comment">// Add neighbors to candidate list</span></div>
<div class="line"><span class="lineno"> 1225</span>          <span class="keywordflow">for</span> (<span class="keyword">auto</span> neighbor : primary_elem_candidate-&gt;neighbor_ptr_range())</div>
<div class="line"><span class="lineno"> 1226</span>          {</div>
<div class="line"><span class="lineno"> 1227</span>            <span class="comment">// If not valid or not on lower dimensional secondary subdomain, skip</span></div>
<div class="line"><span class="lineno"> 1228</span>            <span class="keywordflow">if</span> (neighbor == <span class="keyword">nullptr</span> || neighbor-&gt;subdomain_id() != primary_subd_id)</div>
<div class="line"><span class="lineno"> 1229</span>              <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno"> 1230</span>            <span class="comment">// If already processed, skip</span></div>
<div class="line"><span class="lineno"> 1231</span>            <span class="keywordflow">if</span> (processed_primary_elems.count(neighbor))</div>
<div class="line"><span class="lineno"> 1232</span>              <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno"> 1233</span>            <span class="comment">// Otherwise, add to candidates</span></div>
<div class="line"><span class="lineno"> 1234</span>            primary_elem_candidates.insert(neighbor);</div>
<div class="line"><span class="lineno"> 1235</span>          }</div>
<div class="line"><span class="lineno"> 1236</span> </div>
<div class="line"><span class="lineno"> 1240</span>          std::vector&lt;Node *&gt; new_nodes;</div>
<div class="line"><span class="lineno"> 1241</span>          <span class="keywordflow">for</span> (<span class="keyword">auto</span> pt : nodal_points)</div>
<div class="line"><span class="lineno"> 1242</span>            new_nodes.push_back(<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;add_point(</div>
<div class="line"><span class="lineno"> 1243</span>                pt, <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;max_node_id(), secondary_side_elem-&gt;processor_id()));</div>
<div class="line"><span class="lineno"> 1244</span> </div>
<div class="line"><span class="lineno"> 1245</span>          <span class="comment">// Loop through triangular elements in map</span></div>
<div class="line"><span class="lineno"> 1246</span>          <span class="keywordflow">for</span> (<span class="keyword">auto</span> el : index_range(elem_to_node_map))</div>
<div class="line"><span class="lineno"> 1247</span>          {</div>
<div class="line"><span class="lineno"> 1248</span>            <span class="comment">// Create new triangular element</span></div>
<div class="line"><span class="lineno"> 1249</span>            std::unique_ptr&lt;Elem&gt; new_elem;</div>
<div class="line"><span class="lineno"> 1250</span>            <span class="keywordflow">if</span> (elem_to_node_map[el].size() == 3)</div>
<div class="line"><span class="lineno"> 1251</span>              new_elem = std::make_unique&lt;Tri3&gt;();</div>
<div class="line"><span class="lineno"> 1252</span>            <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno"> 1253</span>              <a class="code hl_function" href="MooseError_8h.html#aa959168eed29caa7aaa85ffc1319a9ad">mooseError</a>(<span class="stringliteral">&quot;Active mortar segments only supports TRI elements, 3 nodes expected &quot;</span></div>
<div class="line"><span class="lineno"> 1254</span>                         <span class="stringliteral">&quot;but: &quot;</span>,</div>
<div class="line"><span class="lineno"> 1255</span>                         elem_to_node_map[el].size(),</div>
<div class="line"><span class="lineno"> 1256</span>                         <span class="stringliteral">&quot; provided.&quot;</span>);</div>
<div class="line"><span class="lineno"> 1257</span> </div>
<div class="line"><span class="lineno"> 1258</span>            new_elem-&gt;processor_id() = secondary_side_elem-&gt;processor_id();</div>
<div class="line"><span class="lineno"> 1259</span>            new_elem-&gt;subdomain_id() = secondary_side_elem-&gt;subdomain_id();</div>
<div class="line"><span class="lineno"> 1260</span>            new_elem-&gt;set_id(local_id_index++);</div>
<div class="line"><span class="lineno"> 1261</span> </div>
<div class="line"><span class="lineno"> 1262</span>            <span class="comment">// Attach newly created nodes</span></div>
<div class="line"><span class="lineno"> 1263</span>            <span class="keywordflow">for</span> (<span class="keyword">auto</span> i : index_range(elem_to_node_map[el]))</div>
<div class="line"><span class="lineno"> 1264</span>              new_elem-&gt;set_node(i) = new_nodes[elem_to_node_map[el][i]];</div>
<div class="line"><span class="lineno"> 1265</span> </div>
<div class="line"><span class="lineno"> 1266</span>            <span class="comment">// If element is smaller than tolerance, don&#39;t add to msm</span></div>
<div class="line"><span class="lineno"> 1267</span>            <span class="keywordflow">if</span> (new_elem-&gt;volume() / secondary_volume &lt; TOLERANCE)</div>
<div class="line"><span class="lineno"> 1268</span>              <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno"> 1269</span> </div>
<div class="line"><span class="lineno"> 1270</span>            <span class="comment">// Add elements to mortar segment mesh</span></div>
<div class="line"><span class="lineno"> 1271</span>            Elem * msm_new_elem = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;add_elem(new_elem.release());</div>
<div class="line"><span class="lineno"> 1272</span> </div>
<div class="line"><span class="lineno"> 1273</span>            msm_new_elem-&gt;set_extra_integer(secondary_sub_elem, sub_elem_map[el].first);</div>
<div class="line"><span class="lineno"> 1274</span>            msm_new_elem-&gt;set_extra_integer(primary_sub_elem, sub_elem_map[el].second);</div>
<div class="line"><span class="lineno"> 1275</span> </div>
<div class="line"><span class="lineno"> 1276</span>            <span class="comment">// Fill out mortar segment info</span></div>
<div class="line"><span class="lineno"> 1277</span>            <a class="code hl_struct" href="structMortarSegmentInfo.html">MortarSegmentInfo</a> msinfo;</div>
<div class="line"><span class="lineno"> 1278</span>            msinfo.<a class="code hl_variable" href="structMortarSegmentInfo.html#afa8c2918a473f0dad90d5c68dad00eb4">secondary_elem</a> = secondary_side_elem;</div>
<div class="line"><span class="lineno"> 1279</span>            msinfo.<a class="code hl_variable" href="structMortarSegmentInfo.html#a3316fbff8584e06e3c973d3f3e6ff05f">primary_elem</a> = primary_elem_candidate;</div>
<div class="line"><span class="lineno"> 1280</span> </div>
<div class="line"><span class="lineno"> 1281</span>            <span class="comment">// Associate this MSM elem with the MortarSegmentInfo.</span></div>
<div class="line"><span class="lineno"> 1282</span>            <a class="code hl_variable" href="classAutomaticMortarGeneration.html#abbd91d3cf8bef528976fe6f932622d2d">_msm_elem_to_info</a>.emplace(msm_new_elem, msinfo);</div>
<div class="line"><span class="lineno"> 1283</span> </div>
<div class="line"><span class="lineno"> 1284</span>            <span class="comment">// Add this mortar segment to the secondary elem to mortar segment map</span></div>
<div class="line"><span class="lineno"> 1285</span>            secondary_to_msm_element_set.insert(msm_new_elem);</div>
<div class="line"><span class="lineno"> 1286</span> </div>
<div class="line"><span class="lineno"> 1287</span>            <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a7254faea651acd63b60b408ab560a0e5">_secondary_ip_sub_ids</a>.insert(msinfo.<a class="code hl_variable" href="structMortarSegmentInfo.html#afa8c2918a473f0dad90d5c68dad00eb4">secondary_elem</a>-&gt;interior_parent()-&gt;subdomain_id());</div>
<div class="line"><span class="lineno"> 1288</span>            <span class="comment">// Unlike for 2D, we always have a primary when building the mortar mesh so we don&#39;t</span></div>
<div class="line"><span class="lineno"> 1289</span>            <span class="comment">// have to check for null</span></div>
<div class="line"><span class="lineno"> 1290</span>            <a class="code hl_variable" href="classAutomaticMortarGeneration.html#ac99e408cefd4da80efa2649ef1d32e93">_primary_ip_sub_ids</a>.insert(msinfo.<a class="code hl_variable" href="structMortarSegmentInfo.html#a3316fbff8584e06e3c973d3f3e6ff05f">primary_elem</a>-&gt;interior_parent()-&gt;subdomain_id());</div>
<div class="line"><span class="lineno"> 1291</span>          }</div>
<div class="line"><span class="lineno"> 1292</span>        }</div>
<div class="line"><span class="lineno"> 1293</span>        <span class="comment">// End loop through primary element candidates</span></div>
<div class="line"><span class="lineno"> 1294</span>      }</div>
<div class="line"><span class="lineno"> 1295</span> </div>
<div class="line"><span class="lineno"> 1296</span>      <span class="keywordflow">for</span> (<span class="keyword">auto</span> sel : make_range(secondary_side_elem-&gt;n_sub_elem()))</div>
<div class="line"><span class="lineno"> 1297</span>      {</div>
<div class="line"><span class="lineno"> 1298</span>        <span class="comment">// Check if any segments failed to project</span></div>
<div class="line"><span class="lineno"> 1299</span>        <span class="keywordflow">if</span> (mortar_segment_helper[sel]-&gt;remainder() == 1.0)</div>
<div class="line"><span class="lineno"> 1300</span>          mooseDoOnce(</div>
<div class="line"><span class="lineno"> 1301</span>              <a class="code hl_function" href="MooseError_8h.html#a3d351254665674621ecbd38f57bb28ae">mooseWarning</a>(<span class="stringliteral">&quot;Some secondary elements on mortar interface were unable to identify&quot;</span></div>
<div class="line"><span class="lineno"> 1302</span>                           <span class="stringliteral">&quot; a corresponding primary element; this may be expected depending on&quot;</span></div>
<div class="line"><span class="lineno"> 1303</span>                           <span class="stringliteral">&quot; problem geometry but may indicate a failure of the element search&quot;</span></div>
<div class="line"><span class="lineno"> 1304</span>                           <span class="stringliteral">&quot; or projection&quot;</span>));</div>
<div class="line"><span class="lineno"> 1305</span>      }</div>
<div class="line"><span class="lineno"> 1306</span> </div>
<div class="line"><span class="lineno"> 1307</span>      <span class="keywordflow">if</span> (secondary_to_msm_element_set.empty())</div>
<div class="line"><span class="lineno"> 1308</span>        <a class="code hl_variable" href="classAutomaticMortarGeneration.html#af0da3b7d9e404238718805e12452d74d">_secondary_elems_to_mortar_segments</a>.erase(secondary_elem_to_msm_map_it);</div>
<div class="line"><span class="lineno"> 1309</span>    } <span class="comment">// End loop through secondary elements</span></div>
<div class="line"><span class="lineno"> 1310</span>  }   <span class="comment">// End loop through mortar constraint pairs</span></div>
<div class="line"><span class="lineno"> 1311</span> </div>
<div class="line"><span class="lineno"> 1312</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;cache_elem_data();</div>
<div class="line"><span class="lineno"> 1313</span> </div>
<div class="line"><span class="lineno"> 1314</span>  <span class="comment">// Output mortar segment mesh</span></div>
<div class="line"><span class="lineno"> 1315</span>  <span class="keywordflow">if</span> (<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a958de5b754ec676f463c50d2f16b5d0c">_debug</a>)</div>
<div class="line"><span class="lineno"> 1316</span>  {</div>
<div class="line"><span class="lineno"> 1317</span>    <span class="comment">// If element is not triangular, increment subdomain id</span></div>
<div class="line"><span class="lineno"> 1318</span>    <span class="comment">// (ExodusII does not support mixed element types in a single subdomain)</span></div>
<div class="line"><span class="lineno"> 1319</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> msm_el : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;active_local_element_ptr_range())</div>
<div class="line"><span class="lineno"> 1320</span>      <span class="keywordflow">if</span> (msm_el-&gt;type() != TRI3)</div>
<div class="line"><span class="lineno"> 1321</span>        msm_el-&gt;subdomain_id()++;</div>
<div class="line"><span class="lineno"> 1322</span> </div>
<div class="line"><span class="lineno"> 1323</span>    ExodusII_IO mortar_segment_mesh_writer(*<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>);</div>
<div class="line"><span class="lineno"> 1324</span> </div>
<div class="line"><span class="lineno"> 1325</span>    <span class="comment">// Default to non-HDF5 output for wider compatibility</span></div>
<div class="line"><span class="lineno"> 1326</span>    mortar_segment_mesh_writer.set_hdf5_writing(<span class="keyword">false</span>);</div>
<div class="line"><span class="lineno"> 1327</span> </div>
<div class="line"><span class="lineno"> 1328</span>    mortar_segment_mesh_writer.write(<span class="stringliteral">&quot;mortar_segment_mesh.e&quot;</span>);</div>
<div class="line"><span class="lineno"> 1329</span> </div>
<div class="line"><span class="lineno"> 1330</span>    <span class="comment">// Undo increment</span></div>
<div class="line"><span class="lineno"> 1331</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> msm_el : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;active_local_element_ptr_range())</div>
<div class="line"><span class="lineno"> 1332</span>      <span class="keywordflow">if</span> (msm_el-&gt;type() != TRI3)</div>
<div class="line"><span class="lineno"> 1333</span>        msm_el-&gt;subdomain_id()--;</div>
<div class="line"><span class="lineno"> 1334</span>  }</div>
<div class="line"><span class="lineno"> 1335</span> </div>
<div class="line"><span class="lineno"> 1336</span>  <a class="code hl_function" href="classAutomaticMortarGeneration.html#a6dfaa66a5dc83c679a3c4dd7aa0bf1ab">buildCouplingInformation</a>();</div>
<div class="line"><span class="lineno"> 1337</span> </div>
<div class="line"><span class="lineno"> 1338</span>  <span class="comment">// Print mortar segment mesh statistics</span></div>
<div class="line"><span class="lineno"> 1339</span>  <span class="keywordflow">if</span> (<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a958de5b754ec676f463c50d2f16b5d0c">_debug</a>)</div>
<div class="line"><span class="lineno"> 1340</span>  {</div>
<div class="line"><span class="lineno"> 1341</span>    <span class="keywordflow">if</span> (<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.n_processors() == 1)</div>
<div class="line"><span class="lineno"> 1342</span>      <a class="code hl_function" href="classAutomaticMortarGeneration.html#a345cd37f09eebfb0b829c15f7fd4a441">msmStatistics</a>();</div>
<div class="line"><span class="lineno"> 1343</span>    <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno"> 1344</span>      <a class="code hl_function" href="MooseError_8h.html#a3d351254665674621ecbd38f57bb28ae">mooseWarning</a>(<span class="stringliteral">&quot;Mortar segment mesh statistics intended for debugging purposes in serial only, &quot;</span></div>
<div class="line"><span class="lineno"> 1345</span>                   <span class="stringliteral">&quot;parallel will only provide statistics for local mortar segment mesh.&quot;</span>);</div>
<div class="line"><span class="lineno"> 1346</span>  }</div>
<div class="line"><span class="lineno"> 1347</span>}</div>
<div class="ttc" id="aNanoflannMeshAdaptor_8h_html_a3a70df33047194961ce21a0133717038"><div class="ttname"><a href="NanoflannMeshAdaptor_8h.html#a3a70df33047194961ce21a0133717038">subdomain_kd_tree_t</a></div><div class="ttdeci">nanoflann::KDTreeSingleIndexAdaptor&lt; subdomain_adatper_t, NanoflannMeshSubdomainAdaptor&lt; 3 &gt;, 3 &gt; subdomain_kd_tree_t</div><div class="ttdef"><b>Definition:</b> <a href="NanoflannMeshAdaptor_8h_source.html#l00209">NanoflannMeshAdaptor.h:209</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a345cd37f09eebfb0b829c15f7fd4a441"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a345cd37f09eebfb0b829c15f7fd4a441">AutomaticMortarGeneration::msmStatistics</a></div><div class="ttdeci">void msmStatistics()</div><div class="ttdoc">Outputs mesh statistics for mortar segment mesh.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8C_source.html#l01421">AutomaticMortarGeneration.C:1421</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_ae200397e9841242f1bc2438b2156f253"><div class="ttname"><a href="classAutomaticMortarGeneration.html#ae200397e9841242f1bc2438b2156f253">AutomaticMortarGeneration::getNodalNormals</a></div><div class="ttdeci">std::vector&lt; Point &gt; getNodalNormals(const Elem &amp;secondary_elem) const</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8C_source.html#l00322">AutomaticMortarGeneration.C:322</a></div></div>
<div class="ttc" id="aclassNanoflannMeshSubdomainAdaptor_html"><div class="ttname"><a href="classNanoflannMeshSubdomainAdaptor.html">NanoflannMeshSubdomainAdaptor</a></div><div class="ttdoc">Special adaptor that works with subdomains of the Mesh.</div><div class="ttdef"><b>Definition:</b> <a href="NanoflannMeshAdaptor_8h_source.html#l00118">NanoflannMeshAdaptor.h:119</a></div></div>
<div class="ttc" id="anamespacenanoflann_html_a7475277cf1d06434e352ade6f35de645"><div class="ttname"><a href="namespacenanoflann.html#a7475277cf1d06434e352ade6f35de645">nanoflann::SearchParameters</a></div><div class="ttdeci">SearchParams SearchParameters</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8C_source.html#l00057">AutomaticMortarGeneration.C:57</a></div></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="MortarData_8C_source.html#l00160">MortarData::update()</a>.</p>

</div>
</div>
<a id="a9b366747e19933f0beae2fbb9c0d969b" name="a9b366747e19933f0beae2fbb9c0d969b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b366747e19933f0beae2fbb9c0d969b">&#9670;&#160;</a></span>buildNodeToElemMaps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AutomaticMortarGeneration::buildNodeToElemMaps </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Once the secondary_requested_boundary_ids and primary_requested_boundary_ids containers have been filled in, call this function to build node-to-Elem maps for the lower-dimensional elements. </p>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00284">284</a> of file <a class="el" href="AutomaticMortarGeneration_8C_source.html">AutomaticMortarGeneration.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  285</span>{</div>
<div class="line"><span class="lineno">  286</span>  <span class="keywordflow">if</span> (<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a1d4166e27bcb186c75c320b232652cf1">_secondary_requested_boundary_ids</a>.empty() || <a class="code hl_variable" href="classAutomaticMortarGeneration.html#ad67507605b6ed18765d5ffd1243ff619">_primary_requested_boundary_ids</a>.empty())</div>
<div class="line"><span class="lineno">  287</span>    <a class="code hl_function" href="MooseError_8h.html#aa959168eed29caa7aaa85ffc1319a9ad">mooseError</a>(</div>
<div class="line"><span class="lineno">  288</span>        <span class="stringliteral">&quot;Must specify secondary and primary boundary ids before building node-to-elem maps.&quot;</span>);</div>
<div class="line"><span class="lineno">  289</span> </div>
<div class="line"><span class="lineno">  290</span>  <span class="comment">// Construct nodes_to_secondary_elem_map</span></div>
<div class="line"><span class="lineno">  291</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; secondary_elem :</div>
<div class="line"><span class="lineno">  292</span>       as_range(<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.active_elements_begin(), <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.active_elements_end()))</div>
<div class="line"><span class="lineno">  293</span>  {</div>
<div class="line"><span class="lineno">  294</span>    <span class="comment">// If this is not one of the lower-dimensional secondary side elements, go on to the next one.</span></div>
<div class="line"><span class="lineno">  295</span>    <span class="keywordflow">if</span> (!this-&gt;<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a59c6fd297125023195e7bfb3714846c5">_secondary_boundary_subdomain_ids</a>.count(secondary_elem-&gt;subdomain_id()))</div>
<div class="line"><span class="lineno">  296</span>      <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno">  297</span> </div>
<div class="line"><span class="lineno">  298</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; nd : secondary_elem-&gt;node_ref_range())</div>
<div class="line"><span class="lineno">  299</span>    {</div>
<div class="line"><span class="lineno">  300</span>      std::vector&lt;const Elem *&gt; &amp; vec = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a1ad443aa196d2c81d195b29ddeee1d5e">_nodes_to_secondary_elem_map</a>[nd.id()];</div>
<div class="line"><span class="lineno">  301</span>      vec.push_back(secondary_elem);</div>
<div class="line"><span class="lineno">  302</span>    }</div>
<div class="line"><span class="lineno">  303</span>  }</div>
<div class="line"><span class="lineno">  304</span> </div>
<div class="line"><span class="lineno">  305</span>  <span class="comment">// Construct nodes_to_primary_elem_map</span></div>
<div class="line"><span class="lineno">  306</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; primary_elem :</div>
<div class="line"><span class="lineno">  307</span>       as_range(<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.active_elements_begin(), <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.active_elements_end()))</div>
<div class="line"><span class="lineno">  308</span>  {</div>
<div class="line"><span class="lineno">  309</span>    <span class="comment">// If this is not one of the lower-dimensional primary side elements, go on to the next one.</span></div>
<div class="line"><span class="lineno">  310</span>    <span class="keywordflow">if</span> (!this-&gt;<a class="code hl_variable" href="classAutomaticMortarGeneration.html#acbe701da36a67d2d9546f9db735b1faf">_primary_boundary_subdomain_ids</a>.count(primary_elem-&gt;subdomain_id()))</div>
<div class="line"><span class="lineno">  311</span>      <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno">  312</span> </div>
<div class="line"><span class="lineno">  313</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; nd : primary_elem-&gt;node_ref_range())</div>
<div class="line"><span class="lineno">  314</span>    {</div>
<div class="line"><span class="lineno">  315</span>      std::vector&lt;const Elem *&gt; &amp; vec = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a1ee9b6e4f8bd88603e22117085758f70">_nodes_to_primary_elem_map</a>[nd.id()];</div>
<div class="line"><span class="lineno">  316</span>      vec.push_back(primary_elem);</div>
<div class="line"><span class="lineno">  317</span>    }</div>
<div class="line"><span class="lineno">  318</span>  }</div>
<div class="line"><span class="lineno">  319</span>}</div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a1ad443aa196d2c81d195b29ddeee1d5e"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a1ad443aa196d2c81d195b29ddeee1d5e">AutomaticMortarGeneration::_nodes_to_secondary_elem_map</a></div><div class="ttdeci">std::unordered_map&lt; dof_id_type, std::vector&lt; const Elem * &gt; &gt; _nodes_to_secondary_elem_map</div><div class="ttdoc">Map from nodes to connected lower-dimensional elements on the secondary/primary subdomains.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00366">AutomaticMortarGeneration.h:366</a></div></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="MortarData_8C_source.html#l00160">MortarData::update()</a>.</p>

</div>
</div>
<a id="aa871943ba7a8761cc220e90af9c716a0" name="aa871943ba7a8761cc220e90af9c716a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa871943ba7a8761cc220e90af9c716a0">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AutomaticMortarGeneration::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the mortar segment mesh and accompanying data structures. </p>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00265">265</a> of file <a class="el" href="AutomaticMortarGeneration_8C_source.html">AutomaticMortarGeneration.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  266</span>{</div>
<div class="line"><span class="lineno">  267</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;clear();</div>
<div class="line"><span class="lineno">  268</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a1ad443aa196d2c81d195b29ddeee1d5e">_nodes_to_secondary_elem_map</a>.clear();</div>
<div class="line"><span class="lineno">  269</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a1ee9b6e4f8bd88603e22117085758f70">_nodes_to_primary_elem_map</a>.clear();</div>
<div class="line"><span class="lineno">  270</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#abb4cc3e3102675e52675a95347ad8e95">_secondary_node_and_elem_to_xi2_primary_elem</a>.clear();</div>
<div class="line"><span class="lineno">  271</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#ac174eedb02e9681baf439360903700d4">_primary_node_and_elem_to_xi1_secondary_elem</a>.clear();</div>
<div class="line"><span class="lineno">  272</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#abbd91d3cf8bef528976fe6f932622d2d">_msm_elem_to_info</a>.clear();</div>
<div class="line"><span class="lineno">  273</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a169550fc1a82fca976e386edae0d254d">_lower_elem_to_side_id</a>.clear();</div>
<div class="line"><span class="lineno">  274</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#ab2357a3aacfa2cae90078e3b6293bf26">_mortar_interface_coupling</a>.clear();</div>
<div class="line"><span class="lineno">  275</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a06fb539aea2e63f3b48a6e1d41a2f568">_secondary_node_to_nodal_normal</a>.clear();</div>
<div class="line"><span class="lineno">  276</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a8120c89f18fdff39621fa512087a2da3">_secondary_node_to_hh_nodal_tangents</a>.clear();</div>
<div class="line"><span class="lineno">  277</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#acb676f79ae207404fb5d224ac768df42">_secondary_element_to_secondary_lowerd_element</a>.clear();</div>
<div class="line"><span class="lineno">  278</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#af0da3b7d9e404238718805e12452d74d">_secondary_elems_to_mortar_segments</a>.clear();</div>
<div class="line"><span class="lineno">  279</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a7254faea651acd63b60b408ab560a0e5">_secondary_ip_sub_ids</a>.clear();</div>
<div class="line"><span class="lineno">  280</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#ac99e408cefd4da80efa2649ef1d32e93">_primary_ip_sub_ids</a>.clear();</div>
<div class="line"><span class="lineno">  281</span>}</div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a06fb539aea2e63f3b48a6e1d41a2f568"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a06fb539aea2e63f3b48a6e1d41a2f568">AutomaticMortarGeneration::_secondary_node_to_nodal_normal</a></div><div class="ttdeci">std::unordered_map&lt; const Node *, Point &gt; _secondary_node_to_nodal_normal</div><div class="ttdoc">Container for storing the nodal normal vector associated with each secondary node.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00430">AutomaticMortarGeneration.h:430</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a169550fc1a82fca976e386edae0d254d"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a169550fc1a82fca976e386edae0d254d">AutomaticMortarGeneration::_lower_elem_to_side_id</a></div><div class="ttdeci">std::unordered_map&lt; const Elem *, unsigned int &gt; _lower_elem_to_side_id</div><div class="ttdoc">Keeps track of the mapping between lower-dimensional elements and the side_id of the interior_parent ...</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00408">AutomaticMortarGeneration.h:408</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a8120c89f18fdff39621fa512087a2da3"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a8120c89f18fdff39621fa512087a2da3">AutomaticMortarGeneration::_secondary_node_to_hh_nodal_tangents</a></div><div class="ttdeci">std::unordered_map&lt; const Node *, std::array&lt; Point, 2 &gt; &gt; _secondary_node_to_hh_nodal_tangents</div><div class="ttdoc">Container for storing the nodal tangent/binormal vectors associated with each secondary node (Househo...</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00434">AutomaticMortarGeneration.h:434</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_acb676f79ae207404fb5d224ac768df42"><div class="ttname"><a href="classAutomaticMortarGeneration.html#acb676f79ae207404fb5d224ac768df42">AutomaticMortarGeneration::_secondary_element_to_secondary_lowerd_element</a></div><div class="ttdeci">std::unordered_map&lt; dof_id_type, const Elem * &gt; _secondary_element_to_secondary_lowerd_element</div><div class="ttdoc">Map from full dimensional secondary element id to lower dimensional secondary element.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00437">AutomaticMortarGeneration.h:437</a></div></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="MortarData_8C_source.html#l00160">MortarData::update()</a>.</p>

</div>
</div>
<a id="a545496202789a72da1ffc639dedf322a" name="a545496202789a72da1ffc639dedf322a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a545496202789a72da1ffc639dedf322a">&#9670;&#160;</a></span>computeInactiveLMElems()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AutomaticMortarGeneration::computeInactiveLMElems </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get list of secondary elems without any corresponding primary elements. </p>
<p >Used to enforce zero values on inactive DoFs of elemental variables. </p>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01661">1661</a> of file <a class="el" href="AutomaticMortarGeneration_8C_source.html">AutomaticMortarGeneration.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1662</span>{</div>
<div class="line"><span class="lineno"> 1663</span>  <span class="comment">// Mark all active secondary elements</span></div>
<div class="line"><span class="lineno"> 1664</span>  std::unordered_set&lt;const Elem *&gt; active_local_elems;</div>
<div class="line"><span class="lineno"> 1665</span> </div>
<div class="line"><span class="lineno"> 1666</span>  <span class="comment">//****</span></div>
<div class="line"><span class="lineno"> 1667</span>  <span class="comment">// Note that in 3D our trick to check whether an element has edge dropping needs loose tolerances</span></div>
<div class="line"><span class="lineno"> 1668</span>  <span class="comment">// since the mortar segments are on the linearized element and comparing the volume of the</span></div>
<div class="line"><span class="lineno"> 1669</span>  <span class="comment">// linearized element does not have the same volume as the warped element</span></div>
<div class="line"><span class="lineno"> 1670</span>  <span class="keyword">const</span> Real tol = (<a class="code hl_function" href="classAutomaticMortarGeneration.html#ad0031e96df8f32e5c456a98532509404">dim</a>() == 3) ? 0.1 : TOLERANCE;</div>
<div class="line"><span class="lineno"> 1671</span> </div>
<div class="line"><span class="lineno"> 1672</span>  std::unordered_map&lt;const Elem *, Real&gt; active_volume;</div>
<div class="line"><span class="lineno"> 1673</span> </div>
<div class="line"><span class="lineno"> 1674</span>  <span class="comment">// Compute fraction of elements with corresponding primary elements</span></div>
<div class="line"><span class="lineno"> 1675</span>  <span class="keywordflow">if</span> (!<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a689b49e6bae35fa2ba975b844c4ec82e">_correct_edge_dropping</a>)</div>
<div class="line"><span class="lineno"> 1676</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> msm_elem : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;active_local_element_ptr_range())</div>
<div class="line"><span class="lineno"> 1677</span>    {</div>
<div class="line"><span class="lineno"> 1678</span>      <span class="keyword">const</span> <a class="code hl_struct" href="structMortarSegmentInfo.html">MortarSegmentInfo</a> &amp; msinfo = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#abbd91d3cf8bef528976fe6f932622d2d">_msm_elem_to_info</a>.at(msm_elem);</div>
<div class="line"><span class="lineno"> 1679</span>      <span class="keyword">const</span> Elem * secondary_elem = msinfo.<a class="code hl_variable" href="structMortarSegmentInfo.html#afa8c2918a473f0dad90d5c68dad00eb4">secondary_elem</a>;</div>
<div class="line"><span class="lineno"> 1680</span> </div>
<div class="line"><span class="lineno"> 1681</span>      active_volume[secondary_elem] += msm_elem-&gt;volume();</div>
<div class="line"><span class="lineno"> 1682</span>    }</div>
<div class="line"><span class="lineno"> 1683</span>  <span class="comment">//****</span></div>
<div class="line"><span class="lineno"> 1684</span> </div>
<div class="line"><span class="lineno"> 1685</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> msm_elem : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;active_local_element_ptr_range())</div>
<div class="line"><span class="lineno"> 1686</span>  {</div>
<div class="line"><span class="lineno"> 1687</span>    <span class="keyword">const</span> <a class="code hl_struct" href="structMortarSegmentInfo.html">MortarSegmentInfo</a> &amp; msinfo = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#abbd91d3cf8bef528976fe6f932622d2d">_msm_elem_to_info</a>.at(msm_elem);</div>
<div class="line"><span class="lineno"> 1688</span>    <span class="keyword">const</span> Elem * secondary_elem = msinfo.<a class="code hl_variable" href="structMortarSegmentInfo.html#afa8c2918a473f0dad90d5c68dad00eb4">secondary_elem</a>;</div>
<div class="line"><span class="lineno"> 1689</span> </div>
<div class="line"><span class="lineno"> 1690</span>    <span class="comment">//****</span></div>
<div class="line"><span class="lineno"> 1691</span>    <span class="keywordflow">if</span> (!<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a689b49e6bae35fa2ba975b844c4ec82e">_correct_edge_dropping</a>)</div>
<div class="line"><span class="lineno"> 1692</span>      <span class="keywordflow">if</span> (std::abs(active_volume[secondary_elem] / secondary_elem-&gt;volume() - 1.0) &gt; tol)</div>
<div class="line"><span class="lineno"> 1693</span>        <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno"> 1694</span>    <span class="comment">//****</span></div>
<div class="line"><span class="lineno"> 1695</span> </div>
<div class="line"><span class="lineno"> 1696</span>    active_local_elems.insert(secondary_elem);</div>
<div class="line"><span class="lineno"> 1697</span>  }</div>
<div class="line"><span class="lineno"> 1698</span> </div>
<div class="line"><span class="lineno"> 1699</span>  <span class="comment">// Take complement of active elements in active local subdomain to get inactive local elements</span></div>
<div class="line"><span class="lineno"> 1700</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#ac3445ab0b94ce0dc9c01a1234321ebaa">_inactive_local_lm_elems</a>.clear();</div>
<div class="line"><span class="lineno"> 1701</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; pr : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a969d4ab038fc8d447e966cd1e1600091">_primary_secondary_subdomain_id_pairs</a>)</div>
<div class="line"><span class="lineno"> 1702</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> el : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.active_local_subdomain_elements_ptr_range(</div>
<div class="line"><span class="lineno"> 1703</span>             <span class="comment">/*secondary_subd_id*/</span> pr.second))</div>
<div class="line"><span class="lineno"> 1704</span>      <span class="keywordflow">if</span> (active_local_elems.find(el) == active_local_elems.end())</div>
<div class="line"><span class="lineno"> 1705</span>        <a class="code hl_variable" href="classAutomaticMortarGeneration.html#ac3445ab0b94ce0dc9c01a1234321ebaa">_inactive_local_lm_elems</a>.insert(el);</div>
<div class="line"><span class="lineno"> 1706</span>}</div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_ac3445ab0b94ce0dc9c01a1234321ebaa"><div class="ttname"><a href="classAutomaticMortarGeneration.html#ac3445ab0b94ce0dc9c01a1234321ebaa">AutomaticMortarGeneration::_inactive_local_lm_elems</a></div><div class="ttdeci">std::unordered_set&lt; const Elem * &gt; _inactive_local_lm_elems</div><div class="ttdoc">List of inactive lagrange multiplier nodes (for elemental variables)</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00443">AutomaticMortarGeneration.h:443</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_ad0031e96df8f32e5c456a98532509404"><div class="ttname"><a href="classAutomaticMortarGeneration.html#ad0031e96df8f32e5c456a98532509404">AutomaticMortarGeneration::dim</a></div><div class="ttdeci">int dim() const</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00279">AutomaticMortarGeneration.h:279</a></div></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="MortarData_8C_source.html#l00160">MortarData::update()</a>.</p>

</div>
</div>
<a id="af55157330468f97bbf6905ffbb92fbea" name="af55157330468f97bbf6905ffbb92fbea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af55157330468f97bbf6905ffbb92fbea">&#9670;&#160;</a></span>computeInactiveLMNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AutomaticMortarGeneration::computeInactiveLMNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get list of secondary nodes that don't contribute to interaction with any primary element. </p>
<p >Used to enforce zero values on inactive DoFs of nodal variables. </p>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01577">1577</a> of file <a class="el" href="AutomaticMortarGeneration_8C_source.html">AutomaticMortarGeneration.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1578</span>{</div>
<div class="line"><span class="lineno"> 1579</span>  <span class="keywordflow">if</span> (!<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a689b49e6bae35fa2ba975b844c4ec82e">_correct_edge_dropping</a>)</div>
<div class="line"><span class="lineno"> 1580</span>  {</div>
<div class="line"><span class="lineno"> 1581</span>    <a class="code hl_function" href="classAutomaticMortarGeneration.html#ac36806c971038a5d13d2e5ea2c9e7f54">computeIncorrectEdgeDroppingInactiveLMNodes</a>();</div>
<div class="line"><span class="lineno"> 1582</span>    <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno"> 1583</span>  }</div>
<div class="line"><span class="lineno"> 1584</span> </div>
<div class="line"><span class="lineno"> 1585</span>  std::unordered_map&lt;processor_id_type, std::set&lt;dof_id_type&gt;&gt; proc_to_active_nodes_set;</div>
<div class="line"><span class="lineno"> 1586</span>  <span class="keyword">const</span> <span class="keyword">auto</span> my_pid = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.processor_id();</div>
<div class="line"><span class="lineno"> 1587</span> </div>
<div class="line"><span class="lineno"> 1588</span>  <span class="comment">// List of active nodes on local secondary elements</span></div>
<div class="line"><span class="lineno"> 1589</span>  std::unordered_set&lt;dof_id_type&gt; active_local_nodes;</div>
<div class="line"><span class="lineno"> 1590</span> </div>
<div class="line"><span class="lineno"> 1591</span>  <span class="comment">// Mark all active local nodes</span></div>
<div class="line"><span class="lineno"> 1592</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> msm_elem : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;active_local_element_ptr_range())</div>
<div class="line"><span class="lineno"> 1593</span>  {</div>
<div class="line"><span class="lineno"> 1594</span>    <span class="keyword">const</span> <a class="code hl_struct" href="structMortarSegmentInfo.html">MortarSegmentInfo</a> &amp; msinfo = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#abbd91d3cf8bef528976fe6f932622d2d">_msm_elem_to_info</a>.at(msm_elem);</div>
<div class="line"><span class="lineno"> 1595</span>    <span class="keyword">const</span> Elem * secondary_elem = msinfo.<a class="code hl_variable" href="structMortarSegmentInfo.html#afa8c2918a473f0dad90d5c68dad00eb4">secondary_elem</a>;</div>
<div class="line"><span class="lineno"> 1596</span> </div>
<div class="line"><span class="lineno"> 1597</span>    <span class="keywordflow">for</span> (<span class="keyword">auto</span> n : make_range(secondary_elem-&gt;n_nodes()))</div>
<div class="line"><span class="lineno"> 1598</span>      active_local_nodes.insert(secondary_elem-&gt;node_id(n));</div>
<div class="line"><span class="lineno"> 1599</span>  }</div>
<div class="line"><span class="lineno"> 1600</span> </div>
<div class="line"><span class="lineno"> 1601</span>  <span class="comment">// Assemble list of procs that nodes contribute to</span></div>
<div class="line"><span class="lineno"> 1602</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; pr : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a969d4ab038fc8d447e966cd1e1600091">_primary_secondary_subdomain_id_pairs</a>)</div>
<div class="line"><span class="lineno"> 1603</span>  {</div>
<div class="line"><span class="lineno"> 1604</span>    <span class="keyword">const</span> <span class="keyword">auto</span> secondary_subd_id = pr.second;</div>
<div class="line"><span class="lineno"> 1605</span> </div>
<div class="line"><span class="lineno"> 1606</span>    <span class="comment">// Loop through all elements not on my processor</span></div>
<div class="line"><span class="lineno"> 1607</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> el : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.active_subdomain_elements_ptr_range(secondary_subd_id))</div>
<div class="line"><span class="lineno"> 1608</span>    {</div>
<div class="line"><span class="lineno"> 1609</span>      <span class="comment">// Get processor_id</span></div>
<div class="line"><span class="lineno"> 1610</span>      <span class="keyword">const</span> <span class="keyword">auto</span> pid = el-&gt;processor_id();</div>
<div class="line"><span class="lineno"> 1611</span> </div>
<div class="line"><span class="lineno"> 1612</span>      <span class="comment">// If element is in my subdomain, skip</span></div>
<div class="line"><span class="lineno"> 1613</span>      <span class="keywordflow">if</span> (pid == my_pid)</div>
<div class="line"><span class="lineno"> 1614</span>        <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno"> 1615</span> </div>
<div class="line"><span class="lineno"> 1616</span>      <span class="comment">// If element on proc pid shares any of my active nodes, mark to send</span></div>
<div class="line"><span class="lineno"> 1617</span>      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> n : make_range(el-&gt;n_nodes()))</div>
<div class="line"><span class="lineno"> 1618</span>      {</div>
<div class="line"><span class="lineno"> 1619</span>        <span class="keyword">const</span> <span class="keyword">auto</span> node_id = el-&gt;node_id(n);</div>
<div class="line"><span class="lineno"> 1620</span>        <span class="keywordflow">if</span> (active_local_nodes.find(node_id) != active_local_nodes.end())</div>
<div class="line"><span class="lineno"> 1621</span>          proc_to_active_nodes_set[pid].insert(node_id);</div>
<div class="line"><span class="lineno"> 1622</span>      }</div>
<div class="line"><span class="lineno"> 1623</span>    }</div>
<div class="line"><span class="lineno"> 1624</span>  }</div>
<div class="line"><span class="lineno"> 1625</span> </div>
<div class="line"><span class="lineno"> 1626</span>  <span class="comment">// Send list of active nodes</span></div>
<div class="line"><span class="lineno"> 1627</span>  {</div>
<div class="line"><span class="lineno"> 1628</span>    <span class="comment">// Pack set into vector for sending (push_parallel_vector_data doesn&#39;t like sets)</span></div>
<div class="line"><span class="lineno"> 1629</span>    std::unordered_map&lt;processor_id_type, std::vector&lt;dof_id_type&gt;&gt; proc_to_active_nodes_vector;</div>
<div class="line"><span class="lineno"> 1630</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; proc_set : proc_to_active_nodes_set)</div>
<div class="line"><span class="lineno"> 1631</span>    {</div>
<div class="line"><span class="lineno"> 1632</span>      proc_to_active_nodes_vector[proc_set.first].reserve(proc_to_active_nodes_set.size());</div>
<div class="line"><span class="lineno"> 1633</span>      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> node_id : proc_set.second)</div>
<div class="line"><span class="lineno"> 1634</span>        proc_to_active_nodes_vector[proc_set.first].push_back(node_id);</div>
<div class="line"><span class="lineno"> 1635</span>    }</div>
<div class="line"><span class="lineno"> 1636</span> </div>
<div class="line"><span class="lineno"> 1637</span>    <span class="comment">// First push data</span></div>
<div class="line"><span class="lineno"> 1638</span>    <span class="keyword">auto</span> action_functor = [<span class="keyword">this</span>, &amp;active_local_nodes](<span class="keyword">const</span> processor_id_type pid,</div>
<div class="line"><span class="lineno"> 1639</span>                                                      <span class="keyword">const</span> std::vector&lt;dof_id_type&gt; &amp; sent_data)</div>
<div class="line"><span class="lineno"> 1640</span>    {</div>
<div class="line"><span class="lineno"> 1641</span>      <span class="keywordflow">if</span> (pid == <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.processor_id())</div>
<div class="line"><span class="lineno"> 1642</span>        <a class="code hl_function" href="MooseError_8h.html#aa959168eed29caa7aaa85ffc1319a9ad">mooseError</a>(<span class="stringliteral">&quot;Should not be communicating with self.&quot;</span>);</div>
<div class="line"><span class="lineno"> 1643</span>      active_local_nodes.insert(sent_data.begin(), sent_data.end());</div>
<div class="line"><span class="lineno"> 1644</span>    };</div>
<div class="line"><span class="lineno"> 1645</span>    TIMPI::push_parallel_vector_data(<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.comm(), proc_to_active_nodes_vector, action_functor);</div>
<div class="line"><span class="lineno"> 1646</span>  }</div>
<div class="line"><span class="lineno"> 1647</span> </div>
<div class="line"><span class="lineno"> 1648</span>  <span class="comment">// Every proc has correct list of active local nodes, now take complement (list of inactive nodes)</span></div>
<div class="line"><span class="lineno"> 1649</span>  <span class="comment">// and store to use later to zero LM DoFs on inactive nodes</span></div>
<div class="line"><span class="lineno"> 1650</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a3c757e0025c7dbfb78485e79067fb138">_inactive_local_lm_nodes</a>.clear();</div>
<div class="line"><span class="lineno"> 1651</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; pr : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a969d4ab038fc8d447e966cd1e1600091">_primary_secondary_subdomain_id_pairs</a>)</div>
<div class="line"><span class="lineno"> 1652</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> el : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.active_local_subdomain_elements_ptr_range(</div>
<div class="line"><span class="lineno"> 1653</span>             <span class="comment">/*secondary_subd_id*/</span> pr.second))</div>
<div class="line"><span class="lineno"> 1654</span>      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> n : make_range(el-&gt;n_nodes()))</div>
<div class="line"><span class="lineno"> 1655</span>        <span class="keywordflow">if</span> (active_local_nodes.find(el-&gt;node_id(n)) == active_local_nodes.end())</div>
<div class="line"><span class="lineno"> 1656</span>          <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a3c757e0025c7dbfb78485e79067fb138">_inactive_local_lm_nodes</a>.insert(el-&gt;node_ptr(n));</div>
<div class="line"><span class="lineno"> 1657</span>}</div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a3c757e0025c7dbfb78485e79067fb138"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a3c757e0025c7dbfb78485e79067fb138">AutomaticMortarGeneration::_inactive_local_lm_nodes</a></div><div class="ttdeci">std::unordered_set&lt; const Node * &gt; _inactive_local_lm_nodes</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00440">AutomaticMortarGeneration.h:440</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_ac36806c971038a5d13d2e5ea2c9e7f54"><div class="ttname"><a href="classAutomaticMortarGeneration.html#ac36806c971038a5d13d2e5ea2c9e7f54">AutomaticMortarGeneration::computeIncorrectEdgeDroppingInactiveLMNodes</a></div><div class="ttdeci">void computeIncorrectEdgeDroppingInactiveLMNodes()</div><div class="ttdoc">Computes inactive secondary nodes when incorrect edge dropping behavior is enabled (any node touching...</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8C_source.html#l01485">AutomaticMortarGeneration.C:1485</a></div></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="MortarData_8C_source.html#l00160">MortarData::update()</a>.</p>

</div>
</div>
<a id="ac36806c971038a5d13d2e5ea2c9e7f54" name="ac36806c971038a5d13d2e5ea2c9e7f54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac36806c971038a5d13d2e5ea2c9e7f54">&#9670;&#160;</a></span>computeIncorrectEdgeDroppingInactiveLMNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AutomaticMortarGeneration::computeIncorrectEdgeDroppingInactiveLMNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes inactive secondary nodes when incorrect edge dropping behavior is enabled (any node touching a partially or fully dropped element is dropped) </p>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01485">1485</a> of file <a class="el" href="AutomaticMortarGeneration_8C_source.html">AutomaticMortarGeneration.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1486</span>{</div>
<div class="line"><span class="lineno"> 1487</span>  <span class="comment">// Note that in 3D our trick to check whether an element has edge dropping needs loose tolerances</span></div>
<div class="line"><span class="lineno"> 1488</span>  <span class="comment">// since the mortar segments are on the linearized element and comparing the volume of the</span></div>
<div class="line"><span class="lineno"> 1489</span>  <span class="comment">// linearized element does not have the same volume as the warped element</span></div>
<div class="line"><span class="lineno"> 1490</span>  <span class="keyword">const</span> Real tol = (<a class="code hl_function" href="classAutomaticMortarGeneration.html#ad0031e96df8f32e5c456a98532509404">dim</a>() == 3) ? 0.1 : TOLERANCE;</div>
<div class="line"><span class="lineno"> 1491</span> </div>
<div class="line"><span class="lineno"> 1492</span>  std::unordered_map&lt;processor_id_type, std::set&lt;dof_id_type&gt;&gt; proc_to_inactive_nodes_set;</div>
<div class="line"><span class="lineno"> 1493</span>  <span class="keyword">const</span> <span class="keyword">auto</span> my_pid = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.processor_id();</div>
<div class="line"><span class="lineno"> 1494</span> </div>
<div class="line"><span class="lineno"> 1495</span>  <span class="comment">// List of inactive nodes on local secondary elements</span></div>
<div class="line"><span class="lineno"> 1496</span>  std::unordered_set&lt;dof_id_type&gt; inactive_node_ids;</div>
<div class="line"><span class="lineno"> 1497</span> </div>
<div class="line"><span class="lineno"> 1498</span>  std::unordered_map&lt;const Elem *, Real&gt; active_volume{};</div>
<div class="line"><span class="lineno"> 1499</span> </div>
<div class="line"><span class="lineno"> 1500</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; pr : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a969d4ab038fc8d447e966cd1e1600091">_primary_secondary_subdomain_id_pairs</a>)</div>
<div class="line"><span class="lineno"> 1501</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> el : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.active_subdomain_elements_ptr_range(pr.second))</div>
<div class="line"><span class="lineno"> 1502</span>      active_volume[el] = 0.;</div>
<div class="line"><span class="lineno"> 1503</span> </div>
<div class="line"><span class="lineno"> 1504</span>  <span class="comment">// Compute fraction of elements with corresponding primary elements</span></div>
<div class="line"><span class="lineno"> 1505</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> msm_elem : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;active_local_element_ptr_range())</div>
<div class="line"><span class="lineno"> 1506</span>  {</div>
<div class="line"><span class="lineno"> 1507</span>    <span class="keyword">const</span> <a class="code hl_struct" href="structMortarSegmentInfo.html">MortarSegmentInfo</a> &amp; msinfo = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#abbd91d3cf8bef528976fe6f932622d2d">_msm_elem_to_info</a>.at(msm_elem);</div>
<div class="line"><span class="lineno"> 1508</span>    <span class="keyword">const</span> Elem * secondary_elem = msinfo.<a class="code hl_variable" href="structMortarSegmentInfo.html#afa8c2918a473f0dad90d5c68dad00eb4">secondary_elem</a>;</div>
<div class="line"><span class="lineno"> 1509</span> </div>
<div class="line"><span class="lineno"> 1510</span>    active_volume[secondary_elem] += msm_elem-&gt;volume();</div>
<div class="line"><span class="lineno"> 1511</span>  }</div>
<div class="line"><span class="lineno"> 1512</span> </div>
<div class="line"><span class="lineno"> 1513</span>  <span class="comment">// Mark all inactive local nodes</span></div>
<div class="line"><span class="lineno"> 1514</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; pr : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a969d4ab038fc8d447e966cd1e1600091">_primary_secondary_subdomain_id_pairs</a>)</div>
<div class="line"><span class="lineno"> 1515</span>    <span class="comment">// Loop through all elements on my processor</span></div>
<div class="line"><span class="lineno"> 1516</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> el : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.active_local_subdomain_elements_ptr_range(pr.second))</div>
<div class="line"><span class="lineno"> 1517</span>      <span class="comment">// If elem fully or partially dropped</span></div>
<div class="line"><span class="lineno"> 1518</span>      <span class="keywordflow">if</span> (std::abs(active_volume[el] / el-&gt;volume() - 1.0) &gt; tol)</div>
<div class="line"><span class="lineno"> 1519</span>      {</div>
<div class="line"><span class="lineno"> 1520</span>        <span class="comment">// Add all nodes to list of inactive</span></div>
<div class="line"><span class="lineno"> 1521</span>        <span class="keywordflow">for</span> (<span class="keyword">auto</span> n : make_range(el-&gt;n_nodes()))</div>
<div class="line"><span class="lineno"> 1522</span>          inactive_node_ids.insert(el-&gt;node_id(n));</div>
<div class="line"><span class="lineno"> 1523</span>      }</div>
<div class="line"><span class="lineno"> 1524</span> </div>
<div class="line"><span class="lineno"> 1525</span>  <span class="comment">// Assemble list of procs that nodes contribute to</span></div>
<div class="line"><span class="lineno"> 1526</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; pr : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a969d4ab038fc8d447e966cd1e1600091">_primary_secondary_subdomain_id_pairs</a>)</div>
<div class="line"><span class="lineno"> 1527</span>  {</div>
<div class="line"><span class="lineno"> 1528</span>    <span class="keyword">const</span> <span class="keyword">auto</span> secondary_subd_id = pr.second;</div>
<div class="line"><span class="lineno"> 1529</span> </div>
<div class="line"><span class="lineno"> 1530</span>    <span class="comment">// Loop through all elements not on my processor</span></div>
<div class="line"><span class="lineno"> 1531</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> el : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.active_subdomain_elements_ptr_range(secondary_subd_id))</div>
<div class="line"><span class="lineno"> 1532</span>    {</div>
<div class="line"><span class="lineno"> 1533</span>      <span class="comment">// Get processor_id</span></div>
<div class="line"><span class="lineno"> 1534</span>      <span class="keyword">const</span> <span class="keyword">auto</span> pid = el-&gt;processor_id();</div>
<div class="line"><span class="lineno"> 1535</span> </div>
<div class="line"><span class="lineno"> 1536</span>      <span class="comment">// If element is in my subdomain, skip</span></div>
<div class="line"><span class="lineno"> 1537</span>      <span class="keywordflow">if</span> (pid == my_pid)</div>
<div class="line"><span class="lineno"> 1538</span>        <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno"> 1539</span> </div>
<div class="line"><span class="lineno"> 1540</span>      <span class="comment">// If element on proc pid shares any of my inactive nodes, mark to send</span></div>
<div class="line"><span class="lineno"> 1541</span>      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> n : make_range(el-&gt;n_nodes()))</div>
<div class="line"><span class="lineno"> 1542</span>      {</div>
<div class="line"><span class="lineno"> 1543</span>        <span class="keyword">const</span> <span class="keyword">auto</span> node_id = el-&gt;node_id(n);</div>
<div class="line"><span class="lineno"> 1544</span>        <span class="keywordflow">if</span> (inactive_node_ids.find(node_id) != inactive_node_ids.end())</div>
<div class="line"><span class="lineno"> 1545</span>          proc_to_inactive_nodes_set[pid].insert(node_id);</div>
<div class="line"><span class="lineno"> 1546</span>      }</div>
<div class="line"><span class="lineno"> 1547</span>    }</div>
<div class="line"><span class="lineno"> 1548</span>  }</div>
<div class="line"><span class="lineno"> 1549</span> </div>
<div class="line"><span class="lineno"> 1550</span>  <span class="comment">// Send list of inactive nodes</span></div>
<div class="line"><span class="lineno"> 1551</span>  {</div>
<div class="line"><span class="lineno"> 1552</span>    <span class="comment">// Pack set into vector for sending (push_parallel_vector_data doesn&#39;t like sets)</span></div>
<div class="line"><span class="lineno"> 1553</span>    std::unordered_map&lt;processor_id_type, std::vector&lt;dof_id_type&gt;&gt; proc_to_inactive_nodes_vector;</div>
<div class="line"><span class="lineno"> 1554</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; proc_set : proc_to_inactive_nodes_set)</div>
<div class="line"><span class="lineno"> 1555</span>      proc_to_inactive_nodes_vector[proc_set.first].insert(</div>
<div class="line"><span class="lineno"> 1556</span>          proc_to_inactive_nodes_vector[proc_set.first].end(),</div>
<div class="line"><span class="lineno"> 1557</span>          proc_set.second.begin(),</div>
<div class="line"><span class="lineno"> 1558</span>          proc_set.second.end());</div>
<div class="line"><span class="lineno"> 1559</span> </div>
<div class="line"><span class="lineno"> 1560</span>    <span class="comment">// First push data</span></div>
<div class="line"><span class="lineno"> 1561</span>    <span class="keyword">auto</span> action_functor = [<span class="keyword">this</span>, &amp;inactive_node_ids](<span class="keyword">const</span> processor_id_type pid,</div>
<div class="line"><span class="lineno"> 1562</span>                                                     <span class="keyword">const</span> std::vector&lt;dof_id_type&gt; &amp; sent_data)</div>
<div class="line"><span class="lineno"> 1563</span>    {</div>
<div class="line"><span class="lineno"> 1564</span>      <span class="keywordflow">if</span> (pid == <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.processor_id())</div>
<div class="line"><span class="lineno"> 1565</span>        <a class="code hl_function" href="MooseError_8h.html#aa959168eed29caa7aaa85ffc1319a9ad">mooseError</a>(<span class="stringliteral">&quot;Should not be communicating with self.&quot;</span>);</div>
<div class="line"><span class="lineno"> 1566</span>      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> pr : sent_data)</div>
<div class="line"><span class="lineno"> 1567</span>        inactive_node_ids.insert(pr);</div>
<div class="line"><span class="lineno"> 1568</span>    };</div>
<div class="line"><span class="lineno"> 1569</span>    TIMPI::push_parallel_vector_data(<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.comm(), proc_to_inactive_nodes_vector, action_functor);</div>
<div class="line"><span class="lineno"> 1570</span>  }</div>
<div class="line"><span class="lineno"> 1571</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a3c757e0025c7dbfb78485e79067fb138">_inactive_local_lm_nodes</a>.clear();</div>
<div class="line"><span class="lineno"> 1572</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> node_id : inactive_node_ids)</div>
<div class="line"><span class="lineno"> 1573</span>    <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a3c757e0025c7dbfb78485e79067fb138">_inactive_local_lm_nodes</a>.insert(<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.node_ptr(node_id));</div>
<div class="line"><span class="lineno"> 1574</span>}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01577">computeInactiveLMNodes()</a>.</p>

</div>
</div>
<a id="a2d9c7320cc6d9a995eaee8bd021397b7" name="a2d9c7320cc6d9a995eaee8bd021397b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d9c7320cc6d9a995eaee8bd021397b7">&#9670;&#160;</a></span>computeNodalGeometry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AutomaticMortarGeneration::computeNodalGeometry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes and stores the nodal normal/tangent vectors in a local data structure instead of using the ExplicitSystem/NumericVector approach. </p>
<p >This design was triggered by the way that the GhostingFunctor operates, but I think it is a better/more efficient way to do it anyway. </p>
<p >The _periodic flag tells us whether we want to inward vs outward facing normals</p>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01709">1709</a> of file <a class="el" href="AutomaticMortarGeneration_8C_source.html">AutomaticMortarGeneration.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1710</span>{</div>
<div class="line"><span class="lineno"> 1711</span>  <span class="comment">// The dimension according to Mesh::mesh_dimension().</span></div>
<div class="line"><span class="lineno"> 1712</span>  <span class="keyword">const</span> <span class="keyword">auto</span> <a class="code hl_function" href="classAutomaticMortarGeneration.html#ad0031e96df8f32e5c456a98532509404">dim</a> = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.mesh_dimension();</div>
<div class="line"><span class="lineno"> 1713</span> </div>
<div class="line"><span class="lineno"> 1714</span>  <span class="comment">// A nodal lower-dimensional nodal quadrature rule to be used on faces.</span></div>
<div class="line"><span class="lineno"> 1715</span>  QNodal qface(<a class="code hl_function" href="classAutomaticMortarGeneration.html#ad0031e96df8f32e5c456a98532509404">dim</a> - 1);</div>
<div class="line"><span class="lineno"> 1716</span> </div>
<div class="line"><span class="lineno"> 1717</span>  <span class="comment">// A map from the node id to the attached elemental normals/weights evaluated at the node. Th</span></div>
<div class="line"><span class="lineno"> 1718</span>  <span class="comment">// length of the vector will correspond to the number of elements attached to the node. If it is a</span></div>
<div class="line"><span class="lineno"> 1719</span>  <span class="comment">// vertex node, for a 1D mortar mesh, the vector length will be two. If it is an interior node,</span></div>
<div class="line"><span class="lineno"> 1720</span>  <span class="comment">// the vector will be length 1. The first member of the pair is that element&#39;s normal at the node.</span></div>
<div class="line"><span class="lineno"> 1721</span>  <span class="comment">// The second member is that element&#39;s JxW at the node</span></div>
<div class="line"><span class="lineno"> 1722</span>  std::map&lt;dof_id_type, std::vector&lt;std::pair&lt;Point, Real&gt;&gt;&gt; node_to_normals_map;</div>
<div class="line"><span class="lineno"> 1723</span> </div>
<div class="line"><span class="lineno"> 1725</span>  Real <a class="code hl_function" href="namespaceMathUtils.html#a53a9ea1c5518918a6de8689ccff698b0">sign</a> = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a509e5164f1c4cd0f981eaa901c37c632">_periodic</a> ? -1 : 1;</div>
<div class="line"><span class="lineno"> 1726</span> </div>
<div class="line"><span class="lineno"> 1727</span>  <span class="comment">// First loop over lower-dimensional secondary side elements and compute/save the outward normal</span></div>
<div class="line"><span class="lineno"> 1728</span>  <span class="comment">// for each one. We loop over all active elements currently, but this procedure could be</span></div>
<div class="line"><span class="lineno"> 1729</span>  <span class="comment">// parallelized as well.</span></div>
<div class="line"><span class="lineno"> 1730</span>  <span class="keywordflow">for</span> (MeshBase::const_element_iterator el = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.active_elements_begin(),</div>
<div class="line"><span class="lineno"> 1731</span>                                        end_el = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.active_elements_end();</div>
<div class="line"><span class="lineno"> 1732</span>       el != end_el;</div>
<div class="line"><span class="lineno"> 1733</span>       ++el)</div>
<div class="line"><span class="lineno"> 1734</span>  {</div>
<div class="line"><span class="lineno"> 1735</span>    <span class="keyword">const</span> Elem * secondary_elem = *el;</div>
<div class="line"><span class="lineno"> 1736</span> </div>
<div class="line"><span class="lineno"> 1737</span>    <span class="comment">// If this is not one of the lower-dimensional secondary side elements, go on to the next one.</span></div>
<div class="line"><span class="lineno"> 1738</span>    <span class="keywordflow">if</span> (!<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a59c6fd297125023195e7bfb3714846c5">_secondary_boundary_subdomain_ids</a>.count(secondary_elem-&gt;subdomain_id()))</div>
<div class="line"><span class="lineno"> 1739</span>      <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno"> 1740</span> </div>
<div class="line"><span class="lineno"> 1741</span>    <span class="comment">// We will create an FE object and attach the nodal quadrature rule such that we can get out the</span></div>
<div class="line"><span class="lineno"> 1742</span>    <span class="comment">// normals at the element nodes</span></div>
<div class="line"><span class="lineno"> 1743</span>    FEType nnx_fe_type(secondary_elem-&gt;default_order(), LAGRANGE);</div>
<div class="line"><span class="lineno"> 1744</span>    std::unique_ptr&lt;FEBase&gt; nnx_fe_face(FEBase::build(<a class="code hl_function" href="classAutomaticMortarGeneration.html#ad0031e96df8f32e5c456a98532509404">dim</a>, nnx_fe_type));</div>
<div class="line"><span class="lineno"> 1745</span>    nnx_fe_face-&gt;attach_quadrature_rule(&amp;qface);</div>
<div class="line"><span class="lineno"> 1746</span>    <span class="keyword">const</span> std::vector&lt;Point&gt; &amp; face_normals = nnx_fe_face-&gt;get_normals();</div>
<div class="line"><span class="lineno"> 1747</span> </div>
<div class="line"><span class="lineno"> 1748</span>    <span class="keyword">const</span> <span class="keyword">auto</span> &amp; JxW = nnx_fe_face-&gt;get_JxW();</div>
<div class="line"><span class="lineno"> 1749</span> </div>
<div class="line"><span class="lineno"> 1750</span>    <span class="comment">// Which side of the parent are we? We need to know this to know</span></div>
<div class="line"><span class="lineno"> 1751</span>    <span class="comment">// which side to reinit.</span></div>
<div class="line"><span class="lineno"> 1752</span>    <span class="keyword">const</span> Elem * interior_parent = secondary_elem-&gt;interior_parent();</div>
<div class="line"><span class="lineno"> 1753</span>    mooseAssert(interior_parent,</div>
<div class="line"><span class="lineno"> 1754</span>                <span class="stringliteral">&quot;No interior parent exists for element &quot;</span></div>
<div class="line"><span class="lineno"> 1755</span>                    &lt;&lt; secondary_elem-&gt;id()</div>
<div class="line"><span class="lineno"> 1756</span>                    &lt;&lt; <span class="stringliteral">&quot;. There may be a problem with your sideset set-up.&quot;</span>);</div>
<div class="line"><span class="lineno"> 1757</span> </div>
<div class="line"><span class="lineno"> 1758</span>    <span class="comment">// Map to get lower dimensional element from interior parent on secondary surface</span></div>
<div class="line"><span class="lineno"> 1759</span>    <span class="comment">// This map can be used to provide a handle to methods in this class that need to</span></div>
<div class="line"><span class="lineno"> 1760</span>    <span class="comment">// operate on lower dimensional elements.</span></div>
<div class="line"><span class="lineno"> 1761</span>    <a class="code hl_variable" href="classAutomaticMortarGeneration.html#acb676f79ae207404fb5d224ac768df42">_secondary_element_to_secondary_lowerd_element</a>.emplace(interior_parent-&gt;id(), secondary_elem);</div>
<div class="line"><span class="lineno"> 1762</span> </div>
<div class="line"><span class="lineno"> 1763</span>    <span class="comment">// Look up which side of the interior parent secondary_elem is.</span></div>
<div class="line"><span class="lineno"> 1764</span>    <span class="keyword">auto</span> s = interior_parent-&gt;which_side_am_i(secondary_elem);</div>
<div class="line"><span class="lineno"> 1765</span> </div>
<div class="line"><span class="lineno"> 1766</span>    <span class="comment">// Reinit the face FE object on side s.</span></div>
<div class="line"><span class="lineno"> 1767</span>    nnx_fe_face-&gt;reinit(interior_parent, s);</div>
<div class="line"><span class="lineno"> 1768</span> </div>
<div class="line"><span class="lineno"> 1769</span>    <span class="keywordflow">for</span> (MooseIndex(secondary_elem-&gt;n_nodes()) n = 0; n &lt; secondary_elem-&gt;n_nodes(); ++n)</div>
<div class="line"><span class="lineno"> 1770</span>    {</div>
<div class="line"><span class="lineno"> 1771</span>      <span class="keyword">auto</span> &amp; normals_and_weights_vec = node_to_normals_map[secondary_elem-&gt;node_id(n)];</div>
<div class="line"><span class="lineno"> 1772</span>      normals_and_weights_vec.push_back(std::make_pair(sign * face_normals[n], JxW[n]));</div>
<div class="line"><span class="lineno"> 1773</span>    }</div>
<div class="line"><span class="lineno"> 1774</span>  }</div>
<div class="line"><span class="lineno"> 1775</span> </div>
<div class="line"><span class="lineno"> 1776</span>  <span class="comment">// Note that contrary to the Bin Yang dissertation, we are not weighting by the face element</span></div>
<div class="line"><span class="lineno"> 1777</span>  <span class="comment">// lengths/volumes. It&#39;s not clear to me that this type of weighting is a good algorithm for cases</span></div>
<div class="line"><span class="lineno"> 1778</span>  <span class="comment">// where the face can be curved</span></div>
<div class="line"><span class="lineno"> 1779</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; pr : node_to_normals_map)</div>
<div class="line"><span class="lineno"> 1780</span>  {</div>
<div class="line"><span class="lineno"> 1781</span>    <span class="comment">// Compute normal vector</span></div>
<div class="line"><span class="lineno"> 1782</span>    <span class="keyword">const</span> <span class="keyword">auto</span> &amp; node_id = pr.first;</div>
<div class="line"><span class="lineno"> 1783</span>    <span class="keyword">const</span> <span class="keyword">auto</span> &amp; normals_and_weights_vec = pr.second;</div>
<div class="line"><span class="lineno"> 1784</span> </div>
<div class="line"><span class="lineno"> 1785</span>    Point nodal_normal;</div>
<div class="line"><span class="lineno"> 1786</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; norm_and_weight : normals_and_weights_vec)</div>
<div class="line"><span class="lineno"> 1787</span>      nodal_normal += norm_and_weight.first * norm_and_weight.second;</div>
<div class="line"><span class="lineno"> 1788</span>    nodal_normal = nodal_normal.unit();</div>
<div class="line"><span class="lineno"> 1789</span> </div>
<div class="line"><span class="lineno"> 1790</span>    <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a06fb539aea2e63f3b48a6e1d41a2f568">_secondary_node_to_nodal_normal</a>[<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.node_ptr(node_id)] = nodal_normal;</div>
<div class="line"><span class="lineno"> 1791</span> </div>
<div class="line"><span class="lineno"> 1792</span>    Point nodal_tangent_one;</div>
<div class="line"><span class="lineno"> 1793</span>    Point nodal_tangent_two;</div>
<div class="line"><span class="lineno"> 1794</span>    <a class="code hl_function" href="classAutomaticMortarGeneration.html#a71119b033756571f4345f912300b182d">householderOrthogolization</a>(nodal_normal, nodal_tangent_one, nodal_tangent_two);</div>
<div class="line"><span class="lineno"> 1795</span> </div>
<div class="line"><span class="lineno"> 1796</span>    <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a8120c89f18fdff39621fa512087a2da3">_secondary_node_to_hh_nodal_tangents</a>[<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.node_ptr(node_id)][0] = nodal_tangent_one;</div>
<div class="line"><span class="lineno"> 1797</span>    <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a8120c89f18fdff39621fa512087a2da3">_secondary_node_to_hh_nodal_tangents</a>[<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.node_ptr(node_id)][1] = nodal_tangent_two;</div>
<div class="line"><span class="lineno"> 1798</span>  }</div>
<div class="line"><span class="lineno"> 1799</span>}</div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a71119b033756571f4345f912300b182d"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a71119b033756571f4345f912300b182d">AutomaticMortarGeneration::householderOrthogolization</a></div><div class="ttdeci">void householderOrthogolization(const Point &amp;normal, Point &amp;tangent_one, Point &amp;tangent_two) const</div><div class="ttdoc">Householder orthogonalization procedure to obtain proper basis for tangent and binormal vectors.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8C_source.html#l01802">AutomaticMortarGeneration.C:1802</a></div></div>
<div class="ttc" id="anamespaceMathUtils_html_a53a9ea1c5518918a6de8689ccff698b0"><div class="ttname"><a href="namespaceMathUtils.html#a53a9ea1c5518918a6de8689ccff698b0">MathUtils::sign</a></div><div class="ttdeci">T sign(T x)</div><div class="ttdef"><b>Definition:</b> <a href="MathUtils_8h_source.html#l00083">MathUtils.h:83</a></div></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="MortarData_8C_source.html#l00160">MortarData::update()</a>.</p>

</div>
</div>
<a id="ad0031e96df8f32e5c456a98532509404" name="ad0031e96df8f32e5c456a98532509404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0031e96df8f32e5c456a98532509404">&#9670;&#160;</a></span>dim()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int AutomaticMortarGeneration::dim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00279">279</a> of file <a class="el" href="AutomaticMortarGeneration_8h_source.html">AutomaticMortarGeneration.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  279</span>{ <span class="keywordflow">return</span> <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.mesh_dimension(); }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01661">computeInactiveLMElems()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01485">computeIncorrectEdgeDroppingInactiveLMNodes()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01709">computeNodalGeometry()</a>, <a class="el" href="MortarUtils_8h_source.html#l00069">Moose::Mortar::loopOverMortarSegments()</a>, and <a class="el" href="MortarData_8C_source.html#l00160">MortarData::update()</a>.</p>

</div>
</div>
<a id="aa9b61427a0ee7b00dc386406f23f2ccd" name="aa9b61427a0ee7b00dc386406f23f2ccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9b61427a0ee7b00dc386406f23f2ccd">&#9670;&#160;</a></span>getInactiveLMElems()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::unordered_set&lt; const Elem * &gt; &amp; AutomaticMortarGeneration::getInactiveLMElems </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The list of secondary elems on which mortar constraint is not active </dd></dl>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00292">292</a> of file <a class="el" href="AutomaticMortarGeneration_8h_source.html">AutomaticMortarGeneration.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  293</span>  {</div>
<div class="line"><span class="lineno">  294</span>    <span class="keywordflow">return</span> <a class="code hl_variable" href="classAutomaticMortarGeneration.html#ac3445ab0b94ce0dc9c01a1234321ebaa">_inactive_local_lm_elems</a>;</div>
<div class="line"><span class="lineno">  295</span>  }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="ComputeMortarFunctor_8C_source.html#l00054">ComputeMortarFunctor::operator()()</a>.</p>

</div>
</div>
<a id="af638f80e4d4fe094ba084a932f465d3d" name="af638f80e4d4fe094ba084a932f465d3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af638f80e4d4fe094ba084a932f465d3d">&#9670;&#160;</a></span>getInactiveLMNodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::unordered_set&lt; const Node * &gt; &amp; AutomaticMortarGeneration::getInactiveLMNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The set of nodes on which mortar constraints are not active </dd></dl>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00284">284</a> of file <a class="el" href="AutomaticMortarGeneration_8h_source.html">AutomaticMortarGeneration.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  285</span>  {</div>
<div class="line"><span class="lineno">  286</span>    <span class="keywordflow">return</span> <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a3c757e0025c7dbfb78485e79067fb138">_inactive_local_lm_nodes</a>;</div>
<div class="line"><span class="lineno">  287</span>  }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="ComputeMortarFunctor_8C_source.html#l00054">ComputeMortarFunctor::operator()()</a>.</p>

</div>
</div>
<a id="ae200397e9841242f1bc2438b2156f253" name="ae200397e9841242f1bc2438b2156f253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae200397e9841242f1bc2438b2156f253">&#9670;&#160;</a></span>getNodalNormals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Point &gt; AutomaticMortarGeneration::getNodalNormals </td>
          <td>(</td>
          <td class="paramtype">const Elem &amp;&#160;</td>
          <td class="paramname"><em>secondary_elem</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The nodal normals associated with the provided <code>secondary_elem</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00322">322</a> of file <a class="el" href="AutomaticMortarGeneration_8C_source.html">AutomaticMortarGeneration.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  323</span>{</div>
<div class="line"><span class="lineno">  324</span>  std::vector&lt;Point&gt; nodal_normals(secondary_elem.n_nodes());</div>
<div class="line"><span class="lineno">  325</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> n : make_range(secondary_elem.n_nodes()))</div>
<div class="line"><span class="lineno">  326</span>    nodal_normals[n] = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a06fb539aea2e63f3b48a6e1d41a2f568">_secondary_node_to_nodal_normal</a>.at(secondary_elem.node_ptr(n));</div>
<div class="line"><span class="lineno">  327</span> </div>
<div class="line"><span class="lineno">  328</span>  <span class="keywordflow">return</span> nodal_normals;</div>
<div class="line"><span class="lineno">  329</span>}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00930">buildMortarSegmentMesh3d()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00404">getNormals()</a>, and <a class="el" href="MortarConsumerInterface_8C_source.html#l00161">MortarConsumerInterface::setNormals()</a>.</p>

</div>
</div>
<a id="ac9594ceb9068d6cf33b6e1ca2f5951fe" name="ac9594ceb9068d6cf33b6e1ca2f5951fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9594ceb9068d6cf33b6e1ca2f5951fe">&#9670;&#160;</a></span>getNodalTangents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; <a class="el" href="classMooseUtils_1_1SemidynamicVector.html">MooseUtils::SemidynamicVector</a>&lt; Point, 9 &gt;, 2 &gt; AutomaticMortarGeneration::getNodalTangents </td>
          <td>(</td>
          <td class="paramtype">const Elem &amp;&#160;</td>
          <td class="paramname"><em>secondary_elem</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the two nodal tangents, which are built on-the-fly. </p>
<dl class="section return"><dt>Returns</dt><dd>The nodal tangents associated with the provided <code>secondary_elem</code> </dd></dl>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00375">375</a> of file <a class="el" href="AutomaticMortarGeneration_8C_source.html">AutomaticMortarGeneration.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  376</span>{</div>
<div class="line"><span class="lineno">  377</span>  <span class="comment">// MetaPhysicL will check if we ran out of allocated space.</span></div>
<div class="line"><span class="lineno">  378</span>  <a class="code hl_class" href="classMooseUtils_1_1SemidynamicVector.html">MooseUtils::SemidynamicVector&lt;Point, 9&gt;</a> nodal_tangents_one(0);</div>
<div class="line"><span class="lineno">  379</span>  <a class="code hl_class" href="classMooseUtils_1_1SemidynamicVector.html">MooseUtils::SemidynamicVector&lt;Point, 9&gt;</a> nodal_tangents_two(0);</div>
<div class="line"><span class="lineno">  380</span> </div>
<div class="line"><span class="lineno">  381</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> n : make_range(secondary_elem.n_nodes()))</div>
<div class="line"><span class="lineno">  382</span>  {</div>
<div class="line"><span class="lineno">  383</span>    <span class="keyword">const</span> <span class="keyword">auto</span> &amp; tangent_vectors =</div>
<div class="line"><span class="lineno">  384</span>        libmesh_map_find(<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a8120c89f18fdff39621fa512087a2da3">_secondary_node_to_hh_nodal_tangents</a>, secondary_elem.node_ptr(n));</div>
<div class="line"><span class="lineno">  385</span>    nodal_tangents_one.push_back(tangent_vectors[0]);</div>
<div class="line"><span class="lineno">  386</span>    nodal_tangents_two.push_back(tangent_vectors[1]);</div>
<div class="line"><span class="lineno">  387</span>  }</div>
<div class="line"><span class="lineno">  388</span> </div>
<div class="line"><span class="lineno">  389</span>  <span class="keywordflow">return</span> {{nodal_tangents_one, nodal_tangents_two}};</div>
<div class="line"><span class="lineno">  390</span>}</div>
<div class="ttc" id="aclassMooseUtils_1_1SemidynamicVector_html"><div class="ttname"><a href="classMooseUtils_1_1SemidynamicVector.html">MooseUtils::SemidynamicVector</a></div><div class="ttdoc">Utility class template for a semidynamic vector with a maximum size N and a chosen dynamic size.</div><div class="ttdef"><b>Definition:</b> <a href="MooseUtils_8h_source.html#l01084">MooseUtils.h:1085</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a71eb5cecb4437a9a0edfe8d5ce38007e" name="a71eb5cecb4437a9a0edfe8d5ce38007e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71eb5cecb4437a9a0edfe8d5ce38007e">&#9670;&#160;</a></span>getNormals() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Point &gt; AutomaticMortarGeneration::getNormals </td>
          <td>(</td>
          <td class="paramtype">const Elem &amp;&#160;</td>
          <td class="paramname"><em>secondary_elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Point &gt; &amp;&#160;</td>
          <td class="paramname"><em>xi1_pts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the normals at given reference points on a secondary element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">secondary_elem</td><td>The secondary element used to query for associated nodal normals </td></tr>
    <tr><td class="paramname">xi1_pts</td><td>The reference points on the secondary element to evaluate the normals at. The points should only be non-zero in the zeroth entry because right now our mortar mesh elements are always 1D </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The normals </dd></dl>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00404">404</a> of file <a class="el" href="AutomaticMortarGeneration_8C_source.html">AutomaticMortarGeneration.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  406</span>{</div>
<div class="line"><span class="lineno">  407</span>  <span class="keyword">const</span> <span class="keyword">auto</span> mortar_dim = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.mesh_dimension() - 1;</div>
<div class="line"><span class="lineno">  408</span>  <span class="keyword">const</span> <span class="keyword">auto</span> num_qps = xi1_pts.size();</div>
<div class="line"><span class="lineno">  409</span>  <span class="keyword">const</span> <span class="keyword">auto</span> nodal_normals = <a class="code hl_function" href="classAutomaticMortarGeneration.html#ae200397e9841242f1bc2438b2156f253">getNodalNormals</a>(secondary_elem);</div>
<div class="line"><span class="lineno">  410</span>  std::vector&lt;Point&gt; normals(num_qps);</div>
<div class="line"><span class="lineno">  411</span> </div>
<div class="line"><span class="lineno">  412</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> n : make_range(secondary_elem.n_nodes()))</div>
<div class="line"><span class="lineno">  413</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> qp : make_range(num_qps))</div>
<div class="line"><span class="lineno">  414</span>    {</div>
<div class="line"><span class="lineno">  415</span>      <span class="keyword">const</span> <span class="keyword">auto</span> phi =</div>
<div class="line"><span class="lineno">  416</span>          (mortar_dim == 1)</div>
<div class="line"><span class="lineno">  417</span>              ? <a class="code hl_function" href="namespaceMoose.html#a9ed3373b5072c07f1f010afb75ac20c9">Moose::fe_lagrange_1D_shape</a>(secondary_elem.default_order(), n, xi1_pts[qp](0))</div>
<div class="line"><span class="lineno">  418</span>              : <a class="code hl_function" href="namespaceMoose.html#a5fd6a33e7b0246beaf68f64045de310c">Moose::fe_lagrange_2D_shape</a>(secondary_elem.type(),</div>
<div class="line"><span class="lineno">  419</span>                                            secondary_elem.default_order(),</div>
<div class="line"><span class="lineno">  420</span>                                            n,</div>
<div class="line"><span class="lineno">  421</span>                                            <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code hl_class" href="classlibMesh_1_1TypeVector.html">TypeVector&lt;Real&gt;</a> &amp;<span class="keyword">&gt;</span>(xi1_pts[qp]));</div>
<div class="line"><span class="lineno">  422</span>      normals[qp] += phi * nodal_normals[n];</div>
<div class="line"><span class="lineno">  423</span>    }</div>
<div class="line"><span class="lineno">  424</span> </div>
<div class="line"><span class="lineno">  425</span>  <span class="keywordflow">if</span> (<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a509e5164f1c4cd0f981eaa901c37c632">_periodic</a>)</div>
<div class="line"><span class="lineno">  426</span>    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; normal : normals)</div>
<div class="line"><span class="lineno">  427</span>      normal *= -1;</div>
<div class="line"><span class="lineno">  428</span> </div>
<div class="line"><span class="lineno">  429</span>  <span class="keywordflow">return</span> normals;</div>
<div class="line"><span class="lineno">  430</span>}</div>
<div class="ttc" id="aclasslibMesh_1_1TypeVector_html"><div class="ttname"><a href="classlibMesh_1_1TypeVector.html">libMesh::TypeVector</a></div><div class="ttdef"><b>Definition:</b> <a href="MooseTypes_8h_source.html#l00143">MooseTypes.h:143</a></div></div>
<div class="ttc" id="anamespaceMoose_html_a5fd6a33e7b0246beaf68f64045de310c"><div class="ttname"><a href="namespaceMoose.html#a5fd6a33e7b0246beaf68f64045de310c">Moose::fe_lagrange_2D_shape</a></div><div class="ttdeci">T fe_lagrange_2D_shape(const ElemType type, const Order order, const unsigned int i, const VectorType&lt; T &gt; &amp;p)</div><div class="ttdef"><b>Definition:</b> <a href="MooseLagrangeHelpers_8h_source.html#l00171">MooseLagrangeHelpers.h:171</a></div></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00433">buildMortarSegmentMesh()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00393">getNormals()</a>, and <a class="el" href="MortarConsumerInterface_8C_source.html#l00161">MortarConsumerInterface::setNormals()</a>.</p>

</div>
</div>
<a id="a061f0533b7776fd51a0dcce78a8a71b9" name="a061f0533b7776fd51a0dcce78a8a71b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a061f0533b7776fd51a0dcce78a8a71b9">&#9670;&#160;</a></span>getNormals() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; Point &gt; AutomaticMortarGeneration::getNormals </td>
          <td>(</td>
          <td class="paramtype">const Elem &amp;&#160;</td>
          <td class="paramname"><em>secondary_elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>oned_xi1_pts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the normals at given reference points on a secondary element. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">secondary_elem</td><td>The secondary element used to query for associated nodal normals </td></tr>
    <tr><td class="paramname">1d_xi1_pts</td><td>The reference points on the secondary element to evaluate the normals at. The "points" are single reals corresponding to xi because right now our mortar mesh elements are always 1D </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The normals </dd></dl>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00393">393</a> of file <a class="el" href="AutomaticMortarGeneration_8C_source.html">AutomaticMortarGeneration.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  395</span>{</div>
<div class="line"><span class="lineno">  396</span>  std::vector&lt;Point&gt; xi1_pts(oned_xi1_pts.size());</div>
<div class="line"><span class="lineno">  397</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> qp : index_range(oned_xi1_pts))</div>
<div class="line"><span class="lineno">  398</span>    xi1_pts[qp] = oned_xi1_pts[qp];</div>
<div class="line"><span class="lineno">  399</span> </div>
<div class="line"><span class="lineno">  400</span>  <span class="keywordflow">return</span> <a class="code hl_function" href="classAutomaticMortarGeneration.html#a71eb5cecb4437a9a0edfe8d5ce38007e">getNormals</a>(secondary_elem, xi1_pts);</div>
<div class="line"><span class="lineno">  401</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab8f33d0072ce0d896b4f058980640488" name="ab8f33d0072ce0d896b4f058980640488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8f33d0072ce0d896b4f058980640488">&#9670;&#160;</a></span>getPrimaryIpToLowerElementMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; unsigned int, unsigned int &gt; AutomaticMortarGeneration::getPrimaryIpToLowerElementMap </td>
          <td>(</td>
          <td class="paramtype">const Elem &amp;&#160;</td>
          <td class="paramname"><em>primary_elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Elem &amp;&#160;</td>
          <td class="paramname"><em>primary_elem_ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Elem &amp;&#160;</td>
          <td class="paramname"><em>lower_secondary_elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute on-the-fly mapping from primary interior parent nodes to its corresponding lower dimensional nodes. </p>
<dl class="section return"><dt>Returns</dt><dd>The map from primary interior parent nodes to its corresponding lower dimensional nodes </dd></dl>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00358">358</a> of file <a class="el" href="AutomaticMortarGeneration_8C_source.html">AutomaticMortarGeneration.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  362</span>{</div>
<div class="line"><span class="lineno">  363</span>  std::map&lt;unsigned int, unsigned int&gt; primary_ip_i_to_lower_primary_i;</div>
<div class="line"><span class="lineno">  364</span> </div>
<div class="line"><span class="lineno">  365</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : make_range(lower_primary_elem.n_nodes()))</div>
<div class="line"><span class="lineno">  366</span>  {</div>
<div class="line"><span class="lineno">  367</span>    <span class="keyword">const</span> <span class="keyword">auto</span> &amp; nd = lower_primary_elem.node_ref(i);</div>
<div class="line"><span class="lineno">  368</span>    primary_ip_i_to_lower_primary_i[primary_elem.get_node_index(&amp;nd)] = i;</div>
<div class="line"><span class="lineno">  369</span>  }</div>
<div class="line"><span class="lineno">  370</span> </div>
<div class="line"><span class="lineno">  371</span>  <span class="keywordflow">return</span> primary_ip_i_to_lower_primary_i;</div>
<div class="line"><span class="lineno">  372</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9a41db0dea91a39a5ec0e1356b544d23" name="a9a41db0dea91a39a5ec0e1356b544d23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a41db0dea91a39a5ec0e1356b544d23">&#9670;&#160;</a></span>getSecondaryIpToLowerElementMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; unsigned int, unsigned int &gt; AutomaticMortarGeneration::getSecondaryIpToLowerElementMap </td>
          <td>(</td>
          <td class="paramtype">const Elem &amp;&#160;</td>
          <td class="paramname"><em>lower_secondary_elem</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute on-the-fly mapping from secondary interior parent nodes to lower dimensional nodes. </p>
<dl class="section return"><dt>Returns</dt><dd>The map from secondary interior parent nodes to lower dimensional nodes </dd></dl>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00342">342</a> of file <a class="el" href="AutomaticMortarGeneration_8C_source.html">AutomaticMortarGeneration.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  343</span>{</div>
<div class="line"><span class="lineno">  344</span>  std::map&lt;unsigned int, unsigned int&gt; secondary_ip_i_to_lower_secondary_i;</div>
<div class="line"><span class="lineno">  345</span>  <span class="keyword">const</span> Elem * <span class="keyword">const</span> secondary_ip = lower_secondary_elem.interior_parent();</div>
<div class="line"><span class="lineno">  346</span>  mooseAssert(secondary_ip, <span class="stringliteral">&quot;This should be non-null&quot;</span>);</div>
<div class="line"><span class="lineno">  347</span> </div>
<div class="line"><span class="lineno">  348</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : make_range(lower_secondary_elem.n_nodes()))</div>
<div class="line"><span class="lineno">  349</span>  {</div>
<div class="line"><span class="lineno">  350</span>    <span class="keyword">const</span> <span class="keyword">auto</span> &amp; nd = lower_secondary_elem.node_ref(i);</div>
<div class="line"><span class="lineno">  351</span>    secondary_ip_i_to_lower_secondary_i[secondary_ip-&gt;get_node_index(&amp;nd)] = i;</div>
<div class="line"><span class="lineno">  352</span>  }</div>
<div class="line"><span class="lineno">  353</span> </div>
<div class="line"><span class="lineno">  354</span>  <span class="keywordflow">return</span> secondary_ip_i_to_lower_secondary_i;</div>
<div class="line"><span class="lineno">  355</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a02fad9659b03bfd39cc92b30a4a988d6" name="a02fad9659b03bfd39cc92b30a4a988d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02fad9659b03bfd39cc92b30a4a988d6">&#9670;&#160;</a></span>getSecondaryLowerdElemFromSecondaryElem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Elem * AutomaticMortarGeneration::getSecondaryLowerdElemFromSecondaryElem </td>
          <td>(</td>
          <td class="paramtype">dof_id_type&#160;</td>
          <td class="paramname"><em>secondary_elem_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return lower dimensional secondary element given its interior parent. </p>
<p >Helpful outside the mortar generation to locate mortar-related quantities. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">secondary_elem_id</td><td>The secondary interior parent element id used to query for associated lower dimensional element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The corresponding lower dimensional secondary element </dd></dl>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00332">332</a> of file <a class="el" href="AutomaticMortarGeneration_8C_source.html">AutomaticMortarGeneration.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  334</span>{</div>
<div class="line"><span class="lineno">  335</span>  mooseAssert(<a class="code hl_variable" href="classAutomaticMortarGeneration.html#acb676f79ae207404fb5d224ac768df42">_secondary_element_to_secondary_lowerd_element</a>.count(secondary_elem_id),</div>
<div class="line"><span class="lineno">  336</span>              <span class="stringliteral">&quot;Map should locate secondary element&quot;</span>);</div>
<div class="line"><span class="lineno">  337</span> </div>
<div class="line"><span class="lineno">  338</span>  <span class="keywordflow">return</span> <a class="code hl_variable" href="classAutomaticMortarGeneration.html#acb676f79ae207404fb5d224ac768df42">_secondary_element_to_secondary_lowerd_element</a>.at(secondary_elem_id);</div>
<div class="line"><span class="lineno">  339</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a71119b033756571f4345f912300b182d" name="a71119b033756571f4345f912300b182d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71119b033756571f4345f912300b182d">&#9670;&#160;</a></span>householderOrthogolization()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AutomaticMortarGeneration::householderOrthogolization </td>
          <td>(</td>
          <td class="paramtype">const Point &amp;&#160;</td>
          <td class="paramname"><em>normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Point &amp;&#160;</td>
          <td class="paramname"><em>tangent_one</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Point &amp;&#160;</td>
          <td class="paramname"><em>tangent_two</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Householder orthogonalization procedure to obtain proper basis for tangent and binormal vectors. </p>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01802">1802</a> of file <a class="el" href="AutomaticMortarGeneration_8C_source.html">AutomaticMortarGeneration.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1805</span>{</div>
<div class="line"><span class="lineno"> 1806</span>  mooseAssert(<a class="code hl_function" href="namespaceMooseUtils.html#ad9865895ce5bb2c18722efa26d5c7693">MooseUtils::absoluteFuzzyEqual</a>(nodal_normal.norm(), 1),</div>
<div class="line"><span class="lineno"> 1807</span>              <span class="stringliteral">&quot;The input nodal normal should have unity norm&quot;</span>);</div>
<div class="line"><span class="lineno"> 1808</span> </div>
<div class="line"><span class="lineno"> 1809</span>  <span class="keyword">const</span> Real nx = nodal_normal(0);</div>
<div class="line"><span class="lineno"> 1810</span>  <span class="keyword">const</span> Real ny = nodal_normal(1);</div>
<div class="line"><span class="lineno"> 1811</span>  <span class="keyword">const</span> Real nz = nodal_normal(2);</div>
<div class="line"><span class="lineno"> 1812</span> </div>
<div class="line"><span class="lineno"> 1813</span>  <span class="comment">// See Lopes DS, Silva MT, Ambrosio JA. Tangent vectors to a 3-D surface normal: A geometric tool</span></div>
<div class="line"><span class="lineno"> 1814</span>  <span class="comment">// to find orthogonal vectors based on the Householder transformation. Computer-Aided Design. 2013</span></div>
<div class="line"><span class="lineno"> 1815</span>  <span class="comment">// Mar 1;45(3):683-94. We choose one definition of h_vector and deal with special case.</span></div>
<div class="line"><span class="lineno"> 1816</span>  <span class="keyword">const</span> Point h_vector(nx + 1.0, ny, nz);</div>
<div class="line"><span class="lineno"> 1817</span> </div>
<div class="line"><span class="lineno"> 1818</span>  <span class="comment">// Avoid singularity of the equations at the end of routine by providing the solution to</span></div>
<div class="line"><span class="lineno"> 1819</span>  <span class="comment">// (nx,ny,nz)=(-1,0,0) Normal/tangent fields can be visualized by outputting nodal geometry mesh</span></div>
<div class="line"><span class="lineno"> 1820</span>  <span class="comment">// on a spherical problem.</span></div>
<div class="line"><span class="lineno"> 1821</span>  <span class="keywordflow">if</span> (std::abs(h_vector(0)) &lt; TOLERANCE)</div>
<div class="line"><span class="lineno"> 1822</span>  {</div>
<div class="line"><span class="lineno"> 1823</span>    nodal_tangent_one(0) = 0;</div>
<div class="line"><span class="lineno"> 1824</span>    nodal_tangent_one(1) = 1;</div>
<div class="line"><span class="lineno"> 1825</span>    nodal_tangent_one(2) = 0;</div>
<div class="line"><span class="lineno"> 1826</span> </div>
<div class="line"><span class="lineno"> 1827</span>    nodal_tangent_two(0) = 0;</div>
<div class="line"><span class="lineno"> 1828</span>    nodal_tangent_two(1) = 0;</div>
<div class="line"><span class="lineno"> 1829</span>    nodal_tangent_two(2) = -1;</div>
<div class="line"><span class="lineno"> 1830</span> </div>
<div class="line"><span class="lineno"> 1831</span>    <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno"> 1832</span>  }</div>
<div class="line"><span class="lineno"> 1833</span> </div>
<div class="line"><span class="lineno"> 1834</span>  <span class="keyword">const</span> Real h = h_vector.norm();</div>
<div class="line"><span class="lineno"> 1835</span> </div>
<div class="line"><span class="lineno"> 1836</span>  nodal_tangent_one(0) = -2.0 * h_vector(0) * h_vector(1) / (h * h);</div>
<div class="line"><span class="lineno"> 1837</span>  nodal_tangent_one(1) = 1.0 - 2.0 * h_vector(1) * h_vector(1) / (h * h);</div>
<div class="line"><span class="lineno"> 1838</span>  nodal_tangent_one(2) = -2.0 * h_vector(1) * h_vector(2) / (h * h);</div>
<div class="line"><span class="lineno"> 1839</span> </div>
<div class="line"><span class="lineno"> 1840</span>  nodal_tangent_two(0) = -2.0 * h_vector(0) * h_vector(2) / (h * h);</div>
<div class="line"><span class="lineno"> 1841</span>  nodal_tangent_two(1) = -2.0 * h_vector(1) * h_vector(2) / (h * h);</div>
<div class="line"><span class="lineno"> 1842</span>  nodal_tangent_two(2) = 1.0 - 2.0 * h_vector(2) * h_vector(2) / (h * h);</div>
<div class="line"><span class="lineno"> 1843</span>}</div>
<div class="ttc" id="anamespaceMooseUtils_html_ad9865895ce5bb2c18722efa26d5c7693"><div class="ttname"><a href="namespaceMooseUtils.html#ad9865895ce5bb2c18722efa26d5c7693">MooseUtils::absoluteFuzzyEqual</a></div><div class="ttdeci">bool absoluteFuzzyEqual(const T &amp;var1, const T2 &amp;var2, const T3 &amp;tol=libMesh::TOLERANCE *libMesh::TOLERANCE)</div><div class="ttdoc">Function to check whether two variables are equal within an absolute tolerance.</div><div class="ttdef"><b>Definition:</b> <a href="MooseUtils_8h_source.html#l00337">MooseUtils.h:337</a></div></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01709">computeNodalGeometry()</a>.</p>

</div>
</div>
<a id="a6b3cdaa794d719da7e0c330ab9dac18e" name="a6b3cdaa794d719da7e0c330ab9dac18e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b3cdaa794d719da7e0c330ab9dac18e">&#9670;&#160;</a></span>incorrectEdgeDropping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AutomaticMortarGeneration::incorrectEdgeDropping </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00297">297</a> of file <a class="el" href="AutomaticMortarGeneration_8h_source.html">AutomaticMortarGeneration.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  297</span>{ <span class="keywordflow">return</span> !<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a689b49e6bae35fa2ba975b844c4ec82e">_correct_edge_dropping</a>; }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="ComputeMortarFunctor_8C_source.html#l00054">ComputeMortarFunctor::operator()()</a>.</p>

</div>
</div>
<a id="a7b7d494bc9dfe051e07cbbdeacc9a28d" name="a7b7d494bc9dfe051e07cbbdeacc9a28d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b7d494bc9dfe051e07cbbdeacc9a28d">&#9670;&#160;</a></span>initOutput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AutomaticMortarGeneration::initOutput </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>initialize mortar-mesh based output </p>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00247">247</a> of file <a class="el" href="AutomaticMortarGeneration_8C_source.html">AutomaticMortarGeneration.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  248</span>{</div>
<div class="line"><span class="lineno">  249</span>  <span class="keywordflow">if</span> (!<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a958de5b754ec676f463c50d2f16b5d0c">_debug</a>)</div>
<div class="line"><span class="lineno">  250</span>    <span class="keywordflow">return</span>;</div>
<div class="line"><span class="lineno">  251</span> </div>
<div class="line"><span class="lineno">  252</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a3a19330f38987cd9318f38d932c5a2ad">_output_params</a> = std::make_unique&lt;InputParameters&gt;(<a class="code hl_function" href="classMortarNodalGeometryOutput.html#a6bf8458c621e9dba746029f0f658eab1">MortarNodalGeometryOutput::validParams</a>());</div>
<div class="line"><span class="lineno">  253</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a3a19330f38987cd9318f38d932c5a2ad">_output_params</a>-&gt;set&lt;<a class="code hl_class" href="classAutomaticMortarGeneration.html">AutomaticMortarGeneration</a> *&gt;(<span class="stringliteral">&quot;_amg&quot;</span>) = <span class="keyword">this</span>;</div>
<div class="line"><span class="lineno">  254</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a3a19330f38987cd9318f38d932c5a2ad">_output_params</a>-&gt;set&lt;<a class="code hl_class" href="classFEProblemBase.html">FEProblemBase</a> *&gt;(<span class="stringliteral">&quot;_fe_problem_base&quot;</span>) = &amp;<a class="code hl_variable" href="classAutomaticMortarGeneration.html#aaad114f9251de54152c04ef277441578">_app</a>.<a class="code hl_function" href="classMooseApp.html#a9901a98a17c8276cc00b4841584bb561">feProblem</a>();</div>
<div class="line"><span class="lineno">  255</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a3a19330f38987cd9318f38d932c5a2ad">_output_params</a>-&gt;set&lt;<a class="code hl_class" href="classMooseApp.html">MooseApp</a> *&gt;(<span class="stringliteral">&quot;_moose_app&quot;</span>) = &amp;<a class="code hl_variable" href="classAutomaticMortarGeneration.html#aaad114f9251de54152c04ef277441578">_app</a>;</div>
<div class="line"><span class="lineno">  256</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a3a19330f38987cd9318f38d932c5a2ad">_output_params</a>-&gt;set&lt;std::string&gt;(<span class="stringliteral">&quot;_object_name&quot;</span>) =</div>
<div class="line"><span class="lineno">  257</span>      <span class="stringliteral">&quot;mortar_nodal_geometry_&quot;</span> +</div>
<div class="line"><span class="lineno">  258</span>      std::to_string(<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a36e1a5b919de8cfdc39c8af4098fb450">_primary_secondary_boundary_id_pairs</a>.front().first) +</div>
<div class="line"><span class="lineno">  259</span>      std::to_string(<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a36e1a5b919de8cfdc39c8af4098fb450">_primary_secondary_boundary_id_pairs</a>.front().second) + <span class="stringliteral">&quot;_&quot;</span> +</div>
<div class="line"><span class="lineno">  260</span>      (<a class="code hl_variable" href="classAutomaticMortarGeneration.html#ac1faa015bf0201e49ab822e50b713fc1">_on_displaced</a> ? <span class="stringliteral">&quot;displaced&quot;</span> : <span class="stringliteral">&quot;undisplaced&quot;</span>);</div>
<div class="line"><span class="lineno">  261</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#aaad114f9251de54152c04ef277441578">_app</a>.<a class="code hl_function" href="classMooseApp.html#a446e24d786a991471cfc3a1f0aeccaea">getOutputWarehouse</a>().<a class="code hl_function" href="classOutputWarehouse.html#af1e105715b5393f3341b24fdc4f31627">addOutput</a>(std::make_shared&lt;MortarNodalGeometryOutput&gt;(*<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a3a19330f38987cd9318f38d932c5a2ad">_output_params</a>));</div>
<div class="line"><span class="lineno">  262</span>}</div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html"><div class="ttname"><a href="classAutomaticMortarGeneration.html">AutomaticMortarGeneration</a></div><div class="ttdoc">This class is a container/interface for the objects involved in automatic generation of mortar spaces...</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00056">AutomaticMortarGeneration.h:57</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a3a19330f38987cd9318f38d932c5a2ad"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a3a19330f38987cd9318f38d932c5a2ad">AutomaticMortarGeneration::_output_params</a></div><div class="ttdeci">std::unique_ptr&lt; InputParameters &gt; _output_params</div><div class="ttdoc">Storage for the input parameters used by the mortar nodal geometry output.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00508">AutomaticMortarGeneration.h:508</a></div></div>
<div class="ttc" id="aclassFEProblemBase_html"><div class="ttname"><a href="classFEProblemBase.html">FEProblemBase</a></div><div class="ttdoc">Specialization of SubProblem for solving nonlinear equations plus auxiliary equations.</div><div class="ttdef"><b>Definition:</b> <a href="FEProblemBase_8h_source.html#l00145">FEProblemBase.h:146</a></div></div>
<div class="ttc" id="aclassMooseApp_html"><div class="ttname"><a href="classMooseApp.html">MooseApp</a></div><div class="ttdoc">Base class for MOOSE-based applications.</div><div class="ttdef"><b>Definition:</b> <a href="MooseApp_8h_source.html#l00068">MooseApp.h:71</a></div></div>
<div class="ttc" id="aclassMooseApp_html_a446e24d786a991471cfc3a1f0aeccaea"><div class="ttname"><a href="classMooseApp.html#a446e24d786a991471cfc3a1f0aeccaea">MooseApp::getOutputWarehouse</a></div><div class="ttdeci">OutputWarehouse &amp; getOutputWarehouse()</div><div class="ttdoc">Get the OutputWarehouse objects.</div><div class="ttdef"><b>Definition:</b> <a href="MooseApp_8C_source.html#l01734">MooseApp.C:1734</a></div></div>
<div class="ttc" id="aclassMooseApp_html_a9901a98a17c8276cc00b4841584bb561"><div class="ttname"><a href="classMooseApp.html#a9901a98a17c8276cc00b4841584bb561">MooseApp::feProblem</a></div><div class="ttdeci">FEProblemBase &amp; feProblem() const</div><div class="ttdef"><b>Definition:</b> <a href="MooseApp_8C_source.html#l01305">MooseApp.C:1305</a></div></div>
<div class="ttc" id="aclassMortarNodalGeometryOutput_html_a6bf8458c621e9dba746029f0f658eab1"><div class="ttname"><a href="classMortarNodalGeometryOutput.html#a6bf8458c621e9dba746029f0f658eab1">MortarNodalGeometryOutput::validParams</a></div><div class="ttdeci">static InputParameters validParams()</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8C_source.html#l00064">AutomaticMortarGeneration.C:64</a></div></div>
<div class="ttc" id="aclassOutputWarehouse_html_af1e105715b5393f3341b24fdc4f31627"><div class="ttname"><a href="classOutputWarehouse.html#af1e105715b5393f3341b24fdc4f31627">OutputWarehouse::addOutput</a></div><div class="ttdeci">void addOutput(std::shared_ptr&lt; Output &gt; output)</div><div class="ttdoc">Adds an existing output object to the warehouse.</div><div class="ttdef"><b>Definition:</b> <a href="OutputWarehouse_8C_source.html#l00102">OutputWarehouse.C:102</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ae7e2418ea72d399f0e9d33fd6c158e37" name="ae7e2418ea72d399f0e9d33fd6c158e37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7e2418ea72d399f0e9d33fd6c158e37">&#9670;&#160;</a></span>mortarInterfaceCoupling()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::unordered_map&lt; dof_id_type, std::unordered_set&lt; dof_id_type &gt; &gt; &amp; AutomaticMortarGeneration::mortarInterfaceCoupling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The mortar interface coupling </dd></dl>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00256">256</a> of file <a class="el" href="AutomaticMortarGeneration_8h_source.html">AutomaticMortarGeneration.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  257</span>  {</div>
<div class="line"><span class="lineno">  258</span>    <span class="keywordflow">return</span> <a class="code hl_variable" href="classAutomaticMortarGeneration.html#ab2357a3aacfa2cae90078e3b6293bf26">_mortar_interface_coupling</a>;</div>
<div class="line"><span class="lineno">  259</span>  }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="AugmentSparsityOnInterface_8C_source.html#l00205">AugmentSparsityOnInterface::ghostHigherDNeighbors()</a>, <a class="el" href="AugmentSparsityOnInterface_8C_source.html#l00124">AugmentSparsityOnInterface::ghostLowerDSecondaryElemPointNeighbors()</a>, and <a class="el" href="AugmentSparsityOnInterface_8C_source.html#l00098">AugmentSparsityOnInterface::ghostMortarInterfaceCouplings()</a>.</p>

</div>
</div>
<a id="aa4d61e6ddf45aeac1436b6755a33bf68" name="aa4d61e6ddf45aeac1436b6755a33bf68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d61e6ddf45aeac1436b6755a33bf68">&#9670;&#160;</a></span>mortarSegmentMesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const MeshBase &amp; AutomaticMortarGeneration::mortarSegmentMesh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The mortar segment mesh </dd></dl>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00269">269</a> of file <a class="el" href="AutomaticMortarGeneration_8h_source.html">AutomaticMortarGeneration.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  269</span>{ <span class="keywordflow">return</span> *<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>; }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="MortarUtils_8h_source.html#l00069">Moose::Mortar::loopOverMortarSegments()</a>.</p>

</div>
</div>
<a id="af1e03eb9fe738d5bdd5800e6dd112dfd" name="af1e03eb9fe738d5bdd5800e6dd112dfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1e03eb9fe738d5bdd5800e6dd112dfd">&#9670;&#160;</a></span>mortarSegmentMeshElemToInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::unordered_map&lt; const Elem *, <a class="el" href="structMortarSegmentInfo.html">MortarSegmentInfo</a> &gt; &amp; AutomaticMortarGeneration::mortarSegmentMeshElemToInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The mortar segment element to corresponding information </dd></dl>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00274">274</a> of file <a class="el" href="AutomaticMortarGeneration_8h_source.html">AutomaticMortarGeneration.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  275</span>  {</div>
<div class="line"><span class="lineno">  276</span>    <span class="keywordflow">return</span> <a class="code hl_variable" href="classAutomaticMortarGeneration.html#abbd91d3cf8bef528976fe6f932622d2d">_msm_elem_to_info</a>;</div>
<div class="line"><span class="lineno">  277</span>  }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="MortarUtils_8h_source.html#l00069">Moose::Mortar::loopOverMortarSegments()</a>.</p>

</div>
</div>
<a id="a345cd37f09eebfb0b829c15f7fd4a441" name="a345cd37f09eebfb0b829c15f7fd4a441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a345cd37f09eebfb0b829c15f7fd4a441">&#9670;&#160;</a></span>msmStatistics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AutomaticMortarGeneration::msmStatistics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Outputs mesh statistics for mortar segment mesh. </p>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01421">1421</a> of file <a class="el" href="AutomaticMortarGeneration_8C_source.html">AutomaticMortarGeneration.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1422</span>{</div>
<div class="line"><span class="lineno"> 1423</span>  <span class="comment">// Print boundary pairs</span></div>
<div class="line"><span class="lineno"> 1424</span>  Moose::out &lt;&lt; <span class="stringliteral">&quot;Mortar Interface Statistics:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno"> 1425</span> </div>
<div class="line"><span class="lineno"> 1426</span>  <span class="comment">// Count number of elements on primary and secondary sides</span></div>
<div class="line"><span class="lineno"> 1427</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; pr : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a969d4ab038fc8d447e966cd1e1600091">_primary_secondary_subdomain_id_pairs</a>)</div>
<div class="line"><span class="lineno"> 1428</span>  {</div>
<div class="line"><span class="lineno"> 1429</span>    <span class="keyword">const</span> <span class="keyword">auto</span> primary_subd_id = pr.first;</div>
<div class="line"><span class="lineno"> 1430</span>    <span class="keyword">const</span> <span class="keyword">auto</span> secondary_subd_id = pr.second;</div>
<div class="line"><span class="lineno"> 1431</span> </div>
<div class="line"><span class="lineno"> 1432</span>    <span class="comment">// Allocate statistics vectors for primary lower, secondary lower, and msm meshes</span></div>
<div class="line"><span class="lineno"> 1433</span>    StatisticsVector&lt;Real&gt; primary;   <span class="comment">// primary.reserve(mesh.n_elem());</span></div>
<div class="line"><span class="lineno"> 1434</span>    StatisticsVector&lt;Real&gt; secondary; <span class="comment">// secondary.reserve(mesh.n_elem());</span></div>
<div class="line"><span class="lineno"> 1435</span>    StatisticsVector&lt;Real&gt; msm;       <span class="comment">// msm.reserve(mortar_segment_mesh-&gt;n_elem());</span></div>
<div class="line"><span class="lineno"> 1436</span> </div>
<div class="line"><span class="lineno"> 1437</span>    <span class="keywordflow">for</span> (<span class="keyword">auto</span> * el : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.active_element_ptr_range())</div>
<div class="line"><span class="lineno"> 1438</span>    {</div>
<div class="line"><span class="lineno"> 1439</span>      <span class="comment">// Add secondary and primary elem volumes to statistics vector</span></div>
<div class="line"><span class="lineno"> 1440</span>      <span class="keywordflow">if</span> (el-&gt;subdomain_id() == secondary_subd_id)</div>
<div class="line"><span class="lineno"> 1441</span>        secondary.push_back(el-&gt;volume());</div>
<div class="line"><span class="lineno"> 1442</span>      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (el-&gt;subdomain_id() == primary_subd_id)</div>
<div class="line"><span class="lineno"> 1443</span>        primary.push_back(el-&gt;volume());</div>
<div class="line"><span class="lineno"> 1444</span>    }</div>
<div class="line"><span class="lineno"> 1445</span> </div>
<div class="line"><span class="lineno"> 1446</span>    <span class="comment">// Note: when we allow more than one primary secondary pair will need to make</span></div>
<div class="line"><span class="lineno"> 1447</span>    <span class="comment">// separate mortar segment mesh for each</span></div>
<div class="line"><span class="lineno"> 1448</span>    <span class="keywordflow">for</span> (<span class="keyword">auto</span> msm_elem : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;active_local_element_ptr_range())</div>
<div class="line"><span class="lineno"> 1449</span>    {</div>
<div class="line"><span class="lineno"> 1450</span>      <span class="comment">// Add msm elem volume to statistic vector</span></div>
<div class="line"><span class="lineno"> 1451</span>      msm.push_back(msm_elem-&gt;volume());</div>
<div class="line"><span class="lineno"> 1452</span>    }</div>
<div class="line"><span class="lineno"> 1453</span> </div>
<div class="line"><span class="lineno"> 1454</span>    <span class="comment">// Create table</span></div>
<div class="line"><span class="lineno"> 1455</span>    std::vector&lt;std::string&gt; col_names = {<span class="stringliteral">&quot;mesh&quot;</span>, <span class="stringliteral">&quot;n_elems&quot;</span>, <span class="stringliteral">&quot;max&quot;</span>, <span class="stringliteral">&quot;min&quot;</span>, <span class="stringliteral">&quot;median&quot;</span>};</div>
<div class="line"><span class="lineno"> 1456</span>    std::vector&lt;std::string&gt; subds = {<span class="stringliteral">&quot;secondary_lower&quot;</span>, <span class="stringliteral">&quot;primary_lower&quot;</span>, <span class="stringliteral">&quot;mortar_segment&quot;</span>};</div>
<div class="line"><span class="lineno"> 1457</span>    std::vector&lt;size_t&gt; n_elems = {secondary.size(), primary.size(), msm.size()};</div>
<div class="line"><span class="lineno"> 1458</span>    std::vector&lt;Real&gt; maxs = {secondary.maximum(), primary.maximum(), msm.maximum()};</div>
<div class="line"><span class="lineno"> 1459</span>    std::vector&lt;Real&gt; mins = {secondary.minimum(), primary.minimum(), msm.minimum()};</div>
<div class="line"><span class="lineno"> 1460</span>    std::vector&lt;Real&gt; medians = {secondary.median(), primary.median(), msm.median()};</div>
<div class="line"><span class="lineno"> 1461</span> </div>
<div class="line"><span class="lineno"> 1462</span>    <a class="code hl_class" href="classFormattedTable.html">FormattedTable</a> table;</div>
<div class="line"><span class="lineno"> 1463</span>    table.<a class="code hl_function" href="classFormattedTable.html#a17854e65f279e180420146fa570ed36a">clear</a>();</div>
<div class="line"><span class="lineno"> 1464</span>    <span class="keywordflow">for</span> (<span class="keyword">auto</span> i : index_range(subds))</div>
<div class="line"><span class="lineno"> 1465</span>    {</div>
<div class="line"><span class="lineno"> 1466</span>      table.<a class="code hl_function" href="classFormattedTable.html#ad88c8d5f300a569a9bc4844223d39612">addRow</a>(i);</div>
<div class="line"><span class="lineno"> 1467</span>      table.<a class="code hl_function" href="classFormattedTable.html#aa3a67ad3a70d2ac160f76b605a415853">addData</a>&lt;std::string&gt;(col_names[0], subds[i]);</div>
<div class="line"><span class="lineno"> 1468</span>      table.<a class="code hl_function" href="classFormattedTable.html#aa3a67ad3a70d2ac160f76b605a415853">addData</a>&lt;<span class="keywordtype">size_t</span>&gt;(col_names[1], n_elems[i]);</div>
<div class="line"><span class="lineno"> 1469</span>      table.<a class="code hl_function" href="classFormattedTable.html#aa3a67ad3a70d2ac160f76b605a415853">addData</a>&lt;Real&gt;(col_names[2], maxs[i]);</div>
<div class="line"><span class="lineno"> 1470</span>      table.<a class="code hl_function" href="classFormattedTable.html#aa3a67ad3a70d2ac160f76b605a415853">addData</a>&lt;Real&gt;(col_names[3], mins[i]);</div>
<div class="line"><span class="lineno"> 1471</span>      table.<a class="code hl_function" href="classFormattedTable.html#aa3a67ad3a70d2ac160f76b605a415853">addData</a>&lt;Real&gt;(col_names[4], medians[i]);</div>
<div class="line"><span class="lineno"> 1472</span>    }</div>
<div class="line"><span class="lineno"> 1473</span> </div>
<div class="line"><span class="lineno"> 1474</span>    Moose::out &lt;&lt; <span class="stringliteral">&quot;secondary subdomain: &quot;</span> &lt;&lt; secondary_subd_id</div>
<div class="line"><span class="lineno"> 1475</span>               &lt;&lt; <span class="stringliteral">&quot; \tprimary subdomain: &quot;</span> &lt;&lt; primary_subd_id &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno"> 1476</span>    table.<a class="code hl_function" href="classFormattedTable.html#a69a8eb1233d213541c3e74d5de3cd882">printTable</a>(Moose::out, subds.size());</div>
<div class="line"><span class="lineno"> 1477</span>  }</div>
<div class="line"><span class="lineno"> 1478</span>}</div>
<div class="ttc" id="aclassFormattedTable_html"><div class="ttname"><a href="classFormattedTable.html">FormattedTable</a></div><div class="ttdoc">This class is used for building, formatting, and outputting tables of numbers.</div><div class="ttdef"><b>Definition:</b> <a href="FormattedTable_8h_source.html#l00109">FormattedTable.h:110</a></div></div>
<div class="ttc" id="aclassFormattedTable_html_a17854e65f279e180420146fa570ed36a"><div class="ttname"><a href="classFormattedTable.html#a17854e65f279e180420146fa570ed36a">FormattedTable::clear</a></div><div class="ttdeci">void clear()</div><div class="ttdef"><b>Definition:</b> <a href="FormattedTable_8C_source.html#l00563">FormattedTable.C:563</a></div></div>
<div class="ttc" id="aclassFormattedTable_html_a69a8eb1233d213541c3e74d5de3cd882"><div class="ttname"><a href="classFormattedTable.html#a69a8eb1233d213541c3e74d5de3cd882">FormattedTable::printTable</a></div><div class="ttdeci">void printTable(std::ostream &amp;out, unsigned int last_n_entries=0)</div><div class="ttdoc">Methods for dumping the table to the stream - either by filename or by stream handle.</div><div class="ttdef"><b>Definition:</b> <a href="FormattedTable_8C_source.html#l00242">FormattedTable.C:242</a></div></div>
<div class="ttc" id="aclassFormattedTable_html_aa3a67ad3a70d2ac160f76b605a415853"><div class="ttname"><a href="classFormattedTable.html#aa3a67ad3a70d2ac160f76b605a415853">FormattedTable::addData</a></div><div class="ttdeci">void addData(const std::string &amp;name, const T &amp;value)</div><div class="ttdoc">Method for adding data to the output table.</div><div class="ttdef"><b>Definition:</b> <a href="FormattedTable_8h_source.html#l00327">FormattedTable.h:327</a></div></div>
<div class="ttc" id="aclassFormattedTable_html_ad88c8d5f300a569a9bc4844223d39612"><div class="ttname"><a href="classFormattedTable.html#ad88c8d5f300a569a9bc4844223d39612">FormattedTable::addRow</a></div><div class="ttdeci">void addRow(Real time)</div><div class="ttdoc">Force a new row in the table with the passed in time.</div><div class="ttdef"><b>Definition:</b> <a href="FormattedTable_8C_source.html#l00186">FormattedTable.C:186</a></div></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00930">buildMortarSegmentMesh3d()</a>.</p>

</div>
</div>
<a id="afd30aa47635b25b913c120f2b3f3c311" name="afd30aa47635b25b913c120f2b3f3c311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd30aa47635b25b913c120f2b3f3c311">&#9670;&#160;</a></span>nodesToSecondaryElem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::unordered_map&lt; dof_id_type, std::vector&lt; const Elem * &gt; &gt; &amp; AutomaticMortarGeneration::nodesToSecondaryElem </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Map from node id to secondary lower-d element pointer </dd></dl>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00333">333</a> of file <a class="el" href="AutomaticMortarGeneration_8h_source.html">AutomaticMortarGeneration.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  334</span>  {</div>
<div class="line"><span class="lineno">  335</span>    <span class="keywordflow">return</span> <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a1ad443aa196d2c81d195b29ddeee1d5e">_nodes_to_secondary_elem_map</a>;</div>
<div class="line"><span class="lineno">  336</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="abad2defa2f6ae78d1024147d1cb2d286" name="abad2defa2f6ae78d1024147d1cb2d286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abad2defa2f6ae78d1024147d1cb2d286">&#9670;&#160;</a></span>onDisplaced()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AutomaticMortarGeneration::onDisplaced </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns whether this object is on the displaced mesh </p>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00171">171</a> of file <a class="el" href="AutomaticMortarGeneration_8h_source.html">AutomaticMortarGeneration.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  171</span>{ <span class="keywordflow">return</span> <a class="code hl_variable" href="classAutomaticMortarGeneration.html#ac1faa015bf0201e49ab822e50b713fc1">_on_displaced</a>; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab03f445cfd60649eff408ab335945380" name="ab03f445cfd60649eff408ab335945380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab03f445cfd60649eff408ab335945380">&#9670;&#160;</a></span>primaryIPSubIDs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::set&lt; <a class="el" href="AutomaticMortarGeneration_8h.html#afb1ef82fea6170b578d48ad9cd793486">SubdomainID</a> &gt; &amp; AutomaticMortarGeneration::primaryIPSubIDs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>All the primary interior parent subdomain IDs associated with the mortar mesh </dd></dl>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00328">328</a> of file <a class="el" href="AutomaticMortarGeneration_8h_source.html">AutomaticMortarGeneration.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  328</span>{ <span class="keywordflow">return</span> <a class="code hl_variable" href="classAutomaticMortarGeneration.html#ac99e408cefd4da80efa2649ef1d32e93">_primary_ip_sub_ids</a>; }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="MortarUtils_8h_source.html#l00326">Moose::Mortar::setupMortarMaterials()</a>.</p>

</div>
</div>
<a id="a511ff6b012ca85a15ed00b59049140ac" name="a511ff6b012ca85a15ed00b59049140ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a511ff6b012ca85a15ed00b59049140ac">&#9670;&#160;</a></span>primarySecondaryBoundaryIDPair()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::pair&lt; <a class="el" href="AutomaticMortarGeneration_8h.html#acdf40e62836d2c708e17f9e204b0f877">BoundaryID</a>, <a class="el" href="AutomaticMortarGeneration_8h.html#acdf40e62836d2c708e17f9e204b0f877">BoundaryID</a> &gt; &amp; AutomaticMortarGeneration::primarySecondaryBoundaryIDPair </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The primary-secondary boundary ID pair </dd></dl>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00515">515</a> of file <a class="el" href="AutomaticMortarGeneration_8h_source.html">AutomaticMortarGeneration.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  516</span>{</div>
<div class="line"><span class="lineno">  517</span>  mooseAssert(<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a36e1a5b919de8cfdc39c8af4098fb450">_primary_secondary_boundary_id_pairs</a>.size() == 1,</div>
<div class="line"><span class="lineno">  518</span>              <span class="stringliteral">&quot;We currently only support a single boundary pair per mortar generation object&quot;</span>);</div>
<div class="line"><span class="lineno">  519</span> </div>
<div class="line"><span class="lineno">  520</span>  <span class="keywordflow">return</span> <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a36e1a5b919de8cfdc39c8af4098fb450">_primary_secondary_boundary_id_pairs</a>.front();</div>
<div class="line"><span class="lineno">  521</span>}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="MortarUtils_8h_source.html#l00069">Moose::Mortar::loopOverMortarSegments()</a>, and <a class="el" href="MortarUtils_8h_source.html#l00326">Moose::Mortar::setupMortarMaterials()</a>.</p>

</div>
</div>
<a id="af3d7aaf216fe1d8fabc8461756312a1f" name="af3d7aaf216fe1d8fabc8461756312a1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3d7aaf216fe1d8fabc8461756312a1f">&#9670;&#160;</a></span>projectPrimaryNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AutomaticMortarGeneration::projectPrimaryNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(Inverse) project primary nodes to the points on the secondary surface where they would have come from (find (xi^(1) values)). </p>
<p >Inputs:</p><ul>
<li>The nodal normals values</li>
<li>mesh</li>
<li>nodes_to_secondary_elem_map</li>
</ul>
<p >Outputs:</p><ul>
<li>primary_node_and_elem_to_xi1_secondary_elem</li>
</ul>
<p >Defined in the file project_primary_nodes.C. </p>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8C_source.html#l02164">2164</a> of file <a class="el" href="AutomaticMortarGeneration_8C_source.html">AutomaticMortarGeneration.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2165</span>{</div>
<div class="line"><span class="lineno"> 2166</span>  <span class="comment">// For each primary/secondary boundary id pair, call the</span></div>
<div class="line"><span class="lineno"> 2167</span>  <span class="comment">// project_primary_nodes_single_pair() helper function.</span></div>
<div class="line"><span class="lineno"> 2168</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; pr : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a969d4ab038fc8d447e966cd1e1600091">_primary_secondary_subdomain_id_pairs</a>)</div>
<div class="line"><span class="lineno"> 2169</span>    <a class="code hl_function" href="classAutomaticMortarGeneration.html#accf5b2f45171eb92b58dd27d22b9715c">projectPrimaryNodesSinglePair</a>(pr.first, pr.second);</div>
<div class="line"><span class="lineno"> 2170</span>}</div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_accf5b2f45171eb92b58dd27d22b9715c"><div class="ttname"><a href="classAutomaticMortarGeneration.html#accf5b2f45171eb92b58dd27d22b9715c">AutomaticMortarGeneration::projectPrimaryNodesSinglePair</a></div><div class="ttdeci">void projectPrimaryNodesSinglePair(SubdomainID lower_dimensional_primary_subdomain_id, SubdomainID lower_dimensional_secondary_subdomain_id)</div><div class="ttdoc">Helper function used internally by AutomaticMortarGeneration::project_primary_nodes().</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8C_source.html#l02173">AutomaticMortarGeneration.C:2173</a></div></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="MortarData_8C_source.html#l00160">MortarData::update()</a>.</p>

</div>
</div>
<a id="accf5b2f45171eb92b58dd27d22b9715c" name="accf5b2f45171eb92b58dd27d22b9715c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accf5b2f45171eb92b58dd27d22b9715c">&#9670;&#160;</a></span>projectPrimaryNodesSinglePair()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AutomaticMortarGeneration::projectPrimaryNodesSinglePair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AutomaticMortarGeneration_8h.html#afb1ef82fea6170b578d48ad9cd793486">SubdomainID</a>&#160;</td>
          <td class="paramname"><em>lower_dimensional_primary_subdomain_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AutomaticMortarGeneration_8h.html#afb1ef82fea6170b578d48ad9cd793486">SubdomainID</a>&#160;</td>
          <td class="paramname"><em>lower_dimensional_secondary_subdomain_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function used internally by AutomaticMortarGeneration::project_primary_nodes(). </p>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8C_source.html#l02173">2173</a> of file <a class="el" href="AutomaticMortarGeneration_8C_source.html">AutomaticMortarGeneration.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2176</span>{</div>
<div class="line"><span class="lineno"> 2177</span>  <span class="comment">// Build a Nanoflann object on the lower-dimensional secondary elements of the Mesh.</span></div>
<div class="line"><span class="lineno"> 2178</span>  <a class="code hl_class" href="classNanoflannMeshSubdomainAdaptor.html">NanoflannMeshSubdomainAdaptor&lt;3&gt;</a> mesh_adaptor(<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>, lower_dimensional_secondary_subdomain_id);</div>
<div class="line"><span class="lineno"> 2179</span>  <a class="code hl_typedef" href="NanoflannMeshAdaptor_8h.html#a3a70df33047194961ce21a0133717038">subdomain_kd_tree_t</a> kd_tree(</div>
<div class="line"><span class="lineno"> 2180</span>      3, mesh_adaptor, nanoflann::KDTreeSingleIndexAdaptorParams(<span class="comment">/*max leaf=*/</span>10));</div>
<div class="line"><span class="lineno"> 2181</span> </div>
<div class="line"><span class="lineno"> 2182</span>  <span class="comment">// Construct the KD tree for lower-dimensional elements in the volume mesh.</span></div>
<div class="line"><span class="lineno"> 2183</span>  kd_tree.buildIndex();</div>
<div class="line"><span class="lineno"> 2184</span> </div>
<div class="line"><span class="lineno"> 2185</span>  std::unordered_set&lt;dof_id_type&gt; primary_nodes_visited;</div>
<div class="line"><span class="lineno"> 2186</span> </div>
<div class="line"><span class="lineno"> 2187</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; primary_side_elem : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.active_element_ptr_range())</div>
<div class="line"><span class="lineno"> 2188</span>  {</div>
<div class="line"><span class="lineno"> 2189</span>    <span class="comment">// If this is not one of the lower-dimensional primary side elements, go on to the next one.</span></div>
<div class="line"><span class="lineno"> 2190</span>    <span class="keywordflow">if</span> (primary_side_elem-&gt;subdomain_id() != lower_dimensional_primary_subdomain_id)</div>
<div class="line"><span class="lineno"> 2191</span>      <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno"> 2192</span> </div>
<div class="line"><span class="lineno"> 2193</span>    <span class="comment">// For each node on this side, find the nearest node on the secondary side using the KDTree,</span></div>
<div class="line"><span class="lineno"> 2194</span>    <span class="comment">// then search in nearby elements for where it projects along the nodal normal direction.</span></div>
<div class="line"><span class="lineno"> 2195</span>    <span class="keywordflow">for</span> (MooseIndex(primary_side_elem-&gt;n_vertices()) n = 0; n &lt; primary_side_elem-&gt;n_vertices();</div>
<div class="line"><span class="lineno"> 2196</span>         ++n)</div>
<div class="line"><span class="lineno"> 2197</span>    {</div>
<div class="line"><span class="lineno"> 2198</span>      <span class="comment">// Get a pointer to this node.</span></div>
<div class="line"><span class="lineno"> 2199</span>      <span class="keyword">const</span> Node * primary_node = primary_side_elem-&gt;node_ptr(n);</div>
<div class="line"><span class="lineno"> 2200</span> </div>
<div class="line"><span class="lineno"> 2201</span>      <span class="comment">// Get the nodal neighbors connected to this primary node.</span></div>
<div class="line"><span class="lineno"> 2202</span>      <span class="keyword">const</span> std::vector&lt;const Elem *&gt; &amp; primary_node_neighbors =</div>
<div class="line"><span class="lineno"> 2203</span>          <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a1ee9b6e4f8bd88603e22117085758f70">_nodes_to_primary_elem_map</a>.at(primary_node-&gt;id());</div>
<div class="line"><span class="lineno"> 2204</span> </div>
<div class="line"><span class="lineno"> 2205</span>      <span class="comment">// Check whether we have already successfully inverse mapped this primary node (whether during</span></div>
<div class="line"><span class="lineno"> 2206</span>      <span class="comment">// secondary node projection or now during primary node projection) or we have already failed</span></div>
<div class="line"><span class="lineno"> 2207</span>      <span class="comment">// to inverse map this primary node (now during primary node projection), and then skip if</span></div>
<div class="line"><span class="lineno"> 2208</span>      <span class="comment">// either of those things is true</span></div>
<div class="line"><span class="lineno"> 2209</span>      <span class="keyword">auto</span> primary_key =</div>
<div class="line"><span class="lineno"> 2210</span>          std::make_tuple(primary_node-&gt;id(), primary_node, primary_node_neighbors[0]);</div>
<div class="line"><span class="lineno"> 2211</span>      <span class="keywordflow">if</span> (!primary_nodes_visited.insert(primary_node-&gt;id()).second ||</div>
<div class="line"><span class="lineno"> 2212</span>          <a class="code hl_variable" href="classAutomaticMortarGeneration.html#ac174eedb02e9681baf439360903700d4">_primary_node_and_elem_to_xi1_secondary_elem</a>.count(primary_key))</div>
<div class="line"><span class="lineno"> 2213</span>        <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno"> 2214</span> </div>
<div class="line"><span class="lineno"> 2215</span>      <span class="comment">// Data structure for performing Nanoflann searches.</span></div>
<div class="line"><span class="lineno"> 2216</span>      Real query_pt[3] = {(*primary_node)(0), (*primary_node)(1), (*primary_node)(2)};</div>
<div class="line"><span class="lineno"> 2217</span> </div>
<div class="line"><span class="lineno"> 2218</span>      <span class="comment">// The number of results we want to get.  We&#39;ll look for a</span></div>
<div class="line"><span class="lineno"> 2219</span>      <span class="comment">// &quot;few&quot; nearest nodes, hopefully that is enough to let us</span></div>
<div class="line"><span class="lineno"> 2220</span>      <span class="comment">// figure out which lower-dimensional Elem on the secondary side</span></div>
<div class="line"><span class="lineno"> 2221</span>      <span class="comment">// we are across from.</span></div>
<div class="line"><span class="lineno"> 2222</span>      <span class="keyword">const</span> <span class="keywordtype">size_t</span> num_results = 3;</div>
<div class="line"><span class="lineno"> 2223</span> </div>
<div class="line"><span class="lineno"> 2224</span>      <span class="comment">// Initialize result_set and do the search.</span></div>
<div class="line"><span class="lineno"> 2225</span>      std::vector&lt;size_t&gt; ret_index(num_results);</div>
<div class="line"><span class="lineno"> 2226</span>      std::vector&lt;Real&gt; out_dist_sqr(num_results);</div>
<div class="line"><span class="lineno"> 2227</span>      nanoflann::KNNResultSet&lt;Real&gt; result_set(num_results);</div>
<div class="line"><span class="lineno"> 2228</span>      result_set.init(&amp;ret_index[0], &amp;out_dist_sqr[0]);</div>
<div class="line"><span class="lineno"> 2229</span>      kd_tree.findNeighbors(result_set, &amp;query_pt[0], <a class="code hl_typedef" href="namespacenanoflann.html#a7475277cf1d06434e352ade6f35de645">nanoflann::SearchParameters</a>());</div>
<div class="line"><span class="lineno"> 2230</span> </div>
<div class="line"><span class="lineno"> 2231</span>      <span class="comment">// If this flag gets set in the loop below, we can break out of the outer r-loop as well.</span></div>
<div class="line"><span class="lineno"> 2232</span>      <span class="keywordtype">bool</span> projection_succeeded = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno"> 2233</span> </div>
<div class="line"><span class="lineno"> 2234</span>      <span class="comment">// Once we&#39;ve rejected a candidate for a given</span></div>
<div class="line"><span class="lineno"> 2235</span>      <span class="comment">// primary_node, there&#39;s no reason to check it</span></div>
<div class="line"><span class="lineno"> 2236</span>      <span class="comment">// again.</span></div>
<div class="line"><span class="lineno"> 2237</span>      std::set&lt;const Elem *&gt; rejected_secondary_elem_candidates;</div>
<div class="line"><span class="lineno"> 2238</span> </div>
<div class="line"><span class="lineno"> 2239</span>      <span class="comment">// Loop over the closest nodes, check whether the secondary node successfully projects into</span></div>
<div class="line"><span class="lineno"> 2240</span>      <span class="comment">// either of the closest neighbors, stop when the projection succeeds.</span></div>
<div class="line"><span class="lineno"> 2241</span>      <span class="keywordflow">for</span> (MooseIndex(result_set) r = 0; r &lt; result_set.size(); ++r)</div>
<div class="line"><span class="lineno"> 2242</span>      {</div>
<div class="line"><span class="lineno"> 2243</span>        <span class="comment">// Verify that the squared distance we compute is the same as nanoflann&#39;s</span></div>
<div class="line"><span class="lineno"> 2244</span>        mooseAssert(std::abs((<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.point(ret_index[r]) - *primary_node).norm_sq() -</div>
<div class="line"><span class="lineno"> 2245</span>                             out_dist_sqr[r]) &lt;= TOLERANCE,</div>
<div class="line"><span class="lineno"> 2246</span>                    <span class="stringliteral">&quot;Lower-dimensional element squared distance verification failed.&quot;</span>);</div>
<div class="line"><span class="lineno"> 2247</span> </div>
<div class="line"><span class="lineno"> 2248</span>        <span class="comment">// Get a reference to the vector of lower dimensional elements from the</span></div>
<div class="line"><span class="lineno"> 2249</span>        <span class="comment">// nodes_to_secondary_elem_map.</span></div>
<div class="line"><span class="lineno"> 2250</span>        <span class="keyword">const</span> std::vector&lt;const Elem *&gt; &amp; secondary_elem_candidates =</div>
<div class="line"><span class="lineno"> 2251</span>            <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a1ad443aa196d2c81d195b29ddeee1d5e">_nodes_to_secondary_elem_map</a>.at(<span class="keyword">static_cast&lt;</span>dof_id_type<span class="keyword">&gt;</span>(ret_index[r]));</div>
<div class="line"><span class="lineno"> 2252</span> </div>
<div class="line"><span class="lineno"> 2253</span>        <span class="comment">// Print the Elems connected to this node on the secondary mesh side.</span></div>
<div class="line"><span class="lineno"> 2254</span>        <span class="keywordflow">for</span> (MooseIndex(secondary_elem_candidates) e = 0; e &lt; secondary_elem_candidates.size(); ++e)</div>
<div class="line"><span class="lineno"> 2255</span>        {</div>
<div class="line"><span class="lineno"> 2256</span>          <span class="keyword">const</span> Elem * secondary_elem_candidate = secondary_elem_candidates[e];</div>
<div class="line"><span class="lineno"> 2257</span> </div>
<div class="line"><span class="lineno"> 2258</span>          <span class="comment">// If we&#39;ve already rejected this candidate, we don&#39;t need to check it again.</span></div>
<div class="line"><span class="lineno"> 2259</span>          <span class="keywordflow">if</span> (rejected_secondary_elem_candidates.count(secondary_elem_candidate))</div>
<div class="line"><span class="lineno"> 2260</span>            <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno"> 2261</span> </div>
<div class="line"><span class="lineno"> 2262</span>          std::vector&lt;Point&gt; nodal_normals(secondary_elem_candidate-&gt;n_nodes());</div>
<div class="line"><span class="lineno"> 2263</span>          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> n : make_range(secondary_elem_candidate-&gt;n_nodes()))</div>
<div class="line"><span class="lineno"> 2264</span>            nodal_normals[n] =</div>
<div class="line"><span class="lineno"> 2265</span>                <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a06fb539aea2e63f3b48a6e1d41a2f568">_secondary_node_to_nodal_normal</a>.at(secondary_elem_candidate-&gt;node_ptr(n));</div>
<div class="line"><span class="lineno"> 2266</span> </div>
<div class="line"><span class="lineno"> 2267</span>          <span class="comment">// Use equation 2.4.6 from Bin Yang&#39;s dissertation to try and solve for</span></div>
<div class="line"><span class="lineno"> 2268</span>          <span class="comment">// the position on the secondary element where this primary came from.  This</span></div>
<div class="line"><span class="lineno"> 2269</span>          <span class="comment">// requires a Newton iteration in general.</span></div>
<div class="line"><span class="lineno"> 2270</span>          <a class="code hl_class" href="classMetaPhysicL_1_1DualNumber.html">DualNumber&lt;Real&gt;</a> xi1_dn{0, 1}; <span class="comment">// initial guess</span></div>
<div class="line"><span class="lineno"> 2271</span>          <span class="keyword">auto</span> &amp;&amp; order = secondary_elem_candidate-&gt;default_order();</div>
<div class="line"><span class="lineno"> 2272</span>          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> current_iterate = 0, max_iterates = 10;</div>
<div class="line"><span class="lineno"> 2273</span> </div>
<div class="line"><span class="lineno"> 2274</span>          <a class="code hl_class" href="classlibMesh_1_1VectorValue.html">VectorValue&lt;DualNumber&lt;Real&gt;</a>&gt; normals(0);</div>
<div class="line"><span class="lineno"> 2275</span> </div>
<div class="line"><span class="lineno"> 2276</span>          <span class="comment">// Newton iteration loop - this to converge in 1 iteration when it</span></div>
<div class="line"><span class="lineno"> 2277</span>          <span class="comment">// succeeds, and possibly two iterations when it converges to a</span></div>
<div class="line"><span class="lineno"> 2278</span>          <span class="comment">// xi outside the reference element. I don&#39;t know any reason why it should</span></div>
<div class="line"><span class="lineno"> 2279</span>          <span class="comment">// only take 1 iteration -- the Jacobian is not constant in general...</span></div>
<div class="line"><span class="lineno"> 2280</span>          <span class="keywordflow">do</span></div>
<div class="line"><span class="lineno"> 2281</span>          {</div>
<div class="line"><span class="lineno"> 2282</span>            <a class="code hl_class" href="classlibMesh_1_1VectorValue.html">VectorValue&lt;DualNumber&lt;Real&gt;</a>&gt; x1(0);</div>
<div class="line"><span class="lineno"> 2283</span>            <span class="keywordflow">for</span> (MooseIndex(secondary_elem_candidate-&gt;n_nodes()) n = 0;</div>
<div class="line"><span class="lineno"> 2284</span>                 n &lt; secondary_elem_candidate-&gt;n_nodes();</div>
<div class="line"><span class="lineno"> 2285</span>                 ++n)</div>
<div class="line"><span class="lineno"> 2286</span>            {</div>
<div class="line"><span class="lineno"> 2287</span>              <span class="keyword">const</span> <span class="keyword">auto</span> phi = <a class="code hl_function" href="namespaceMoose.html#a9ed3373b5072c07f1f010afb75ac20c9">Moose::fe_lagrange_1D_shape</a>(order, n, xi1_dn);</div>
<div class="line"><span class="lineno"> 2288</span>              x1 += phi * secondary_elem_candidate-&gt;point(n);</div>
<div class="line"><span class="lineno"> 2289</span>              normals += phi * nodal_normals[n];</div>
<div class="line"><span class="lineno"> 2290</span>            }</div>
<div class="line"><span class="lineno"> 2291</span> </div>
<div class="line"><span class="lineno"> 2292</span>            <span class="keyword">const</span> <span class="keyword">auto</span> u = x1 - (*primary_node);</div>
<div class="line"><span class="lineno"> 2293</span> </div>
<div class="line"><span class="lineno"> 2294</span>            <span class="keyword">const</span> <span class="keyword">auto</span> F = u(0) * normals(1) - u(1) * normals(0);</div>
<div class="line"><span class="lineno"> 2295</span> </div>
<div class="line"><span class="lineno"> 2296</span>            <span class="keywordflow">if</span> (std::abs(F) &lt; <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a04e775677691747d25e1a5f05496fa5a">_newton_tolerance</a>)</div>
<div class="line"><span class="lineno"> 2297</span>              <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 2298</span> </div>
<div class="line"><span class="lineno"> 2299</span>            <span class="comment">// Unlike for projection of nodal normals onto primary surfaces, we should never have a</span></div>
<div class="line"><span class="lineno"> 2300</span>            <span class="comment">// case where the nodal normal is completely orthogonal to the secondary surface, so we</span></div>
<div class="line"><span class="lineno"> 2301</span>            <span class="comment">// do not have to guard against F.derivatives() == 0 here</span></div>
<div class="line"><span class="lineno"> 2302</span>            Real dxi1 = -F.value() / F.derivatives();</div>
<div class="line"><span class="lineno"> 2303</span> </div>
<div class="line"><span class="lineno"> 2304</span>            xi1_dn += dxi1;</div>
<div class="line"><span class="lineno"> 2305</span> </div>
<div class="line"><span class="lineno"> 2306</span>            normals = 0;</div>
<div class="line"><span class="lineno"> 2307</span>          } <span class="keywordflow">while</span> (++current_iterate &lt; max_iterates);</div>
<div class="line"><span class="lineno"> 2308</span> </div>
<div class="line"><span class="lineno"> 2309</span>          Real xi1 = xi1_dn.value();</div>
<div class="line"><span class="lineno"> 2310</span> </div>
<div class="line"><span class="lineno"> 2311</span>          <span class="comment">// Check for convergence to a valid solution... The last condition checks for obliqueness</span></div>
<div class="line"><span class="lineno"> 2312</span>          <span class="comment">// of the projection</span></div>
<div class="line"><span class="lineno"> 2313</span>          <span class="keywordflow">if</span> ((current_iterate &lt; max_iterates) &amp;&amp; (std::abs(xi1) &lt;= 1. + <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a25f6f147b1b0a4b00e7c6739dd17b98c">_xi_tolerance</a>) &amp;&amp;</div>
<div class="line"><span class="lineno"> 2314</span>              (std::abs((primary_side_elem-&gt;point(0) - primary_side_elem-&gt;point(1)).unit() *</div>
<div class="line"><span class="lineno"> 2315</span>                        <a class="code hl_function" href="namespaceMetaPhysicL.html#a1c0a19c861d5f7813f7fb6825d8fe146">MetaPhysicL::raw_value</a>(normals).unit()) &lt;</div>
<div class="line"><span class="lineno"> 2316</span>               std::cos(<a class="code hl_variable" href="classAutomaticMortarGeneration.html#af5ca257dd4090b3a8d801a439dcae0ca">_minimum_projection_angle</a> * libMesh::pi / 180.0)))</div>
<div class="line"><span class="lineno"> 2317</span>          {</div>
<div class="line"><span class="lineno"> 2318</span>            <span class="keywordflow">if</span> (std::abs(std::abs(xi1) - 1.) &lt; <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a25f6f147b1b0a4b00e7c6739dd17b98c">_xi_tolerance</a>)</div>
<div class="line"><span class="lineno"> 2319</span>            {</div>
<div class="line"><span class="lineno"> 2320</span>              <span class="comment">// Special case: xi1=+/-1.</span></div>
<div class="line"><span class="lineno"> 2321</span>              <span class="comment">// It is unlikely that we get here, because this primary node should already</span></div>
<div class="line"><span class="lineno"> 2322</span>              <span class="comment">// have been mapped during the project_secondary_nodes() routine, but</span></div>
<div class="line"><span class="lineno"> 2323</span>              <span class="comment">// there is still a chance since the tolerances are applied to</span></div>
<div class="line"><span class="lineno"> 2324</span>              <span class="comment">// the xi coordinate and that value may be different on a primary element and a</span></div>
<div class="line"><span class="lineno"> 2325</span>              <span class="comment">// secondary element since they may have different sizes.</span></div>
<div class="line"><span class="lineno"> 2326</span>              <span class="keywordflow">throw</span> <a class="code hl_class" href="classMooseException.html">MooseException</a>(<span class="stringliteral">&quot;Nodes on primary and secondary surfaces are aligned. This is &quot;</span></div>
<div class="line"><span class="lineno"> 2327</span>                                   <span class="stringliteral">&quot;causing trouble when identifying projections from secondary &quot;</span></div>
<div class="line"><span class="lineno"> 2328</span>                                   <span class="stringliteral">&quot;nodes when performing primary node projections.&quot;</span>);</div>
<div class="line"><span class="lineno"> 2329</span>            }</div>
<div class="line"><span class="lineno"> 2330</span>            <span class="keywordflow">else</span> <span class="comment">// somewhere in the middle of the Elem</span></div>
<div class="line"><span class="lineno"> 2331</span>            {</div>
<div class="line"><span class="lineno"> 2332</span>              <span class="comment">// Add entry to primary_node_and_elem_to_xi1_secondary_elem</span></div>
<div class="line"><span class="lineno"> 2333</span>              <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 2334</span>              <span class="comment">// Note: we originally duplicated the map values for the keys (node, left_neighbor)</span></div>
<div class="line"><span class="lineno"> 2335</span>              <span class="comment">// and (node, right_neighbor) but I don&#39;t think that should be necessary. Instead we</span></div>
<div class="line"><span class="lineno"> 2336</span>              <span class="comment">// just do it for neighbor 0, but really maybe we don&#39;t even need to do that since</span></div>
<div class="line"><span class="lineno"> 2337</span>              <span class="comment">// we can always look up the neighbors later given the Node... keeping it like this</span></div>
<div class="line"><span class="lineno"> 2338</span>              <span class="comment">// helps to maintain the &quot;symmetry&quot; of the two containers.</span></div>
<div class="line"><span class="lineno"> 2339</span>              <span class="keyword">const</span> Elem * neigh = primary_node_neighbors[0];</div>
<div class="line"><span class="lineno"> 2340</span>              <span class="keywordflow">for</span> (MooseIndex(neigh-&gt;n_vertices()) nid = 0; nid &lt; neigh-&gt;n_vertices(); ++nid)</div>
<div class="line"><span class="lineno"> 2341</span>              {</div>
<div class="line"><span class="lineno"> 2342</span>                <span class="keyword">const</span> Node * neigh_node = neigh-&gt;node_ptr(nid);</div>
<div class="line"><span class="lineno"> 2343</span>                <span class="keywordflow">if</span> (primary_node == neigh_node)</div>
<div class="line"><span class="lineno"> 2344</span>                {</div>
<div class="line"><span class="lineno"> 2345</span>                  <span class="keyword">auto</span> key = std::make_tuple(neigh_node-&gt;id(), neigh_node, neigh);</div>
<div class="line"><span class="lineno"> 2346</span>                  <span class="keyword">auto</span> val = std::make_pair(xi1, secondary_elem_candidate);</div>
<div class="line"><span class="lineno"> 2347</span>                  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#ac174eedb02e9681baf439360903700d4">_primary_node_and_elem_to_xi1_secondary_elem</a>.emplace(key, val);</div>
<div class="line"><span class="lineno"> 2348</span>                }</div>
<div class="line"><span class="lineno"> 2349</span>              }</div>
<div class="line"><span class="lineno"> 2350</span>            }</div>
<div class="line"><span class="lineno"> 2351</span> </div>
<div class="line"><span class="lineno"> 2352</span>            projection_succeeded = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 2353</span>            <span class="keywordflow">break</span>; <span class="comment">// out of e-loop</span></div>
<div class="line"><span class="lineno"> 2354</span>          }</div>
<div class="line"><span class="lineno"> 2355</span>          <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno"> 2356</span>          {</div>
<div class="line"><span class="lineno"> 2357</span>            <span class="comment">// The current primary_point is not in this Elem, so keep track of the rejects.</span></div>
<div class="line"><span class="lineno"> 2358</span>            rejected_secondary_elem_candidates.insert(secondary_elem_candidate);</div>
<div class="line"><span class="lineno"> 2359</span>          }</div>
<div class="line"><span class="lineno"> 2360</span>        } <span class="comment">// end e-loop over candidate elems</span></div>
<div class="line"><span class="lineno"> 2361</span> </div>
<div class="line"><span class="lineno"> 2362</span>        <span class="keywordflow">if</span> (projection_succeeded)</div>
<div class="line"><span class="lineno"> 2363</span>          <span class="keywordflow">break</span>; <span class="comment">// out of r-loop</span></div>
<div class="line"><span class="lineno"> 2364</span>      }          <span class="comment">// r-loop</span></div>
<div class="line"><span class="lineno"> 2365</span> </div>
<div class="line"><span class="lineno"> 2366</span>      <span class="keywordflow">if</span> (!projection_succeeded &amp;&amp; <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a958de5b754ec676f463c50d2f16b5d0c">_debug</a>)</div>
<div class="line"><span class="lineno"> 2367</span>      {</div>
<div class="line"><span class="lineno"> 2368</span>        <a class="code hl_variable" href="classConsoleStreamInterface.html#acd1f259e7a3d200223164c08af3a7c13">_console</a> &lt;&lt; <span class="stringliteral">&quot;Failed to find point from which primary node &quot;</span></div>
<div class="line"><span class="lineno"> 2369</span>                 &lt;&lt; <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>Point &amp;<span class="keyword">&gt;</span>(*primary_node) &lt;&lt; <span class="stringliteral">&quot; was projected.&quot;</span> &lt;&lt; std::endl</div>
<div class="line"><span class="lineno"> 2370</span>                 &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno"> 2371</span>      }</div>
<div class="line"><span class="lineno"> 2372</span>    } <span class="comment">// loop over side nodes</span></div>
<div class="line"><span class="lineno"> 2373</span>  }   <span class="comment">// end loop over elements for finding where primary points would have projected from.</span></div>
<div class="line"><span class="lineno"> 2374</span>}</div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a04e775677691747d25e1a5f05496fa5a"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a04e775677691747d25e1a5f05496fa5a">AutomaticMortarGeneration::_newton_tolerance</a></div><div class="ttdeci">Real _newton_tolerance</div><div class="ttdoc">Newton solve tolerance for node projections.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00490">AutomaticMortarGeneration.h:490</a></div></div>
<div class="ttc" id="aclassConsoleStreamInterface_html_acd1f259e7a3d200223164c08af3a7c13"><div class="ttname"><a href="classConsoleStreamInterface.html#acd1f259e7a3d200223164c08af3a7c13">ConsoleStreamInterface::_console</a></div><div class="ttdeci">const ConsoleStream _console</div><div class="ttdoc">An instance of helper class to write streams to the Console objects.</div><div class="ttdef"><b>Definition:</b> <a href="ConsoleStreamInterface_8h_source.html#l00031">ConsoleStreamInterface.h:31</a></div></div>
<div class="ttc" id="aclassMetaPhysicL_1_1DualNumber_html"><div class="ttname"><a href="classMetaPhysicL_1_1DualNumber.html">MetaPhysicL::DualNumber</a></div><div class="ttdef"><b>Definition:</b> <a href="ChainedReal_8h_source.html#l00021">ChainedReal.h:21</a></div></div>
<div class="ttc" id="aclasslibMesh_1_1VectorValue_html"><div class="ttname"><a href="classlibMesh_1_1VectorValue.html">libMesh::VectorValue</a></div><div class="ttdef"><b>Definition:</b> <a href="Assembly_8h_source.html#l00037">Assembly.h:37</a></div></div>
<div class="ttc" id="anamespaceMetaPhysicL_html_a1c0a19c861d5f7813f7fb6825d8fe146"><div class="ttname"><a href="namespaceMetaPhysicL.html#a1c0a19c861d5f7813f7fb6825d8fe146">MetaPhysicL::raw_value</a></div><div class="ttdeci">auto raw_value(const Eigen::Map&lt; T &gt; &amp;in)</div><div class="ttdef"><b>Definition:</b> <a href="ADReal_8h_source.html#l00073">ADReal.h:73</a></div></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="AutomaticMortarGeneration_8C_source.html#l02164">projectPrimaryNodes()</a>.</p>

</div>
</div>
<a id="a51ac6050a6f320045d286c92bffba156" name="a51ac6050a6f320045d286c92bffba156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51ac6050a6f320045d286c92bffba156">&#9670;&#160;</a></span>projectSecondaryNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AutomaticMortarGeneration::projectSecondaryNodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Project secondary nodes (find xi^(2) values) to the closest points on the primary surface. </p>
<p >Inputs:</p><ul>
<li>The nodal normals values</li>
<li>mesh</li>
<li>nodes_to_primary_elem_map</li>
</ul>
<p >Outputs:</p><ul>
<li>secondary_node_and_elem_to_xi2_primary_elem</li>
</ul>
<p >Defined in the file project_secondary_nodes.C. </p>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01848">1848</a> of file <a class="el" href="AutomaticMortarGeneration_8C_source.html">AutomaticMortarGeneration.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1849</span>{</div>
<div class="line"><span class="lineno"> 1850</span>  <span class="comment">// For each primary/secondary boundary id pair, call the</span></div>
<div class="line"><span class="lineno"> 1851</span>  <span class="comment">// project_secondary_nodes_single_pair() helper function.</span></div>
<div class="line"><span class="lineno"> 1852</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; pr : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a969d4ab038fc8d447e966cd1e1600091">_primary_secondary_subdomain_id_pairs</a>)</div>
<div class="line"><span class="lineno"> 1853</span>    <a class="code hl_function" href="classAutomaticMortarGeneration.html#a8aa99d7524d7b1ae972fe152fd0dc61e">projectSecondaryNodesSinglePair</a>(pr.first, pr.second);</div>
<div class="line"><span class="lineno"> 1854</span>}</div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a8aa99d7524d7b1ae972fe152fd0dc61e"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a8aa99d7524d7b1ae972fe152fd0dc61e">AutomaticMortarGeneration::projectSecondaryNodesSinglePair</a></div><div class="ttdeci">void projectSecondaryNodesSinglePair(SubdomainID lower_dimensional_primary_subdomain_id, SubdomainID lower_dimensional_secondary_subdomain_id)</div><div class="ttdoc">Helper function responsible for projecting secondary nodes onto primary elements for a single primary...</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8C_source.html#l01857">AutomaticMortarGeneration.C:1857</a></div></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="MortarData_8C_source.html#l00160">MortarData::update()</a>.</p>

</div>
</div>
<a id="a8aa99d7524d7b1ae972fe152fd0dc61e" name="a8aa99d7524d7b1ae972fe152fd0dc61e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aa99d7524d7b1ae972fe152fd0dc61e">&#9670;&#160;</a></span>projectSecondaryNodesSinglePair()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AutomaticMortarGeneration::projectSecondaryNodesSinglePair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="AutomaticMortarGeneration_8h.html#afb1ef82fea6170b578d48ad9cd793486">SubdomainID</a>&#160;</td>
          <td class="paramname"><em>lower_dimensional_primary_subdomain_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="AutomaticMortarGeneration_8h.html#afb1ef82fea6170b578d48ad9cd793486">SubdomainID</a>&#160;</td>
          <td class="paramname"><em>lower_dimensional_secondary_subdomain_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function responsible for projecting secondary nodes onto primary elements for a single primary/secondary pair. </p>
<p >Called by the class member AutomaticMortarGeneration::project_secondary_nodes(). </p>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01857">1857</a> of file <a class="el" href="AutomaticMortarGeneration_8C_source.html">AutomaticMortarGeneration.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 1860</span>{</div>
<div class="line"><span class="lineno"> 1861</span>  <span class="comment">// Build the &quot;subdomain&quot; adaptor based KD Tree.</span></div>
<div class="line"><span class="lineno"> 1862</span>  <a class="code hl_class" href="classNanoflannMeshSubdomainAdaptor.html">NanoflannMeshSubdomainAdaptor&lt;3&gt;</a> mesh_adaptor(<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>, lower_dimensional_primary_subdomain_id);</div>
<div class="line"><span class="lineno"> 1863</span>  <a class="code hl_typedef" href="NanoflannMeshAdaptor_8h.html#a3a70df33047194961ce21a0133717038">subdomain_kd_tree_t</a> kd_tree(</div>
<div class="line"><span class="lineno"> 1864</span>      3, mesh_adaptor, nanoflann::KDTreeSingleIndexAdaptorParams(<span class="comment">/*max leaf=*/</span>10));</div>
<div class="line"><span class="lineno"> 1865</span> </div>
<div class="line"><span class="lineno"> 1866</span>  <span class="comment">// Construct the KD tree.</span></div>
<div class="line"><span class="lineno"> 1867</span>  kd_tree.buildIndex();</div>
<div class="line"><span class="lineno"> 1868</span> </div>
<div class="line"><span class="lineno"> 1869</span>  <span class="keywordflow">for</span> (MeshBase::const_element_iterator el = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.active_elements_begin(),</div>
<div class="line"><span class="lineno"> 1870</span>                                        end_el = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.active_elements_end();</div>
<div class="line"><span class="lineno"> 1871</span>       el != end_el;</div>
<div class="line"><span class="lineno"> 1872</span>       ++el)</div>
<div class="line"><span class="lineno"> 1873</span>  {</div>
<div class="line"><span class="lineno"> 1874</span>    <span class="keyword">const</span> Elem * secondary_side_elem = *el;</div>
<div class="line"><span class="lineno"> 1875</span> </div>
<div class="line"><span class="lineno"> 1876</span>    <span class="comment">// If this Elem is not in the current secondary subdomain, go on to the next one.</span></div>
<div class="line"><span class="lineno"> 1877</span>    <span class="keywordflow">if</span> (secondary_side_elem-&gt;subdomain_id() != lower_dimensional_secondary_subdomain_id)</div>
<div class="line"><span class="lineno"> 1878</span>      <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno"> 1879</span> </div>
<div class="line"><span class="lineno"> 1880</span>    <span class="comment">// For each node on the lower-dimensional element, find the nearest</span></div>
<div class="line"><span class="lineno"> 1881</span>    <span class="comment">// node on the primary side using the KDTree, then</span></div>
<div class="line"><span class="lineno"> 1882</span>    <span class="comment">// search in nearby elements for where it projects</span></div>
<div class="line"><span class="lineno"> 1883</span>    <span class="comment">// along the nodal normal direction.</span></div>
<div class="line"><span class="lineno"> 1884</span>    <span class="keywordflow">for</span> (MooseIndex(secondary_side_elem-&gt;n_vertices()) n = 0; n &lt; secondary_side_elem-&gt;n_vertices();</div>
<div class="line"><span class="lineno"> 1885</span>         ++n)</div>
<div class="line"><span class="lineno"> 1886</span>    {</div>
<div class="line"><span class="lineno"> 1887</span>      <span class="keyword">const</span> Node * secondary_node = secondary_side_elem-&gt;node_ptr(n);</div>
<div class="line"><span class="lineno"> 1888</span> </div>
<div class="line"><span class="lineno"> 1889</span>      <span class="comment">// Get the nodal neighbors for secondary_node, so we can check whether we&#39;ve</span></div>
<div class="line"><span class="lineno"> 1890</span>      <span class="comment">// already successfully projected it.</span></div>
<div class="line"><span class="lineno"> 1891</span>      <span class="keyword">const</span> std::vector&lt;const Elem *&gt; &amp; secondary_node_neighbors =</div>
<div class="line"><span class="lineno"> 1892</span>          this-&gt;<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a1ad443aa196d2c81d195b29ddeee1d5e">_nodes_to_secondary_elem_map</a>.at(secondary_node-&gt;id());</div>
<div class="line"><span class="lineno"> 1893</span> </div>
<div class="line"><span class="lineno"> 1894</span>      <span class="comment">// Check whether we&#39;ve already mapped this secondary node</span></div>
<div class="line"><span class="lineno"> 1895</span>      <span class="comment">// successfully for all of its nodal neighbors.</span></div>
<div class="line"><span class="lineno"> 1896</span>      <span class="keywordtype">bool</span> is_mapped = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 1897</span>      <span class="keywordflow">for</span> (MooseIndex(secondary_node_neighbors) snn = 0; snn &lt; secondary_node_neighbors.size();</div>
<div class="line"><span class="lineno"> 1898</span>           ++snn)</div>
<div class="line"><span class="lineno"> 1899</span>      {</div>
<div class="line"><span class="lineno"> 1900</span>        <span class="keyword">auto</span> secondary_key = std::make_pair(secondary_node, secondary_node_neighbors[snn]);</div>
<div class="line"><span class="lineno"> 1901</span>        <span class="keywordflow">if</span> (!<a class="code hl_variable" href="classAutomaticMortarGeneration.html#abb4cc3e3102675e52675a95347ad8e95">_secondary_node_and_elem_to_xi2_primary_elem</a>.count(secondary_key))</div>
<div class="line"><span class="lineno"> 1902</span>        {</div>
<div class="line"><span class="lineno"> 1903</span>          is_mapped = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno"> 1904</span>          <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 1905</span>        }</div>
<div class="line"><span class="lineno"> 1906</span>      }</div>
<div class="line"><span class="lineno"> 1907</span> </div>
<div class="line"><span class="lineno"> 1908</span>      <span class="comment">// Go to the next node if this one has already been mapped.</span></div>
<div class="line"><span class="lineno"> 1909</span>      <span class="keywordflow">if</span> (is_mapped)</div>
<div class="line"><span class="lineno"> 1910</span>        <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno"> 1911</span> </div>
<div class="line"><span class="lineno"> 1912</span>      <span class="comment">// Look up the new nodal normal value in the local storage, error if not found.</span></div>
<div class="line"><span class="lineno"> 1913</span>      Point nodal_normal = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a06fb539aea2e63f3b48a6e1d41a2f568">_secondary_node_to_nodal_normal</a>.at(secondary_node);</div>
<div class="line"><span class="lineno"> 1914</span> </div>
<div class="line"><span class="lineno"> 1915</span>      <span class="comment">// Data structure for performing Nanoflann searches.</span></div>
<div class="line"><span class="lineno"> 1916</span>      std::array&lt;Real, 3&gt; query_pt = {</div>
<div class="line"><span class="lineno"> 1917</span>          {(*secondary_node)(0), (*secondary_node)(1), (*secondary_node)(2)}};</div>
<div class="line"><span class="lineno"> 1918</span> </div>
<div class="line"><span class="lineno"> 1919</span>      <span class="comment">// The number of results we want to get.  We&#39;ll look for a</span></div>
<div class="line"><span class="lineno"> 1920</span>      <span class="comment">// &quot;few&quot; nearest nodes, hopefully that is enough to let us</span></div>
<div class="line"><span class="lineno"> 1921</span>      <span class="comment">// figure out which lower-dimensional Elem on the primary</span></div>
<div class="line"><span class="lineno"> 1922</span>      <span class="comment">// side we are across from.</span></div>
<div class="line"><span class="lineno"> 1923</span>      <span class="keyword">const</span> std::size_t num_results = 3;</div>
<div class="line"><span class="lineno"> 1924</span> </div>
<div class="line"><span class="lineno"> 1925</span>      <span class="comment">// Initialize result_set and do the search.</span></div>
<div class="line"><span class="lineno"> 1926</span>      std::vector&lt;size_t&gt; ret_index(num_results);</div>
<div class="line"><span class="lineno"> 1927</span>      std::vector&lt;Real&gt; out_dist_sqr(num_results);</div>
<div class="line"><span class="lineno"> 1928</span>      nanoflann::KNNResultSet&lt;Real&gt; result_set(num_results);</div>
<div class="line"><span class="lineno"> 1929</span>      result_set.init(&amp;ret_index[0], &amp;out_dist_sqr[0]);</div>
<div class="line"><span class="lineno"> 1930</span>      kd_tree.findNeighbors(result_set, &amp;query_pt[0], <a class="code hl_typedef" href="namespacenanoflann.html#a7475277cf1d06434e352ade6f35de645">nanoflann::SearchParameters</a>());</div>
<div class="line"><span class="lineno"> 1931</span> </div>
<div class="line"><span class="lineno"> 1932</span>      <span class="comment">// If this flag gets set in the loop below, we can break out of the outer r-loop as well.</span></div>
<div class="line"><span class="lineno"> 1933</span>      <span class="keywordtype">bool</span> projection_succeeded = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno"> 1934</span> </div>
<div class="line"><span class="lineno"> 1935</span>      <span class="comment">// Once we&#39;ve rejected a candidate for a given secondary_node,</span></div>
<div class="line"><span class="lineno"> 1936</span>      <span class="comment">// there&#39;s no reason to check it again.</span></div>
<div class="line"><span class="lineno"> 1937</span>      std::set&lt;const Elem *&gt; rejected_primary_elem_candidates;</div>
<div class="line"><span class="lineno"> 1938</span> </div>
<div class="line"><span class="lineno"> 1939</span>      <span class="comment">// Loop over the closest nodes, check whether</span></div>
<div class="line"><span class="lineno"> 1940</span>      <span class="comment">// the secondary node successfully projects into</span></div>
<div class="line"><span class="lineno"> 1941</span>      <span class="comment">// either of the closest neighbors, stop when</span></div>
<div class="line"><span class="lineno"> 1942</span>      <span class="comment">// the projection succeeds.</span></div>
<div class="line"><span class="lineno"> 1943</span>      <span class="keywordflow">for</span> (MooseIndex(result_set) r = 0; r &lt; result_set.size(); ++r)</div>
<div class="line"><span class="lineno"> 1944</span>      {</div>
<div class="line"><span class="lineno"> 1945</span>        <span class="comment">// Verify that the squared distance we compute is the same as nanoflann&#39;sFss</span></div>
<div class="line"><span class="lineno"> 1946</span>        mooseAssert(std::abs((<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.point(ret_index[r]) - *secondary_node).norm_sq() -</div>
<div class="line"><span class="lineno"> 1947</span>                             out_dist_sqr[r]) &lt;= TOLERANCE,</div>
<div class="line"><span class="lineno"> 1948</span>                    <span class="stringliteral">&quot;Lower-dimensional element squared distance verification failed.&quot;</span>);</div>
<div class="line"><span class="lineno"> 1949</span> </div>
<div class="line"><span class="lineno"> 1950</span>        <span class="comment">// Get a reference to the vector of lower dimensional elements from the</span></div>
<div class="line"><span class="lineno"> 1951</span>        <span class="comment">// nodes_to_primary_elem_map.</span></div>
<div class="line"><span class="lineno"> 1952</span>        std::vector&lt;const Elem *&gt; &amp; primary_elem_candidates =</div>
<div class="line"><span class="lineno"> 1953</span>            this-&gt;<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a1ee9b6e4f8bd88603e22117085758f70">_nodes_to_primary_elem_map</a>.at(<span class="keyword">static_cast&lt;</span>dof_id_type<span class="keyword">&gt;</span>(ret_index[r]));</div>
<div class="line"><span class="lineno"> 1954</span> </div>
<div class="line"><span class="lineno"> 1955</span>        <span class="comment">// Search the Elems connected to this node on the primary mesh side.</span></div>
<div class="line"><span class="lineno"> 1956</span>        <span class="keywordflow">for</span> (MooseIndex(primary_elem_candidates) e = 0; e &lt; primary_elem_candidates.size(); ++e)</div>
<div class="line"><span class="lineno"> 1957</span>        {</div>
<div class="line"><span class="lineno"> 1958</span>          <span class="keyword">const</span> Elem * primary_elem_candidate = primary_elem_candidates[e];</div>
<div class="line"><span class="lineno"> 1959</span> </div>
<div class="line"><span class="lineno"> 1960</span>          <span class="comment">// If we&#39;ve already rejected this candidate, we don&#39;t need to check it again.</span></div>
<div class="line"><span class="lineno"> 1961</span>          <span class="keywordflow">if</span> (rejected_primary_elem_candidates.count(primary_elem_candidate))</div>
<div class="line"><span class="lineno"> 1962</span>            <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno"> 1963</span> </div>
<div class="line"><span class="lineno"> 1964</span>          <span class="comment">// Now generically solve for xi2</span></div>
<div class="line"><span class="lineno"> 1965</span>          <span class="keyword">auto</span> &amp;&amp; order = primary_elem_candidate-&gt;default_order();</div>
<div class="line"><span class="lineno"> 1966</span>          <a class="code hl_class" href="classMetaPhysicL_1_1DualNumber.html">DualNumber&lt;Real&gt;</a> xi2_dn{0, 1};</div>
<div class="line"><span class="lineno"> 1967</span>          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> current_iterate = 0, max_iterates = 10;</div>
<div class="line"><span class="lineno"> 1968</span> </div>
<div class="line"><span class="lineno"> 1969</span>          <span class="comment">// Newton loop</span></div>
<div class="line"><span class="lineno"> 1970</span>          <span class="keywordflow">do</span></div>
<div class="line"><span class="lineno"> 1971</span>          {</div>
<div class="line"><span class="lineno"> 1972</span>            <a class="code hl_class" href="classlibMesh_1_1VectorValue.html">VectorValue&lt;DualNumber&lt;Real&gt;</a>&gt; x2(0);</div>
<div class="line"><span class="lineno"> 1973</span>            <span class="keywordflow">for</span> (MooseIndex(primary_elem_candidate-&gt;n_nodes()) n = 0;</div>
<div class="line"><span class="lineno"> 1974</span>                 n &lt; primary_elem_candidate-&gt;n_nodes();</div>
<div class="line"><span class="lineno"> 1975</span>                 ++n)</div>
<div class="line"><span class="lineno"> 1976</span>              x2 +=</div>
<div class="line"><span class="lineno"> 1977</span>                  <a class="code hl_function" href="namespaceMoose.html#a9ed3373b5072c07f1f010afb75ac20c9">Moose::fe_lagrange_1D_shape</a>(order, n, xi2_dn) * primary_elem_candidate-&gt;point(n);</div>
<div class="line"><span class="lineno"> 1978</span>            <span class="keyword">const</span> <span class="keyword">auto</span> u = x2 - (*secondary_node);</div>
<div class="line"><span class="lineno"> 1979</span>            <span class="keyword">const</span> <span class="keyword">auto</span> F = u(0) * nodal_normal(1) - u(1) * nodal_normal(0);</div>
<div class="line"><span class="lineno"> 1980</span> </div>
<div class="line"><span class="lineno"> 1981</span>            <span class="keywordflow">if</span> (std::abs(F) &lt; <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a04e775677691747d25e1a5f05496fa5a">_newton_tolerance</a>)</div>
<div class="line"><span class="lineno"> 1982</span>              <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno"> 1983</span> </div>
<div class="line"><span class="lineno"> 1984</span>            <span class="keywordflow">if</span> (F.derivatives())</div>
<div class="line"><span class="lineno"> 1985</span>            {</div>
<div class="line"><span class="lineno"> 1986</span>              Real dxi2 = -F.value() / F.derivatives();</div>
<div class="line"><span class="lineno"> 1987</span> </div>
<div class="line"><span class="lineno"> 1988</span>              xi2_dn += dxi2;</div>
<div class="line"><span class="lineno"> 1989</span>            }</div>
<div class="line"><span class="lineno"> 1990</span>            <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno"> 1991</span>              <span class="comment">// It&#39;s possible that the secondary surface nodal normal is completely orthogonal to</span></div>
<div class="line"><span class="lineno"> 1992</span>              <span class="comment">// the primary surface normal, in which case the derivative is 0. We know in this case</span></div>
<div class="line"><span class="lineno"> 1993</span>              <span class="comment">// that the projection should be a failure</span></div>
<div class="line"><span class="lineno"> 1994</span>              current_iterate = max_iterates;</div>
<div class="line"><span class="lineno"> 1995</span>          } <span class="keywordflow">while</span> (++current_iterate &lt; max_iterates);</div>
<div class="line"><span class="lineno"> 1996</span> </div>
<div class="line"><span class="lineno"> 1997</span>          Real xi2 = xi2_dn.value();</div>
<div class="line"><span class="lineno"> 1998</span> </div>
<div class="line"><span class="lineno"> 1999</span>          <span class="comment">// Check whether the projection worked. The last condition checks for obliqueness of the</span></div>
<div class="line"><span class="lineno"> 2000</span>          <span class="comment">// projection</span></div>
<div class="line"><span class="lineno"> 2001</span>          <span class="keywordflow">if</span> ((current_iterate &lt; max_iterates) &amp;&amp; (std::abs(xi2) &lt;= 1. + <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a25f6f147b1b0a4b00e7c6739dd17b98c">_xi_tolerance</a>) &amp;&amp;</div>
<div class="line"><span class="lineno"> 2002</span>              (std::abs(</div>
<div class="line"><span class="lineno"> 2003</span>                   (primary_elem_candidate-&gt;point(0) - primary_elem_candidate-&gt;point(1)).unit() *</div>
<div class="line"><span class="lineno"> 2004</span>                   nodal_normal) &lt; std::cos(<a class="code hl_variable" href="classAutomaticMortarGeneration.html#af5ca257dd4090b3a8d801a439dcae0ca">_minimum_projection_angle</a> * libMesh::pi / 180)))</div>
<div class="line"><span class="lineno"> 2005</span>          {</div>
<div class="line"><span class="lineno"> 2006</span>            <span class="comment">// If xi2 == +1 or -1 then this secondary node mapped directly to a node on the primary</span></div>
<div class="line"><span class="lineno"> 2007</span>            <span class="comment">// surface. This isn&#39;t as unlikely as you might think, it will happen if the meshes</span></div>
<div class="line"><span class="lineno"> 2008</span>            <span class="comment">// on the interface start off being perfectly aligned. In this situation, we need to</span></div>
<div class="line"><span class="lineno"> 2009</span>            <span class="comment">// associate the secondary node with two different elements (and two corresponding</span></div>
<div class="line"><span class="lineno"> 2010</span>            <span class="comment">// xi^(2) values.</span></div>
<div class="line"><span class="lineno"> 2011</span> </div>
<div class="line"><span class="lineno"> 2012</span>            <span class="comment">// We are projecting on one side first and the other side second. If we make the</span></div>
<div class="line"><span class="lineno"> 2013</span>            <span class="comment">// tolerance bigger and remove the (5) factor we are going to continue to miss the</span></div>
<div class="line"><span class="lineno"> 2014</span>            <span class="comment">// second projection and fall into the exception message in</span></div>
<div class="line"><span class="lineno"> 2015</span>            <span class="comment">// projectPrimaryNodesSinglePair. What makes this modification to not fall in the</span></div>
<div class="line"><span class="lineno"> 2016</span>            <span class="comment">// exception is that we are projecting on one side more xi than in the other. There</span></div>
<div class="line"><span class="lineno"> 2017</span>            <span class="comment">// should be a better way of doing this by using actual distances and not parametric</span></div>
<div class="line"><span class="lineno"> 2018</span>            <span class="comment">// coordinates. But I believe making the tolerance uniformly larger or smaller won&#39;t do</span></div>
<div class="line"><span class="lineno"> 2019</span>            <span class="comment">// the trick here.</span></div>
<div class="line"><span class="lineno"> 2020</span>            <span class="keywordflow">if</span> (std::abs(std::abs(xi2) - 1.) &lt; <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a25f6f147b1b0a4b00e7c6739dd17b98c">_xi_tolerance</a> * 5.0)</div>
<div class="line"><span class="lineno"> 2021</span>            {</div>
<div class="line"><span class="lineno"> 2022</span>              <span class="keyword">const</span> Node * primary_node = (xi2 &lt; 0) ? primary_elem_candidate-&gt;node_ptr(0)</div>
<div class="line"><span class="lineno"> 2023</span>                                                    : primary_elem_candidate-&gt;node_ptr(1);</div>
<div class="line"><span class="lineno"> 2024</span> </div>
<div class="line"><span class="lineno"> 2025</span>              <span class="keyword">const</span> std::vector&lt;const Elem *&gt; &amp; primary_node_neighbors =</div>
<div class="line"><span class="lineno"> 2026</span>                  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a1ee9b6e4f8bd88603e22117085758f70">_nodes_to_primary_elem_map</a>.at(primary_node-&gt;id());</div>
<div class="line"><span class="lineno"> 2027</span> </div>
<div class="line"><span class="lineno"> 2028</span>              std::vector&lt;bool&gt; primary_elems_mapped(primary_node_neighbors.size(), <span class="keyword">false</span>);</div>
<div class="line"><span class="lineno"> 2029</span> </div>
<div class="line"><span class="lineno"> 2030</span>              <span class="comment">// Add entries to secondary_node_and_elem_to_xi2_primary_elem container.</span></div>
<div class="line"><span class="lineno"> 2031</span>              <span class="comment">//</span></div>
<div class="line"><span class="lineno"> 2032</span>              <span class="comment">// First, determine &quot;on left&quot; vs. &quot;on right&quot; orientation of the nodal neighbors.</span></div>
<div class="line"><span class="lineno"> 2033</span>              <span class="comment">// There can be a max of 2 nodal neighbors, and we want to make sure that the</span></div>
<div class="line"><span class="lineno"> 2034</span>              <span class="comment">// secondary nodal neighbor on the &quot;left&quot; is associated with the primary nodal</span></div>
<div class="line"><span class="lineno"> 2035</span>              <span class="comment">// neighbor on the &quot;left&quot; and similarly for the &quot;right&quot;.</span></div>
<div class="line"><span class="lineno"> 2036</span>              std::vector&lt;Real&gt; secondary_node_neighbor_cps(2), primary_node_neighbor_cps(2);</div>
<div class="line"><span class="lineno"> 2037</span> </div>
<div class="line"><span class="lineno"> 2038</span>              <span class="comment">// Figure out which secondary side neighbor is on the &quot;left&quot; and which is on the</span></div>
<div class="line"><span class="lineno"> 2039</span>              <span class="comment">// &quot;right&quot;.</span></div>
<div class="line"><span class="lineno"> 2040</span>              <span class="keywordflow">for</span> (MooseIndex(secondary_node_neighbors) nn = 0;</div>
<div class="line"><span class="lineno"> 2041</span>                   nn &lt; secondary_node_neighbors.size();</div>
<div class="line"><span class="lineno"> 2042</span>                   ++nn)</div>
<div class="line"><span class="lineno"> 2043</span>              {</div>
<div class="line"><span class="lineno"> 2044</span>                <span class="keyword">const</span> Elem * secondary_neigh = secondary_node_neighbors[nn];</div>
<div class="line"><span class="lineno"> 2045</span>                Point opposite = (secondary_neigh-&gt;node_ptr(0) == secondary_node)</div>
<div class="line"><span class="lineno"> 2046</span>                                     ? secondary_neigh-&gt;point(1)</div>
<div class="line"><span class="lineno"> 2047</span>                                     : secondary_neigh-&gt;point(0);</div>
<div class="line"><span class="lineno"> 2048</span>                Point cp = nodal_normal.cross(opposite - *secondary_node);</div>
<div class="line"><span class="lineno"> 2049</span>                secondary_node_neighbor_cps[nn] = cp(2);</div>
<div class="line"><span class="lineno"> 2050</span>              }</div>
<div class="line"><span class="lineno"> 2051</span> </div>
<div class="line"><span class="lineno"> 2052</span>              <span class="comment">// Figure out which primary side neighbor is on the &quot;left&quot; and which is on the</span></div>
<div class="line"><span class="lineno"> 2053</span>              <span class="comment">// &quot;right&quot;.</span></div>
<div class="line"><span class="lineno"> 2054</span>              <span class="keywordflow">for</span> (MooseIndex(primary_node_neighbors) nn = 0; nn &lt; primary_node_neighbors.size();</div>
<div class="line"><span class="lineno"> 2055</span>                   ++nn)</div>
<div class="line"><span class="lineno"> 2056</span>              {</div>
<div class="line"><span class="lineno"> 2057</span>                <span class="keyword">const</span> Elem * primary_neigh = primary_node_neighbors[nn];</div>
<div class="line"><span class="lineno"> 2058</span>                Point opposite = (primary_neigh-&gt;node_ptr(0) == primary_node)</div>
<div class="line"><span class="lineno"> 2059</span>                                     ? primary_neigh-&gt;point(1)</div>
<div class="line"><span class="lineno"> 2060</span>                                     : primary_neigh-&gt;point(0);</div>
<div class="line"><span class="lineno"> 2061</span>                Point cp = nodal_normal.cross(opposite - *secondary_node);</div>
<div class="line"><span class="lineno"> 2062</span>                primary_node_neighbor_cps[nn] = cp(2);</div>
<div class="line"><span class="lineno"> 2063</span>              }</div>
<div class="line"><span class="lineno"> 2064</span> </div>
<div class="line"><span class="lineno"> 2065</span>              <span class="comment">// Associate secondary/primary elems on matching sides.</span></div>
<div class="line"><span class="lineno"> 2066</span>              <span class="keywordtype">bool</span> found_match = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno"> 2067</span>              <span class="keywordflow">for</span> (MooseIndex(secondary_node_neighbors) snn = 0;</div>
<div class="line"><span class="lineno"> 2068</span>                   snn &lt; secondary_node_neighbors.size();</div>
<div class="line"><span class="lineno"> 2069</span>                   ++snn)</div>
<div class="line"><span class="lineno"> 2070</span>                <span class="keywordflow">for</span> (MooseIndex(primary_node_neighbors) mnn = 0;</div>
<div class="line"><span class="lineno"> 2071</span>                     mnn &lt; primary_node_neighbors.size();</div>
<div class="line"><span class="lineno"> 2072</span>                     ++mnn)</div>
<div class="line"><span class="lineno"> 2073</span>                  <span class="keywordflow">if</span> (secondary_node_neighbor_cps[snn] * primary_node_neighbor_cps[mnn] &gt; 0)</div>
<div class="line"><span class="lineno"> 2074</span>                  {</div>
<div class="line"><span class="lineno"> 2075</span>                    found_match = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 2076</span>                    primary_elems_mapped[mnn] = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 2077</span> </div>
<div class="line"><span class="lineno"> 2078</span>                    <span class="comment">// Figure out xi^(2) value by looking at which node primary_node is</span></div>
<div class="line"><span class="lineno"> 2079</span>                    <span class="comment">// of the current primary node neighbor.</span></div>
<div class="line"><span class="lineno"> 2080</span>                    Real xi2 = (primary_node == primary_node_neighbors[mnn]-&gt;node_ptr(0)) ? -1 : +1;</div>
<div class="line"><span class="lineno"> 2081</span>                    <span class="keyword">auto</span> secondary_key =</div>
<div class="line"><span class="lineno"> 2082</span>                        std::make_pair(secondary_node, secondary_node_neighbors[snn]);</div>
<div class="line"><span class="lineno"> 2083</span>                    <span class="keyword">auto</span> primary_val = std::make_pair(xi2, primary_node_neighbors[mnn]);</div>
<div class="line"><span class="lineno"> 2084</span>                    <a class="code hl_variable" href="classAutomaticMortarGeneration.html#abb4cc3e3102675e52675a95347ad8e95">_secondary_node_and_elem_to_xi2_primary_elem</a>.emplace(secondary_key,</div>
<div class="line"><span class="lineno"> 2085</span>                                                                         primary_val);</div>
<div class="line"><span class="lineno"> 2086</span> </div>
<div class="line"><span class="lineno"> 2087</span>                    <span class="comment">// Also map in the other direction.</span></div>
<div class="line"><span class="lineno"> 2088</span>                    Real xi1 =</div>
<div class="line"><span class="lineno"> 2089</span>                        (secondary_node == secondary_node_neighbors[snn]-&gt;node_ptr(0)) ? -1 : +1;</div>
<div class="line"><span class="lineno"> 2090</span> </div>
<div class="line"><span class="lineno"> 2091</span>                    <span class="keyword">auto</span> primary_key = std::make_tuple(</div>
<div class="line"><span class="lineno"> 2092</span>                        primary_node-&gt;id(), primary_node, primary_node_neighbors[mnn]);</div>
<div class="line"><span class="lineno"> 2093</span>                    <span class="keyword">auto</span> secondary_val = std::make_pair(xi1, secondary_node_neighbors[snn]);</div>
<div class="line"><span class="lineno"> 2094</span>                    <a class="code hl_variable" href="classAutomaticMortarGeneration.html#ac174eedb02e9681baf439360903700d4">_primary_node_and_elem_to_xi1_secondary_elem</a>.emplace(primary_key,</div>
<div class="line"><span class="lineno"> 2095</span>                                                                         secondary_val);</div>
<div class="line"><span class="lineno"> 2096</span>                  }</div>
<div class="line"><span class="lineno"> 2097</span> </div>
<div class="line"><span class="lineno"> 2098</span>              <span class="keywordflow">if</span> (!found_match)</div>
<div class="line"><span class="lineno"> 2099</span>              {</div>
<div class="line"><span class="lineno"> 2100</span>                <span class="comment">// There could be coincident nodes and this might be a bad primary candidate (see</span></div>
<div class="line"><span class="lineno"> 2101</span>                <span class="comment">// issue #21680). Instead of giving up, let&#39;s try continuing</span></div>
<div class="line"><span class="lineno"> 2102</span>                rejected_primary_elem_candidates.insert(primary_elem_candidate);</div>
<div class="line"><span class="lineno"> 2103</span>                <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno"> 2104</span>              }</div>
<div class="line"><span class="lineno"> 2105</span> </div>
<div class="line"><span class="lineno"> 2106</span>              <span class="comment">// We need to handle the case where we&#39;ve exactly projected a secondary node onto a</span></div>
<div class="line"><span class="lineno"> 2107</span>              <span class="comment">// primary node, but our secondary node is at one of the secondary face endpoints and</span></div>
<div class="line"><span class="lineno"> 2108</span>              <span class="comment">// our primary node is not.</span></div>
<div class="line"><span class="lineno"> 2109</span>              <span class="keywordflow">if</span> (secondary_node_neighbors.size() == 1 &amp;&amp; primary_node_neighbors.size() == 2)</div>
<div class="line"><span class="lineno"> 2110</span>                <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = primary_elems_mapped.begin(); it != primary_elems_mapped.end(); ++it)</div>
<div class="line"><span class="lineno"> 2111</span>                  <span class="keywordflow">if</span> (*it == <span class="keyword">false</span>)</div>
<div class="line"><span class="lineno"> 2112</span>                  {</div>
<div class="line"><span class="lineno"> 2113</span>                    <span class="keyword">auto</span> index = std::distance(primary_elems_mapped.begin(), it);</div>
<div class="line"><span class="lineno"> 2114</span>                    <a class="code hl_variable" href="classAutomaticMortarGeneration.html#ac174eedb02e9681baf439360903700d4">_primary_node_and_elem_to_xi1_secondary_elem</a>.emplace(</div>
<div class="line"><span class="lineno"> 2115</span>                        std::make_tuple(</div>
<div class="line"><span class="lineno"> 2116</span>                            primary_node-&gt;id(), primary_node, primary_node_neighbors[index]),</div>
<div class="line"><span class="lineno"> 2117</span>                        std::make_pair(1, <span class="keyword">nullptr</span>));</div>
<div class="line"><span class="lineno"> 2118</span>                  }</div>
<div class="line"><span class="lineno"> 2119</span>            }</div>
<div class="line"><span class="lineno"> 2120</span>            <span class="keywordflow">else</span> <span class="comment">// Point falls somewhere in the middle of the Elem.</span></div>
<div class="line"><span class="lineno"> 2121</span>            {</div>
<div class="line"><span class="lineno"> 2122</span>              <span class="comment">// Add two entries to secondary_node_and_elem_to_xi2_primary_elem.</span></div>
<div class="line"><span class="lineno"> 2123</span>              <span class="keywordflow">for</span> (MooseIndex(secondary_node_neighbors) nn = 0;</div>
<div class="line"><span class="lineno"> 2124</span>                   nn &lt; secondary_node_neighbors.size();</div>
<div class="line"><span class="lineno"> 2125</span>                   ++nn)</div>
<div class="line"><span class="lineno"> 2126</span>              {</div>
<div class="line"><span class="lineno"> 2127</span>                <span class="keyword">const</span> Elem * neigh = secondary_node_neighbors[nn];</div>
<div class="line"><span class="lineno"> 2128</span>                <span class="keywordflow">for</span> (MooseIndex(neigh-&gt;n_vertices()) nid = 0; nid &lt; neigh-&gt;n_vertices(); ++nid)</div>
<div class="line"><span class="lineno"> 2129</span>                {</div>
<div class="line"><span class="lineno"> 2130</span>                  <span class="keyword">const</span> Node * neigh_node = neigh-&gt;node_ptr(nid);</div>
<div class="line"><span class="lineno"> 2131</span>                  <span class="keywordflow">if</span> (secondary_node == neigh_node)</div>
<div class="line"><span class="lineno"> 2132</span>                  {</div>
<div class="line"><span class="lineno"> 2133</span>                    <span class="keyword">auto</span> key = std::make_pair(neigh_node, neigh);</div>
<div class="line"><span class="lineno"> 2134</span>                    <span class="keyword">auto</span> val = std::make_pair(xi2, primary_elem_candidate);</div>
<div class="line"><span class="lineno"> 2135</span>                    <a class="code hl_variable" href="classAutomaticMortarGeneration.html#abb4cc3e3102675e52675a95347ad8e95">_secondary_node_and_elem_to_xi2_primary_elem</a>.emplace(key, val);</div>
<div class="line"><span class="lineno"> 2136</span>                  }</div>
<div class="line"><span class="lineno"> 2137</span>                }</div>
<div class="line"><span class="lineno"> 2138</span>              }</div>
<div class="line"><span class="lineno"> 2139</span>            }</div>
<div class="line"><span class="lineno"> 2140</span> </div>
<div class="line"><span class="lineno"> 2141</span>            projection_succeeded = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno"> 2142</span>            <span class="keywordflow">break</span>; <span class="comment">// out of e-loop</span></div>
<div class="line"><span class="lineno"> 2143</span>          }</div>
<div class="line"><span class="lineno"> 2144</span>          <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno"> 2145</span>            <span class="comment">// The current secondary_node is not in this Elem, so keep track of the rejects.</span></div>
<div class="line"><span class="lineno"> 2146</span>            rejected_primary_elem_candidates.insert(primary_elem_candidate);</div>
<div class="line"><span class="lineno"> 2147</span>        }</div>
<div class="line"><span class="lineno"> 2148</span> </div>
<div class="line"><span class="lineno"> 2149</span>        <span class="keywordflow">if</span> (projection_succeeded)</div>
<div class="line"><span class="lineno"> 2150</span>          <span class="keywordflow">break</span>; <span class="comment">// out of r-loop</span></div>
<div class="line"><span class="lineno"> 2151</span>      }          <span class="comment">// r-loop</span></div>
<div class="line"><span class="lineno"> 2152</span> </div>
<div class="line"><span class="lineno"> 2153</span>      <span class="keywordflow">if</span> (!projection_succeeded &amp;&amp; <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a958de5b754ec676f463c50d2f16b5d0c">_debug</a>)</div>
<div class="line"><span class="lineno"> 2154</span>        <a class="code hl_variable" href="classConsoleStreamInterface.html#acd1f259e7a3d200223164c08af3a7c13">_console</a> &lt;&lt; <span class="stringliteral">&quot;Failed to find primary Elem into which secondary node &quot;</span></div>
<div class="line"><span class="lineno"> 2155</span>                 &lt;&lt; <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>Point &amp;<span class="keyword">&gt;</span>(*secondary_node) &lt;&lt; <span class="stringliteral">&quot; was projected.&quot;</span> &lt;&lt; std::endl</div>
<div class="line"><span class="lineno"> 2156</span>                 &lt;&lt; std::endl;</div>
<div class="line"><span class="lineno"> 2157</span>    } <span class="comment">// loop over side nodes</span></div>
<div class="line"><span class="lineno"> 2158</span>  }   <span class="comment">// end loop over lower-dimensional elements</span></div>
<div class="line"><span class="lineno"> 2159</span>}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01848">projectSecondaryNodes()</a>.</p>

</div>
</div>
<a id="af11d3acd4a241fb531e4fa9ef227f469" name="af11d3acd4a241fb531e4fa9ef227f469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af11d3acd4a241fb531e4fa9ef227f469">&#9670;&#160;</a></span>secondariesToMortarSegments() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::unordered_map&lt; dof_id_type, std::set&lt; Elem *, CompareDofObjectsByID &gt; &gt; &amp; AutomaticMortarGeneration::secondariesToMortarSegments </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the lower dimensional secondary element ids and their associated mortar segment elements </dd></dl>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00315">315</a> of file <a class="el" href="AutomaticMortarGeneration_8h_source.html">AutomaticMortarGeneration.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  316</span>  {</div>
<div class="line"><span class="lineno">  317</span>    <span class="keywordflow">return</span> <a class="code hl_variable" href="classAutomaticMortarGeneration.html#af0da3b7d9e404238718805e12452d74d">_secondary_elems_to_mortar_segments</a>;</div>
<div class="line"><span class="lineno">  318</span>  }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3b69cbfeaf6799a4094c8ca1676759d6" name="a3b69cbfeaf6799a4094c8ca1676759d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b69cbfeaf6799a4094c8ca1676759d6">&#9670;&#160;</a></span>secondariesToMortarSegments() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classAutomaticMortarGeneration.html#a25ec95581c8e81806bd24643af800bbd">AutomaticMortarGeneration::MortarFilterIter</a> &gt; AutomaticMortarGeneration::secondariesToMortarSegments </td>
          <td>(</td>
          <td class="paramtype">const Node &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A vector of iterators that point to the lower dimensional secondary elements and their associated mortar segment elements that would have nonzero values for a Lagrange shape function associated with the provided node. This method may return an empty container if the node is away from the mortar mesh </dd></dl>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8C_source.html#l02377">2377</a> of file <a class="el" href="AutomaticMortarGeneration_8C_source.html">AutomaticMortarGeneration.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno"> 2378</span>{</div>
<div class="line"><span class="lineno"> 2379</span>  <span class="keyword">auto</span> secondary_it = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a1ad443aa196d2c81d195b29ddeee1d5e">_nodes_to_secondary_elem_map</a>.find(node.id());</div>
<div class="line"><span class="lineno"> 2380</span>  <span class="keywordflow">if</span> (secondary_it == <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a1ad443aa196d2c81d195b29ddeee1d5e">_nodes_to_secondary_elem_map</a>.end())</div>
<div class="line"><span class="lineno"> 2381</span>    <span class="keywordflow">return</span> {};</div>
<div class="line"><span class="lineno"> 2382</span> </div>
<div class="line"><span class="lineno"> 2383</span>  <span class="keyword">const</span> <span class="keyword">auto</span> &amp; secondary_elems = secondary_it-&gt;second;</div>
<div class="line"><span class="lineno"> 2384</span>  std::vector&lt;MortarFilterIter&gt; ret;</div>
<div class="line"><span class="lineno"> 2385</span>  ret.reserve(secondary_elems.size());</div>
<div class="line"><span class="lineno"> 2386</span> </div>
<div class="line"><span class="lineno"> 2387</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : index_range(secondary_elems))</div>
<div class="line"><span class="lineno"> 2388</span>  {</div>
<div class="line"><span class="lineno"> 2389</span>    <span class="keyword">auto</span> * <span class="keyword">const</span> secondary_elem = secondary_elems[i];</div>
<div class="line"><span class="lineno"> 2390</span>    <span class="keyword">auto</span> msm_it = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#af0da3b7d9e404238718805e12452d74d">_secondary_elems_to_mortar_segments</a>.find(secondary_elem-&gt;id());</div>
<div class="line"><span class="lineno"> 2391</span>    <span class="keywordflow">if</span> (msm_it == <a class="code hl_variable" href="classAutomaticMortarGeneration.html#af0da3b7d9e404238718805e12452d74d">_secondary_elems_to_mortar_segments</a>.end())</div>
<div class="line"><span class="lineno"> 2392</span>      <span class="comment">// We may have removed this element key from this map</span></div>
<div class="line"><span class="lineno"> 2393</span>      <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno"> 2394</span> </div>
<div class="line"><span class="lineno"> 2395</span>    mooseAssert(secondary_elem-&gt;active(),</div>
<div class="line"><span class="lineno"> 2396</span>                <span class="stringliteral">&quot;We loop over active elements when building the mortar segment mesh, so we golly &quot;</span></div>
<div class="line"><span class="lineno"> 2397</span>                <span class="stringliteral">&quot;well hope this is active.&quot;</span>);</div>
<div class="line"><span class="lineno"> 2398</span>    mooseAssert(!msm_it-&gt;second.empty(),</div>
<div class="line"><span class="lineno"> 2399</span>                <span class="stringliteral">&quot;We should have removed all secondaries from this map if they do not have any &quot;</span></div>
<div class="line"><span class="lineno"> 2400</span>                <span class="stringliteral">&quot;mortar segments associated with them.&quot;</span>);</div>
<div class="line"><span class="lineno"> 2401</span>    ret.push_back(msm_it);</div>
<div class="line"><span class="lineno"> 2402</span>  }</div>
<div class="line"><span class="lineno"> 2403</span> </div>
<div class="line"><span class="lineno"> 2404</span>  <span class="keywordflow">return</span> ret;</div>
<div class="line"><span class="lineno"> 2405</span>}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="MortarUserObjectThread_8C_source.html#l00051">MortarUserObjectThread::operator()()</a>, and <a class="el" href="ComputeMortarFunctor_8C_source.html#l00054">ComputeMortarFunctor::operator()()</a>.</p>

</div>
</div>
<a id="a948e97177233f154ff53976dcd7a367c" name="a948e97177233f154ff53976dcd7a367c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a948e97177233f154ff53976dcd7a367c">&#9670;&#160;</a></span>secondaryIPSubIDs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::set&lt; <a class="el" href="AutomaticMortarGeneration_8h.html#afb1ef82fea6170b578d48ad9cd793486">SubdomainID</a> &gt; &amp; AutomaticMortarGeneration::secondaryIPSubIDs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>All the secondary interior parent subdomain IDs associated with the mortar mesh </dd></dl>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00323">323</a> of file <a class="el" href="AutomaticMortarGeneration_8h_source.html">AutomaticMortarGeneration.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  323</span>{ <span class="keywordflow">return</span> <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a7254faea651acd63b60b408ab560a0e5">_secondary_ip_sub_ids</a>; }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="MortarUtils_8h_source.html#l00326">Moose::Mortar::setupMortarMaterials()</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a1a702fe0b6991a787d7257f8263a618b" name="a1a702fe0b6991a787d7257f8263a618b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a702fe0b6991a787d7257f8263a618b">&#9670;&#160;</a></span>AugmentSparsityOnInterface</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classAugmentSparsityOnInterface.html">AugmentSparsityOnInterface</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00511">511</a> of file <a class="el" href="AutomaticMortarGeneration_8h_source.html">AutomaticMortarGeneration.h</a>.</p>

</div>
</div>
<a id="abfa0eb2fcdd908fd95d33c4818f08855" name="abfa0eb2fcdd908fd95d33c4818f08855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfa0eb2fcdd908fd95d33c4818f08855">&#9670;&#160;</a></span>MortarNodalGeometryOutput</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classMortarNodalGeometryOutput.html">MortarNodalGeometryOutput</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00510">510</a> of file <a class="el" href="AutomaticMortarGeneration_8h_source.html">AutomaticMortarGeneration.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aaad114f9251de54152c04ef277441578" name="aaad114f9251de54152c04ef277441578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad114f9251de54152c04ef277441578">&#9670;&#160;</a></span>_app</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMooseApp.html">MooseApp</a>&amp; AutomaticMortarGeneration::_app</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The <a class="el" href="namespaceMoose.html" title="MOOSE now contains C++17 code, so give a reasonable error message stating what the user can do to add...">Moose</a> app. </p>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00350">350</a> of file <a class="el" href="AutomaticMortarGeneration_8h_source.html">AutomaticMortarGeneration.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00247">initOutput()</a>.</p>

</div>
</div>
<a id="acd1f259e7a3d200223164c08af3a7c13" name="acd1f259e7a3d200223164c08af3a7c13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd1f259e7a3d200223164c08af3a7c13">&#9670;&#160;</a></span>_console</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classConsoleStream.html">ConsoleStream</a> ConsoleStreamInterface::_console</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An instance of helper class to write streams to the <a class="el" href="classConsole.html" title="An output object for writing to the console (screen)">Console</a> objects. </p>

<p class="definition">Definition at line <a class="el" href="ConsoleStreamInterface_8h_source.html#l00031">31</a> of file <a class="el" href="ConsoleStreamInterface_8h_source.html">ConsoleStreamInterface.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="IterationAdaptiveDT_8C_source.html#l00550">IterationAdaptiveDT::acceptStep()</a>, <a class="el" href="MaterialOutputAction_8C_source.html#l00077">MaterialOutputAction::act()</a>, <a class="el" href="MeshOnlyAction_8C_source.html#l00035">MeshOnlyAction::act()</a>, <a class="el" href="SetupDebugAction_8C_source.html#l00077">SetupDebugAction::act()</a>, <a class="el" href="FEProblemBase_8C_source.html#l07125">FEProblemBase::adaptMesh()</a>, <a class="el" href="Adaptivity_8C_source.html#l00123">Adaptivity::adaptMesh()</a>, <a class="el" href="PerfGraph_8C_source.html#l00150">PerfGraph::addToExecutionList()</a>, <a class="el" href="SimplePredictor_8C_source.html#l00042">SimplePredictor::apply()</a>, <a class="el" href="SystemBase_8C_source.html#l01424">SystemBase::applyScalingFactors()</a>, <a class="el" href="MultiApp_8C_source.html#l00721">MultiApp::backup()</a>, <a class="el" href="FEProblemBase_8C_source.html#l05025">FEProblemBase::backupMultiApps()</a>, <a class="el" href="CoarsenedPiecewiseLinear_8C_source.html#l00059">CoarsenedPiecewiseLinear::buildCoarsenedGrid()</a>, <a class="el" href="MeshDiagnosticsGenerator_8C_source.html#l00337">MeshDiagnosticsGenerator::checkElementOverlap()</a>, <a class="el" href="MeshDiagnosticsGenerator_8C_source.html#l00309">MeshDiagnosticsGenerator::checkElementTypes()</a>, <a class="el" href="MeshDiagnosticsGenerator_8C_source.html#l00268">MeshDiagnosticsGenerator::checkElementVolumes()</a>, <a class="el" href="MeshDiagnosticsGenerator_8C_source.html#l01157">MeshDiagnosticsGenerator::checkLocalJacobians()</a>, <a class="el" href="MeshDiagnosticsGenerator_8C_source.html#l00469">MeshDiagnosticsGenerator::checkNonConformalMesh()</a>, <a class="el" href="MeshDiagnosticsGenerator_8C_source.html#l00514">MeshDiagnosticsGenerator::checkNonConformalMeshFromAdaptivity()</a>, <a class="el" href="MeshDiagnosticsGenerator_8C_source.html#l00408">MeshDiagnosticsGenerator::checkNonPlanarSides()</a>, <a class="el" href="FEProblemBase_8C_source.html#l07384">FEProblemBase::checkProblemIntegrity()</a>, <a class="el" href="ReferenceResidualProblem_8C_source.html#l00511">ReferenceResidualProblem::checkRelativeConvergence()</a>, <a class="el" href="MeshDiagnosticsGenerator_8C_source.html#l00146">MeshDiagnosticsGenerator::checkSidesetsOrientation()</a>, <a class="el" href="IterationAdaptiveDT_8C_source.html#l00489">IterationAdaptiveDT::computeAdaptiveDT()</a>, <a class="el" href="Transient_8C_source.html#l00492">Transient::computeConstrainedDT()</a>, <a class="el" href="FixedPointSolve_8C_source.html#l00488">FixedPointSolve::computeCustomConvergencePostprocessor()</a>, <a class="el" href="NonlinearSystemBase_8C_source.html#l03096">NonlinearSystemBase::computeDamping()</a>, <a class="el" href="IterationAdaptiveDT_8C_source.html#l00237">IterationAdaptiveDT::computeDT()</a>, <a class="el" href="IterationAdaptiveDT_8C_source.html#l00322">IterationAdaptiveDT::computeFailedDT()</a>, <a class="el" href="IterationAdaptiveDT_8C_source.html#l00217">IterationAdaptiveDT::computeInitialDT()</a>, <a class="el" href="IterationAdaptiveDT_8C_source.html#l00526">IterationAdaptiveDT::computeInterpolationDT()</a>, <a class="el" href="FEProblemBase_8C_source.html#l06177">FEProblemBase::computeResidualAndJacobian()</a>, <a class="el" href="FEProblemBase_8C_source.html#l06452">FEProblemBase::computeResidualTags()</a>, <a class="el" href="NonlinearSystemBase_8C_source.html#l03720">NonlinearSystemBase::computeScaling()</a>, <a class="el" href="Problem_8h_source.html#l00048">Problem::console()</a>, <a class="el" href="TimeStepper_8C_source.html#l00102">TimeStepper::constrainStep()</a>, <a class="el" href="IterationAdaptiveDT_8C_source.html#l00298">IterationAdaptiveDT::constrainStep()</a>, <a class="el" href="MultiApp_8C_source.html#l01054">MultiApp::createApp()</a>, <a class="el" href="FEProblemBase_8C_source.html#l04920">FEProblemBase::execMultiApps()</a>, <a class="el" href="FEProblemBase_8C_source.html#l04820">FEProblemBase::execMultiAppTransfers()</a>, <a class="el" href="Eigenvalue_8C_source.html#l00215">Eigenvalue::execute()</a>, <a class="el" href="Steady_8C_source.html#l00054">Steady::execute()</a>, <a class="el" href="MessageFromInput_8C_source.html#l00041">MessageFromInput::execute()</a>, <a class="el" href="ActionWarehouse_8C_source.html#l00364">ActionWarehouse::executeActionsWithAction()</a>, <a class="el" href="ActionWarehouse_8C_source.html#l00332">ActionWarehouse::executeAllActions()</a>, <a class="el" href="ElementQualityChecker_8C_source.html#l00155">ElementQualityChecker::finalize()</a>, <a class="el" href="FEProblemBase_8C_source.html#l05003">FEProblemBase::finishMultiAppStep()</a>, <a class="el" href="MeshRepairGenerator_8C_source.html#l00081">MeshRepairGenerator::fixOverlappingNodes()</a>, <a class="el" href="MeshGenerator_8C_source.html#l00226">MeshGenerator::generateInternal()</a>, <a class="el" href="VariableCondensationPreconditioner_8C_source.html#l00194">VariableCondensationPreconditioner::getDofToCondense()</a>, <a class="el" href="InversePowerMethod_8C_source.html#l00060">InversePowerMethod::init()</a>, <a class="el" href="NonlinearEigen_8C_source.html#l00046">NonlinearEigen::init()</a>, <a class="el" href="FEProblemBase_8C_source.html#l07089">FEProblemBase::initialAdaptMesh()</a>, <a class="el" href="EigenExecutionerBase_8C_source.html#l00165">EigenExecutionerBase::inversePowerIteration()</a>, <a class="el" href="FEProblemBase_8C_source.html#l04206">FEProblemBase::joinAndFinalize()</a>, <a class="el" href="Transient_8C_source.html#l00584">Transient::keepGoing()</a>, <a class="el" href="IterationAdaptiveDT_8C_source.html#l00404">IterationAdaptiveDT::limitDTByFunction()</a>, <a class="el" href="IterationAdaptiveDT_8C_source.html#l00375">IterationAdaptiveDT::limitDTToPostprocessorValue()</a>, <a class="el" href="FEProblemBase_8C_source.html#l03699">FEProblemBase::logAdd()</a>, <a class="el" href="EigenExecutionerBase_8C_source.html#l00133">EigenExecutionerBase::makeBXConsistent()</a>, <a class="el" href="Console_8C_source.html#l00737">Console::meshChanged()</a>, <a class="el" href="MooseBaseErrorInterface_8h_source.html#l00078">MooseBaseErrorInterface::mooseDeprecated()</a>, <a class="el" href="MooseBaseErrorInterface_8h_source.html#l00084">MooseBaseErrorInterface::mooseInfo()</a>, <a class="el" href="MooseBaseErrorInterface_8h_source.html#l00062">MooseBaseErrorInterface::mooseWarning()</a>, <a class="el" href="MooseBaseErrorInterface_8h_source.html#l00072">MooseBaseErrorInterface::mooseWarningNonPrefixed()</a>, <a class="el" href="ReferenceResidualProblem_8C_source.html#l00461">ReferenceResidualProblem::nonlinearConvergenceSetup()</a>, <a class="el" href="Console_8C_source.html#l00310">Console::output()</a>, <a class="el" href="DOFMapOutput_8C_source.html#l00112">DOFMapOutput::output()</a>, <a class="el" href="MaterialPropertyDebugOutput_8C_source.html#l00039">MaterialPropertyDebugOutput::output()</a>, <a class="el" href="PerfGraphOutput_8C_source.html#l00068">PerfGraphOutput::output()</a>, <a class="el" href="ReporterDebugOutput_8C_source.html#l00029">ReporterDebugOutput::output()</a>, <a class="el" href="VariableResidualNormsDebugOutput_8C_source.html#l00047">VariableResidualNormsDebugOutput::output()</a>, <a class="el" href="ControlOutput_8C_source.html#l00056">ControlOutput::outputActiveObjects()</a>, <a class="el" href="ControlOutput_8C_source.html#l00151">ControlOutput::outputChangedControls()</a>, <a class="el" href="ControlOutput_8C_source.html#l00098">ControlOutput::outputControls()</a>, <a class="el" href="Console_8C_source.html#l00623">Console::outputInput()</a>, <a class="el" href="Console_8C_source.html#l00636">Console::outputPostprocessors()</a>, <a class="el" href="PseudoTimestep_8C_source.html#l00105">PseudoTimestep::outputPseudoTimestep()</a>, <a class="el" href="Console_8C_source.html#l00651">Console::outputReporters()</a>, <a class="el" href="Console_8C_source.html#l00666">Console::outputScalarVariables()</a>, <a class="el" href="Console_8C_source.html#l00684">Console::outputSystemInformation()</a>, <a class="el" href="FEProblemBase_8C_source.html#l07027">FEProblemBase::possiblyRebuildGeomSearchPatches()</a>, <a class="el" href="EigenExecutionerBase_8C_source.html#l00382">EigenExecutionerBase::postExecute()</a>, <a class="el" href="AB2PredictorCorrector_8C_source.html#l00127">AB2PredictorCorrector::postSolve()</a>, <a class="el" href="ActionWarehouse_8C_source.html#l00260">ActionWarehouse::printActionDependencySets()</a>, <a class="el" href="SolutionInvalidity_8C_source.html#l00150">SolutionInvalidity::printDebug()</a>, <a class="el" href="EigenExecutionerBase_8C_source.html#l00450">EigenExecutionerBase::printEigenvalue()</a>, <a class="el" href="PicardSolve_8C_source.html#l00260">PicardSolve::printFixedPointConvergenceHistory()</a>, <a class="el" href="SecantSolve_8C_source.html#l00252">SecantSolve::printFixedPointConvergenceHistory()</a>, <a class="el" href="SteffensenSolve_8C_source.html#l00225">SteffensenSolve::printFixedPointConvergenceHistory()</a>, <a class="el" href="FixedPointSolve_8C_source.html#l00550">FixedPointSolve::printFixedPointConvergenceReason()</a>, <a class="el" href="PerfGraphLivePrint_8C_source.html#l00037">PerfGraphLivePrint::printLiveMessage()</a>, <a class="el" href="MaterialPropertyDebugOutput_8C_source.html#l00054">MaterialPropertyDebugOutput::printMaterialMap()</a>, <a class="el" href="PerfGraphLivePrint_8C_source.html#l00127">PerfGraphLivePrint::printStats()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l02173">projectPrimaryNodesSinglePair()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01857">projectSecondaryNodesSinglePair()</a>, <a class="el" href="SolutionTimeAdaptiveDT_8C_source.html#l00114">SolutionTimeAdaptiveDT::rejectStep()</a>, <a class="el" href="MultiApp_8C_source.html#l00736">MultiApp::restore()</a>, <a class="el" href="FEProblemBase_8C_source.html#l05049">FEProblemBase::restoreMultiApps()</a>, <a class="el" href="SimplePredictor_8C_source.html#l00027">SimplePredictor::shouldApply()</a>, <a class="el" href="Checkpoint_8C_source.html#l00106">Checkpoint::shouldOutput()</a>, <a class="el" href="SubProblem_8C_source.html#l01206">SubProblem::showFunctorRequestors()</a>, <a class="el" href="SubProblem_8C_source.html#l01194">SubProblem::showFunctors()</a>, <a class="el" href="FullSolveMultiApp_8C_source.html#l00138">FullSolveMultiApp::showStatusMessage()</a>, <a class="el" href="FEProblemSolve_8C_source.html#l00280">FEProblemSolve::solve()</a>, <a class="el" href="FixedPointSolve_8C_source.html#l00182">FixedPointSolve::solve()</a>, <a class="el" href="NonlinearSystem_8C_source.html#l00132">NonlinearSystem::solve()</a>, <a class="el" href="AStableDirk4_8C_source.html#l00107">AStableDirk4::solve()</a>, <a class="el" href="ExplicitRK2_8C_source.html#l00070">ExplicitRK2::solve()</a>, <a class="el" href="ExplicitTVDRK2_8C_source.html#l00072">ExplicitTVDRK2::solve()</a>, <a class="el" href="ImplicitMidpoint_8C_source.html#l00060">ImplicitMidpoint::solve()</a>, <a class="el" href="LStableDirk2_8C_source.html#l00063">LStableDirk2::solve()</a>, <a class="el" href="LStableDirk3_8C_source.html#l00082">LStableDirk3::solve()</a>, <a class="el" href="LStableDirk4_8C_source.html#l00077">LStableDirk4::solve()</a>, <a class="el" href="EigenProblem_8C_source.html#l00515">EigenProblem::solve()</a>, <a class="el" href="FixedPointSolve_8C_source.html#l00360">FixedPointSolve::solveStep()</a>, <a class="el" href="TransientMultiApp_8C_source.html#l00181">TransientMultiApp::solveStep()</a>, <a class="el" href="PerfGraphLivePrint_8C_source.html#l00308">PerfGraphLivePrint::start()</a>, <a class="el" href="AB2PredictorCorrector_8C_source.html#l00084">AB2PredictorCorrector::step()</a>, <a class="el" href="NonlinearEigen_8C_source.html#l00113">NonlinearEigen::takeStep()</a>, <a class="el" href="Transient_8C_source.html#l00414">Transient::takeStep()</a>, <a class="el" href="Console_8C_source.html#l00414">Console::writeTimestepInformation()</a>, <a class="el" href="Console_8C_source.html#l00520">Console::writeVariableNorms()</a>, and <a class="el" href="FEProblemBase_8C_source.html#l00618">FEProblemBase::~FEProblemBase()</a>.</p>

</div>
</div>
<a id="a689b49e6bae35fa2ba975b844c4ec82e" name="a689b49e6bae35fa2ba975b844c4ec82e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a689b49e6bae35fa2ba975b844c4ec82e">&#9670;&#160;</a></span>_correct_edge_dropping</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool AutomaticMortarGeneration::_correct_edge_dropping</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flag to enable regressed treatment of edge dropping where all LM DoFs on edge dropping element are strongly set to 0. </p>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00499">499</a> of file <a class="el" href="AutomaticMortarGeneration_8h_source.html">AutomaticMortarGeneration.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01661">computeInactiveLMElems()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01577">computeInactiveLMNodes()</a>, and <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00297">incorrectEdgeDropping()</a>.</p>

</div>
</div>
<a id="a958de5b754ec676f463c50d2f16b5d0c" name="a958de5b754ec676f463c50d2f16b5d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a958de5b754ec676f463c50d2f16b5d0c">&#9670;&#160;</a></span>_debug</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool AutomaticMortarGeneration::_debug</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether to print debug output. </p>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00478">478</a> of file <a class="el" href="AutomaticMortarGeneration_8h_source.html">AutomaticMortarGeneration.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00433">buildMortarSegmentMesh()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00930">buildMortarSegmentMesh3d()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00247">initOutput()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l02173">projectPrimaryNodesSinglePair()</a>, and <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01857">projectSecondaryNodesSinglePair()</a>.</p>

</div>
</div>
<a id="ac4462365906bd50aeb9a76b07a5ff34d" name="ac4462365906bd50aeb9a76b07a5ff34d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4462365906bd50aeb9a76b07a5ff34d">&#9670;&#160;</a></span>_distributed</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool AutomaticMortarGeneration::_distributed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the mortar segment mesh is distributed. </p>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00487">487</a> of file <a class="el" href="AutomaticMortarGeneration_8h_source.html">AutomaticMortarGeneration.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00213">AutomaticMortarGeneration()</a>.</p>

</div>
</div>
<a id="ac3445ab0b94ce0dc9c01a1234321ebaa" name="ac3445ab0b94ce0dc9c01a1234321ebaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3445ab0b94ce0dc9c01a1234321ebaa">&#9670;&#160;</a></span>_inactive_local_lm_elems</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt;const Elem *&gt; AutomaticMortarGeneration::_inactive_local_lm_elems</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>List of inactive lagrange multiplier nodes (for elemental variables) </p>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00443">443</a> of file <a class="el" href="AutomaticMortarGeneration_8h_source.html">AutomaticMortarGeneration.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01661">computeInactiveLMElems()</a>, and <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00292">getInactiveLMElems()</a>.</p>

</div>
</div>
<a id="a3c757e0025c7dbfb78485e79067fb138" name="a3c757e0025c7dbfb78485e79067fb138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c757e0025c7dbfb78485e79067fb138">&#9670;&#160;</a></span>_inactive_local_lm_nodes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt;const Node *&gt; AutomaticMortarGeneration::_inactive_local_lm_nodes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00440">440</a> of file <a class="el" href="AutomaticMortarGeneration_8h_source.html">AutomaticMortarGeneration.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01577">computeInactiveLMNodes()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01485">computeIncorrectEdgeDroppingInactiveLMNodes()</a>, and <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00284">getInactiveLMNodes()</a>.</p>

</div>
</div>
<a id="a169550fc1a82fca976e386edae0d254d" name="a169550fc1a82fca976e386edae0d254d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a169550fc1a82fca976e386edae0d254d">&#9670;&#160;</a></span>_lower_elem_to_side_id</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;const Elem *, unsigned int&gt; AutomaticMortarGeneration::_lower_elem_to_side_id</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Keeps track of the mapping between lower-dimensional elements and the side_id of the interior_parent which they are. </p>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00408">408</a> of file <a class="el" href="AutomaticMortarGeneration_8h_source.html">AutomaticMortarGeneration.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00265">clear()</a>.</p>

</div>
</div>
<a id="a933e2cc029eab5574d2afcac61acf4e7" name="a933e2cc029eab5574d2afcac61acf4e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a933e2cc029eab5574d2afcac61acf4e7">&#9670;&#160;</a></span>_mesh</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MeshBase&amp; AutomaticMortarGeneration::_mesh</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reference to the mesh stored in equation_systems. </p>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00353">353</a> of file <a class="el" href="AutomaticMortarGeneration_8h_source.html">AutomaticMortarGeneration.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00213">AutomaticMortarGeneration()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01350">buildCouplingInformation()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00433">buildMortarSegmentMesh()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00930">buildMortarSegmentMesh3d()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00284">buildNodeToElemMaps()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01661">computeInactiveLMElems()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01577">computeInactiveLMNodes()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01485">computeIncorrectEdgeDroppingInactiveLMNodes()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01709">computeNodalGeometry()</a>, <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00279">dim()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00404">getNormals()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01421">msmStatistics()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00078">MortarNodalGeometryOutput::output()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l02173">projectPrimaryNodesSinglePair()</a>, and <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01857">projectSecondaryNodesSinglePair()</a>.</p>

</div>
</div>
<a id="af5ca257dd4090b3a8d801a439dcae0ca" name="af5ca257dd4090b3a8d801a439dcae0ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5ca257dd4090b3a8d801a439dcae0ca">&#9670;&#160;</a></span>_minimum_projection_angle</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Real AutomaticMortarGeneration::_minimum_projection_angle</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parameter to control which angle (in degrees) is admissible for the creation of mortar segments. </p>
<p >If set to a value close to zero, very oblique projections are allowed, which can result in mortar segments solving physics not meaningfully and overprojection of primary nodes onto the mortar segment mesh in extreme cases. This parameter is mostly intended for mortar mesh debugging purposes in 2D. </p>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00505">505</a> of file <a class="el" href="AutomaticMortarGeneration_8h_source.html">AutomaticMortarGeneration.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AutomaticMortarGeneration_8C_source.html#l02173">projectPrimaryNodesSinglePair()</a>, and <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01857">projectSecondaryNodesSinglePair()</a>.</p>

</div>
</div>
<a id="ab2357a3aacfa2cae90078e3b6293bf26" name="ab2357a3aacfa2cae90078e3b6293bf26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2357a3aacfa2cae90078e3b6293bf26">&#9670;&#160;</a></span>_mortar_interface_coupling</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;dof_id_type, std::unordered_set&lt;dof_id_type&gt; &gt; AutomaticMortarGeneration::_mortar_interface_coupling</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used by the <a class="el" href="classAugmentSparsityOnInterface.html">AugmentSparsityOnInterface</a> functor to determine whether a given Elem is coupled to any others across the gap, and to explicitly set up the dependence between interior_parent() elements on the secondary side and their lower-dimensional sides which are on the interface. </p>
<p >This latter type of coupling must be explicitly declared when there is no primary_elem for a given mortar segment and you are using e.g. a P^1-P^0 discretization which does not induce the coupling automatically. </p>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00427">427</a> of file <a class="el" href="AutomaticMortarGeneration_8h_source.html">AutomaticMortarGeneration.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01350">buildCouplingInformation()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00265">clear()</a>, and <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00256">mortarInterfaceCoupling()</a>.</p>

</div>
</div>
<a id="a9c3bb17ea3f054b18cc8044bb10d55d9" name="a9c3bb17ea3f054b18cc8044bb10d55d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c3bb17ea3f054b18cc8044bb10d55d9">&#9670;&#160;</a></span>_mortar_segment_mesh</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;MeshBase&gt; AutomaticMortarGeneration::_mortar_segment_mesh</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>1D Mesh of mortar segment elements which gets built by the call to build_mortar_segment_mesh(). </p>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00399">399</a> of file <a class="el" href="AutomaticMortarGeneration_8h_source.html">AutomaticMortarGeneration.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00213">AutomaticMortarGeneration()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00433">buildMortarSegmentMesh()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00930">buildMortarSegmentMesh3d()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00265">clear()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01661">computeInactiveLMElems()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01577">computeInactiveLMNodes()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01485">computeIncorrectEdgeDroppingInactiveLMNodes()</a>, <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00269">mortarSegmentMesh()</a>, and <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01421">msmStatistics()</a>.</p>

</div>
</div>
<a id="abbd91d3cf8bef528976fe6f932622d2d" name="abbd91d3cf8bef528976fe6f932622d2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbd91d3cf8bef528976fe6f932622d2d">&#9670;&#160;</a></span>_msm_elem_to_info</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;const Elem *, <a class="el" href="structMortarSegmentInfo.html">MortarSegmentInfo</a>&gt; AutomaticMortarGeneration::_msm_elem_to_info</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map between Elems in the mortar segment mesh and their info structs. </p>
<p >This gets filled in by the call to build_mortar_segment_mesh(). </p>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00404">404</a> of file <a class="el" href="AutomaticMortarGeneration_8h_source.html">AutomaticMortarGeneration.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01350">buildCouplingInformation()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00433">buildMortarSegmentMesh()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00930">buildMortarSegmentMesh3d()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00265">clear()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01661">computeInactiveLMElems()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01577">computeInactiveLMNodes()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01485">computeIncorrectEdgeDroppingInactiveLMNodes()</a>, and <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00274">mortarSegmentMeshElemToInfo()</a>.</p>

</div>
</div>
<a id="a04e775677691747d25e1a5f05496fa5a" name="a04e775677691747d25e1a5f05496fa5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04e775677691747d25e1a5f05496fa5a">&#9670;&#160;</a></span>_newton_tolerance</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Real AutomaticMortarGeneration::_newton_tolerance = 1e-12</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Newton solve tolerance for node projections. </p>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00490">490</a> of file <a class="el" href="AutomaticMortarGeneration_8h_source.html">AutomaticMortarGeneration.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AutomaticMortarGeneration_8C_source.html#l02173">projectPrimaryNodesSinglePair()</a>, and <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01857">projectSecondaryNodesSinglePair()</a>.</p>

</div>
</div>
<a id="a1ee9b6e4f8bd88603e22117085758f70" name="a1ee9b6e4f8bd88603e22117085758f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ee9b6e4f8bd88603e22117085758f70">&#9670;&#160;</a></span>_nodes_to_primary_elem_map</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;dof_id_type, std::vector&lt;const Elem *&gt; &gt; AutomaticMortarGeneration::_nodes_to_primary_elem_map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00367">367</a> of file <a class="el" href="AutomaticMortarGeneration_8h_source.html">AutomaticMortarGeneration.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00433">buildMortarSegmentMesh()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00930">buildMortarSegmentMesh3d()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00284">buildNodeToElemMaps()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00265">clear()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l02173">projectPrimaryNodesSinglePair()</a>, and <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01857">projectSecondaryNodesSinglePair()</a>.</p>

</div>
</div>
<a id="a1ad443aa196d2c81d195b29ddeee1d5e" name="a1ad443aa196d2c81d195b29ddeee1d5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ad443aa196d2c81d195b29ddeee1d5e">&#9670;&#160;</a></span>_nodes_to_secondary_elem_map</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;dof_id_type, std::vector&lt;const Elem *&gt; &gt; AutomaticMortarGeneration::_nodes_to_secondary_elem_map</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map from nodes to connected lower-dimensional elements on the secondary/primary subdomains. </p>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00366">366</a> of file <a class="el" href="AutomaticMortarGeneration_8h_source.html">AutomaticMortarGeneration.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00284">buildNodeToElemMaps()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00265">clear()</a>, <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00333">nodesToSecondaryElem()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l02173">projectPrimaryNodesSinglePair()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01857">projectSecondaryNodesSinglePair()</a>, and <a class="el" href="AutomaticMortarGeneration_8C_source.html#l02377">secondariesToMortarSegments()</a>.</p>

</div>
</div>
<a id="ac1faa015bf0201e49ab822e50b713fc1" name="ac1faa015bf0201e49ab822e50b713fc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1faa015bf0201e49ab822e50b713fc1">&#9670;&#160;</a></span>_on_displaced</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool AutomaticMortarGeneration::_on_displaced</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether this object is on the displaced mesh. </p>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00481">481</a> of file <a class="el" href="AutomaticMortarGeneration_8h_source.html">AutomaticMortarGeneration.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00247">initOutput()</a>, <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00171">onDisplaced()</a>, and <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00078">MortarNodalGeometryOutput::output()</a>.</p>

</div>
</div>
<a id="a3a19330f38987cd9318f38d932c5a2ad" name="a3a19330f38987cd9318f38d932c5a2ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a19330f38987cd9318f38d932c5a2ad">&#9670;&#160;</a></span>_output_params</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classInputParameters.html">InputParameters</a>&gt; AutomaticMortarGeneration::_output_params</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classStorage.html">Storage</a> for the input parameters used by the mortar nodal geometry output. </p>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00508">508</a> of file <a class="el" href="AutomaticMortarGeneration_8h_source.html">AutomaticMortarGeneration.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00247">initOutput()</a>.</p>

</div>
</div>
<a id="a509e5164f1c4cd0f981eaa901c37c632" name="a509e5164f1c4cd0f981eaa901c37c632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a509e5164f1c4cd0f981eaa901c37c632">&#9670;&#160;</a></span>_periodic</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool AutomaticMortarGeneration::_periodic</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether this object will be generating a mortar segment mesh for periodic constraints. </p>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00484">484</a> of file <a class="el" href="AutomaticMortarGeneration_8h_source.html">AutomaticMortarGeneration.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01709">computeNodalGeometry()</a>, and <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00404">getNormals()</a>.</p>

</div>
</div>
<a id="acbe701da36a67d2d9546f9db735b1faf" name="acbe701da36a67d2d9546f9db735b1faf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbe701da36a67d2d9546f9db735b1faf">&#9670;&#160;</a></span>_primary_boundary_subdomain_ids</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;<a class="el" href="AutomaticMortarGeneration_8h.html#afb1ef82fea6170b578d48ad9cd793486">SubdomainID</a>&gt; AutomaticMortarGeneration::_primary_boundary_subdomain_ids</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00417">417</a> of file <a class="el" href="AutomaticMortarGeneration_8h_source.html">AutomaticMortarGeneration.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00213">AutomaticMortarGeneration()</a>, and <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00284">buildNodeToElemMaps()</a>.</p>

</div>
</div>
<a id="ac99e408cefd4da80efa2649ef1d32e93" name="ac99e408cefd4da80efa2649ef1d32e93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac99e408cefd4da80efa2649ef1d32e93">&#9670;&#160;</a></span>_primary_ip_sub_ids</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;<a class="el" href="AutomaticMortarGeneration_8h.html#afb1ef82fea6170b578d48ad9cd793486">SubdomainID</a>&gt; AutomaticMortarGeneration::_primary_ip_sub_ids</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>All the primary interior parent subdomain IDs associated with the mortar mesh. </p>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00455">455</a> of file <a class="el" href="AutomaticMortarGeneration_8h_source.html">AutomaticMortarGeneration.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00433">buildMortarSegmentMesh()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00930">buildMortarSegmentMesh3d()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00265">clear()</a>, and <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00328">primaryIPSubIDs()</a>.</p>

</div>
</div>
<a id="ac174eedb02e9681baf439360903700d4" name="ac174eedb02e9681baf439360903700d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac174eedb02e9681baf439360903700d4">&#9670;&#160;</a></span>_primary_node_and_elem_to_xi1_secondary_elem</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::tuple&lt;dof_id_type, const Node *, const Elem *&gt;, std::pair&lt;Real, const Elem *&gt; &gt; AutomaticMortarGeneration::_primary_node_and_elem_to_xi1_secondary_elem</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same type of container, but for mapping (Primary Node ID, Primary Node, Primary Elem) -&gt; (xi^(1), Secondary Elem) where they are inverse-projected along the nodal normal direction. </p>
<p >Note that the first item of the key, the primary node ID, is important for storing the key-value pairs in a consistent order across processes, e.g. this container has to be ordered! </p>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00395">395</a> of file <a class="el" href="AutomaticMortarGeneration_8h_source.html">AutomaticMortarGeneration.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00433">buildMortarSegmentMesh()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00265">clear()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l02173">projectPrimaryNodesSinglePair()</a>, and <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01857">projectSecondaryNodesSinglePair()</a>.</p>

</div>
</div>
<a id="ad67507605b6ed18765d5ffd1243ff619" name="ad67507605b6ed18765d5ffd1243ff619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad67507605b6ed18765d5ffd1243ff619">&#9670;&#160;</a></span>_primary_requested_boundary_ids</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;<a class="el" href="AutomaticMortarGeneration_8h.html#acdf40e62836d2c708e17f9e204b0f877">BoundaryID</a>&gt; AutomaticMortarGeneration::_primary_requested_boundary_ids</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The boundary ids corresponding to all the primary surfaces. </p>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00359">359</a> of file <a class="el" href="AutomaticMortarGeneration_8h_source.html">AutomaticMortarGeneration.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00213">AutomaticMortarGeneration()</a>, and <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00284">buildNodeToElemMaps()</a>.</p>

</div>
</div>
<a id="a36e1a5b919de8cfdc39c8af4098fb450" name="a36e1a5b919de8cfdc39c8af4098fb450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36e1a5b919de8cfdc39c8af4098fb450">&#9670;&#160;</a></span>_primary_secondary_boundary_id_pairs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;<a class="el" href="AutomaticMortarGeneration_8h.html#acdf40e62836d2c708e17f9e204b0f877">BoundaryID</a>, <a class="el" href="AutomaticMortarGeneration_8h.html#acdf40e62836d2c708e17f9e204b0f877">BoundaryID</a>&gt; &gt; AutomaticMortarGeneration::_primary_secondary_boundary_id_pairs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A list of primary/secondary boundary id pairs corresponding to each side of the mortar interface. </p>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00363">363</a> of file <a class="el" href="AutomaticMortarGeneration_8h_source.html">AutomaticMortarGeneration.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00213">AutomaticMortarGeneration()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00433">buildMortarSegmentMesh()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00247">initOutput()</a>, and <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00515">primarySecondaryBoundaryIDPair()</a>.</p>

</div>
</div>
<a id="a969d4ab038fc8d447e966cd1e1600091" name="a969d4ab038fc8d447e966cd1e1600091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a969d4ab038fc8d447e966cd1e1600091">&#9670;&#160;</a></span>_primary_secondary_subdomain_id_pairs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::pair&lt;<a class="el" href="AutomaticMortarGeneration_8h.html#afb1ef82fea6170b578d48ad9cd793486">SubdomainID</a>, <a class="el" href="AutomaticMortarGeneration_8h.html#afb1ef82fea6170b578d48ad9cd793486">SubdomainID</a>&gt; &gt; AutomaticMortarGeneration::_primary_secondary_subdomain_id_pairs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A list of primary/secondary subdomain id pairs corresponding to each side of the mortar interface. </p>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00412">412</a> of file <a class="el" href="AutomaticMortarGeneration_8h_source.html">AutomaticMortarGeneration.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00213">AutomaticMortarGeneration()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00930">buildMortarSegmentMesh3d()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01661">computeInactiveLMElems()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01577">computeInactiveLMNodes()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01485">computeIncorrectEdgeDroppingInactiveLMNodes()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01421">msmStatistics()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l02164">projectPrimaryNodes()</a>, and <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01848">projectSecondaryNodes()</a>.</p>

</div>
</div>
<a id="a59c6fd297125023195e7bfb3714846c5" name="a59c6fd297125023195e7bfb3714846c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59c6fd297125023195e7bfb3714846c5">&#9670;&#160;</a></span>_secondary_boundary_subdomain_ids</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;<a class="el" href="AutomaticMortarGeneration_8h.html#afb1ef82fea6170b578d48ad9cd793486">SubdomainID</a>&gt; AutomaticMortarGeneration::_secondary_boundary_subdomain_ids</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The secondary/primary lower-dimensional boundary subdomain ids are the secondary/primary <em>boundary</em> ids. </p>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00416">416</a> of file <a class="el" href="AutomaticMortarGeneration_8h_source.html">AutomaticMortarGeneration.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00213">AutomaticMortarGeneration()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00433">buildMortarSegmentMesh()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00284">buildNodeToElemMaps()</a>, and <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01709">computeNodalGeometry()</a>.</p>

</div>
</div>
<a id="acb676f79ae207404fb5d224ac768df42" name="acb676f79ae207404fb5d224ac768df42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb676f79ae207404fb5d224ac768df42">&#9670;&#160;</a></span>_secondary_element_to_secondary_lowerd_element</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;dof_id_type, const Elem *&gt; AutomaticMortarGeneration::_secondary_element_to_secondary_lowerd_element</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map from full dimensional secondary element id to lower dimensional secondary element. </p>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00437">437</a> of file <a class="el" href="AutomaticMortarGeneration_8h_source.html">AutomaticMortarGeneration.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00265">clear()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01709">computeNodalGeometry()</a>, and <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00332">getSecondaryLowerdElemFromSecondaryElem()</a>.</p>

</div>
</div>
<a id="af0da3b7d9e404238718805e12452d74d" name="af0da3b7d9e404238718805e12452d74d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0da3b7d9e404238718805e12452d74d">&#9670;&#160;</a></span>_secondary_elems_to_mortar_segments</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;dof_id_type, std::set&lt;Elem *, CompareDofObjectsByID&gt; &gt; AutomaticMortarGeneration::_secondary_elems_to_mortar_segments</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>We maintain a mapping from lower-dimensional secondary elements in the original mesh to (sets of) elements in mortar_segment_mesh. </p>
<p >This allows us to quickly determine which elements need to be split. </p>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00449">449</a> of file <a class="el" href="AutomaticMortarGeneration_8h_source.html">AutomaticMortarGeneration.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00433">buildMortarSegmentMesh()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00930">buildMortarSegmentMesh3d()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00265">clear()</a>, and <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00315">secondariesToMortarSegments()</a>.</p>

</div>
</div>
<a id="a7254faea651acd63b60b408ab560a0e5" name="a7254faea651acd63b60b408ab560a0e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7254faea651acd63b60b408ab560a0e5">&#9670;&#160;</a></span>_secondary_ip_sub_ids</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;<a class="el" href="AutomaticMortarGeneration_8h.html#afb1ef82fea6170b578d48ad9cd793486">SubdomainID</a>&gt; AutomaticMortarGeneration::_secondary_ip_sub_ids</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>All the secondary interior parent subdomain IDs associated with the mortar mesh. </p>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00452">452</a> of file <a class="el" href="AutomaticMortarGeneration_8h_source.html">AutomaticMortarGeneration.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00433">buildMortarSegmentMesh()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00930">buildMortarSegmentMesh3d()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00265">clear()</a>, and <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00323">secondaryIPSubIDs()</a>.</p>

</div>
</div>
<a id="abb4cc3e3102675e52675a95347ad8e95" name="abb4cc3e3102675e52675a95347ad8e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb4cc3e3102675e52675a95347ad8e95">&#9670;&#160;</a></span>_secondary_node_and_elem_to_xi2_primary_elem</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;std::pair&lt;const Node *, const Elem *&gt;, std::pair&lt;Real, const Elem *&gt; &gt; AutomaticMortarGeneration::_secondary_node_and_elem_to_xi2_primary_elem</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Similar to the map above, but associates a (Secondary Node, Secondary Elem) pair to a (xi^(2), primary Elem) pair. </p>
<p >This allows a single secondary node, which is potentially connected to two elements on the secondary side, to be associated with multiple primary Elem/xi^(2) values to handle the case where the primary and secondary nodes are "matching". In this configuration:</p>
<p >A B o--&mdash;o--&mdash;o (secondary orientation -&gt;) | v ---&mdash;x---&mdash; (primary orientation &lt;-) C D</p>
<p >The entries in the map should be: (Elem A, Node 1) -&gt; (Elem C, xi^(2)=-1) (Elem B, Node 0) -&gt; (Elem D, xi^(2)=+1) </p>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00387">387</a> of file <a class="el" href="AutomaticMortarGeneration_8h_source.html">AutomaticMortarGeneration.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00433">buildMortarSegmentMesh()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00265">clear()</a>, and <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01857">projectSecondaryNodesSinglePair()</a>.</p>

</div>
</div>
<a id="a8120c89f18fdff39621fa512087a2da3" name="a8120c89f18fdff39621fa512087a2da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8120c89f18fdff39621fa512087a2da3">&#9670;&#160;</a></span>_secondary_node_to_hh_nodal_tangents</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;const Node *, std::array&lt;Point, 2&gt; &gt; AutomaticMortarGeneration::_secondary_node_to_hh_nodal_tangents</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Container for storing the nodal tangent/binormal vectors associated with each secondary node (Householder approach). </p>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00434">434</a> of file <a class="el" href="AutomaticMortarGeneration_8h_source.html">AutomaticMortarGeneration.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00265">clear()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01709">computeNodalGeometry()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00375">getNodalTangents()</a>, and <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00078">MortarNodalGeometryOutput::output()</a>.</p>

</div>
</div>
<a id="a06fb539aea2e63f3b48a6e1d41a2f568" name="a06fb539aea2e63f3b48a6e1d41a2f568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06fb539aea2e63f3b48a6e1d41a2f568">&#9670;&#160;</a></span>_secondary_node_to_nodal_normal</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;const Node *, Point&gt; AutomaticMortarGeneration::_secondary_node_to_nodal_normal</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Container for storing the nodal normal vector associated with each secondary node. </p>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00430">430</a> of file <a class="el" href="AutomaticMortarGeneration_8h_source.html">AutomaticMortarGeneration.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00265">clear()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01709">computeNodalGeometry()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00322">getNodalNormals()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00078">MortarNodalGeometryOutput::output()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l02173">projectPrimaryNodesSinglePair()</a>, and <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01857">projectSecondaryNodesSinglePair()</a>.</p>

</div>
</div>
<a id="a1d4166e27bcb186c75c320b232652cf1" name="a1d4166e27bcb186c75c320b232652cf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d4166e27bcb186c75c320b232652cf1">&#9670;&#160;</a></span>_secondary_requested_boundary_ids</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;<a class="el" href="AutomaticMortarGeneration_8h.html#acdf40e62836d2c708e17f9e204b0f877">BoundaryID</a>&gt; AutomaticMortarGeneration::_secondary_requested_boundary_ids</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The boundary ids corresponding to all the secondary surfaces. </p>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00356">356</a> of file <a class="el" href="AutomaticMortarGeneration_8h_source.html">AutomaticMortarGeneration.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00213">AutomaticMortarGeneration()</a>, and <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00284">buildNodeToElemMaps()</a>.</p>

</div>
</div>
<a id="a25f6f147b1b0a4b00e7c6739dd17b98c" name="a25f6f147b1b0a4b00e7c6739dd17b98c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25f6f147b1b0a4b00e7c6739dd17b98c">&#9670;&#160;</a></span>_xi_tolerance</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Real AutomaticMortarGeneration::_xi_tolerance = 1e-6</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tolerance for checking projection xi values. </p>
<p >Usually we are checking whether we projected onto a certain element (in which case -1 &lt;= xi &lt;= 1) or whether we should have <em>already</em> projected a primary node (in which case we error if abs(xi) is sufficiently close to 1) </p>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00495">495</a> of file <a class="el" href="AutomaticMortarGeneration_8h_source.html">AutomaticMortarGeneration.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="AutomaticMortarGeneration_8C_source.html#l00433">buildMortarSegmentMesh()</a>, <a class="el" href="AutomaticMortarGeneration_8C_source.html#l02173">projectPrimaryNodesSinglePair()</a>, and <a class="el" href="AutomaticMortarGeneration_8C_source.html#l01857">projectSecondaryNodesSinglePair()</a>.</p>

</div>
</div>
<a id="a5c57df863394d8e14ba6811f6e2dbe9c" name="a5c57df863394d8e14ba6811f6e2dbe9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c57df863394d8e14ba6811f6e2dbe9c">&#9670;&#160;</a></span>system_name</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string AutomaticMortarGeneration::system_name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The name of the nodal normals system. </p>
<p >We store this in one place so it's easy to change later. </p>

<p class="definition">Definition at line <a class="el" href="AutomaticMortarGeneration_8h_source.html#l00063">63</a> of file <a class="el" href="AutomaticMortarGeneration_8h_source.html">AutomaticMortarGeneration.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>moose/framework/include/constraints/<a class="el" href="AutomaticMortarGeneration_8h_source.html">AutomaticMortarGeneration.h</a></li>
<li>moose/framework/src/constraints/<a class="el" href="AutomaticMortarGeneration_8C_source.html">AutomaticMortarGeneration.C</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Dec 24 2023 00:20:24 for Zapdos by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>

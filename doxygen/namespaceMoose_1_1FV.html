<!-- HTML header for doxygen 1.9.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Zapdos: Moose::FV Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
    <a href="https://shannon-lab.github.io/zapdos" style="text-decoration:none"><div id="projectname">Zapdos</div></a><div id="projectname">
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceMoose.html">Moose</a></li><li class="navelem"><a class="el" href="namespaceMoose_1_1FV.html">FV</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">Moose::FV Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMoose_1_1FV_1_1CentralDifferenceLimiter.html">CentralDifferenceLimiter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a limiter which reproduces a central-differencing scheme, defined by $\beta(r_f) = 1$.  <a href="classMoose_1_1FV_1_1CentralDifferenceLimiter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMoose_1_1FV_1_1Limiter.html">Limiter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for defining slope limiters for finite volume or potentially reconstructed Discontinuous-Galerkin applications.  <a href="classMoose_1_1FV_1_1Limiter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMoose_1_1FV_1_1LimiterValueType.html">LimiterValueType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMoose_1_1FV_1_1LimiterValueType_3_01ADReal_01_4.html">LimiterValueType&lt; ADReal &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMoose_1_1FV_1_1LimiterValueType_3_01Real_01_4.html">LimiterValueType&lt; Real &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structMoose_1_1FV_1_1LimiterValueType_3_01T_00_01typename_01std_1_1enable__if_3_01HasMemberType_6e1fca9e7f7d8fb075d5b6d6a8d52f5a.html">LimiterValueType&lt; T, typename std::enable_if&lt; HasMemberType_value_type&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMoose_1_1FV_1_1MinModLimiter.html">MinModLimiter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the Min-Mod limiter, defined by $\beta(r_f) = \text{max}(0, \text{min}(1, r_f))$.  <a href="classMoose_1_1FV_1_1MinModLimiter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMoose_1_1FV_1_1QUICKLimiter.html">QUICKLimiter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a limiter which reproduces the QUICK scheme, defined by $\beta(r_f) = \frac{3+r_f}{4}$.  <a href="classMoose_1_1FV_1_1QUICKLimiter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMoose_1_1FV_1_1SOULimiter.html">SOULimiter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a limiter which reproduces the second-order-upwind scheme, defined by $\beta(r_f) = r_f$.  <a href="classMoose_1_1FV_1_1SOULimiter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMoose_1_1FV_1_1UpwindLimiter.html">UpwindLimiter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a limiter which reproduces the upwind scheme, defined by $\beta(r_f) = 0$.  <a href="classMoose_1_1FV_1_1UpwindLimiter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMoose_1_1FV_1_1VanLeerLimiter.html">VanLeerLimiter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the Van Leer limiter, defined by $\beta(r_f) = \frac{r_f + \text{abs}(r_f)}{1 + \text{abs}(r_f)}$.  <a href="classMoose_1_1FV_1_1VanLeerLimiter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a543ddcb0eef69b1aa6f7138b271c245c"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMoose_1_1FV.html#a543ddcb0eef69b1aa6f7138b271c245c">LimiterType</a> : int { <br />
&#160;&#160;<a class="el" href="namespaceMoose_1_1FV.html#a543ddcb0eef69b1aa6f7138b271c245caf9b8010cbfb0219d361f7670afcc289f">VanLeer</a> = 0
, <a class="el" href="namespaceMoose_1_1FV.html#a543ddcb0eef69b1aa6f7138b271c245ca6d61af52253bb644a0c23a12513a8a76">Upwind</a>
, <a class="el" href="namespaceMoose_1_1FV.html#a543ddcb0eef69b1aa6f7138b271c245cac6f5d0a15fe7871f1df4eacfbf77bdf6">CentralDifference</a>
, <a class="el" href="namespaceMoose_1_1FV.html#a543ddcb0eef69b1aa6f7138b271c245cac7fdfb1f6f93b887ae2479d84991b1e2">MinMod</a>
, <br />
&#160;&#160;<a class="el" href="namespaceMoose_1_1FV.html#a543ddcb0eef69b1aa6f7138b271c245caf3c08d92741209a11f476a78eea13191">SOU</a>
, <a class="el" href="namespaceMoose_1_1FV.html#a543ddcb0eef69b1aa6f7138b271c245ca7c77dcebcec67792afc15f80522fd945">QUICK</a>
<br />
 }</td></tr>
<tr class="separator:a543ddcb0eef69b1aa6f7138b271c245c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5941595b238d0963e4fe80718ab7dd50"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMoose_1_1FV.html#a5941595b238d0963e4fe80718ab7dd50">InterpMethod</a> { <br />
&#160;&#160;<a class="el" href="namespaceMoose_1_1FV.html#a5941595b238d0963e4fe80718ab7dd50ab1897515d548a960afe49ecf66a29021">Average</a>
, <a class="el" href="namespaceMoose_1_1FV.html#a5941595b238d0963e4fe80718ab7dd50a7776c998287c8c720bd5638d3e3e61be">HarmonicAverage</a>
, <a class="el" href="namespaceMoose_1_1FV.html#a5941595b238d0963e4fe80718ab7dd50a09b24c3a49cf399c0cc973cab0d13e4a">SkewCorrectedAverage</a>
, <a class="el" href="namespaceMoose_1_1FV.html#a5941595b238d0963e4fe80718ab7dd50a6d61af52253bb644a0c23a12513a8a76">Upwind</a>
, <br />
&#160;&#160;<a class="el" href="namespaceMoose_1_1FV.html#a5941595b238d0963e4fe80718ab7dd50a6fd4a9707e063a1fb5d86bf9e442888d">RhieChow</a>
, <a class="el" href="namespaceMoose_1_1FV.html#a5941595b238d0963e4fe80718ab7dd50af9b8010cbfb0219d361f7670afcc289f">VanLeer</a>
, <a class="el" href="namespaceMoose_1_1FV.html#a5941595b238d0963e4fe80718ab7dd50ac7fdfb1f6f93b887ae2479d84991b1e2">MinMod</a>
, <a class="el" href="namespaceMoose_1_1FV.html#a5941595b238d0963e4fe80718ab7dd50af3c08d92741209a11f476a78eea13191">SOU</a>
, <br />
&#160;&#160;<a class="el" href="namespaceMoose_1_1FV.html#a5941595b238d0963e4fe80718ab7dd50a7c77dcebcec67792afc15f80522fd945">QUICK</a>
<br />
 }</td></tr>
<tr class="memdesc:a5941595b238d0963e4fe80718ab7dd50"><td class="mdescLeft">&#160;</td><td class="mdescRight">This codifies a set of available ways to interpolate with elem+neighbor solution information to calculate values (e.g.  <a href="namespaceMoose_1_1FV.html#a5941595b238d0963e4fe80718ab7dd50">More...</a><br /></td></tr>
<tr class="separator:a5941595b238d0963e4fe80718ab7dd50"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a34d562f52c0ec819e7ffb51d54c8cf4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceMoose_1_1FV.html#a543ddcb0eef69b1aa6f7138b271c245c">LimiterType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMoose_1_1FV.html#a34d562f52c0ec819e7ffb51d54c8cf4d">limiterType</a> (<a class="el" href="namespaceMoose_1_1FV.html#a5941595b238d0963e4fe80718ab7dd50">InterpMethod</a> interp_method)</td></tr>
<tr class="memdesc:a34d562f52c0ec819e7ffb51d54c8cf4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the limiter type associated with the supplied interpolation method.  <a href="namespaceMoose_1_1FV.html#a34d562f52c0ec819e7ffb51d54c8cf4d">More...</a><br /></td></tr>
<tr class="separator:a34d562f52c0ec819e7ffb51d54c8cf4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31abd59f95d9b6db2c0306c2480af237"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMoose_1_1FV.html#a31abd59f95d9b6db2c0306c2480af237">elemHasFaceInfo</a> (const Elem &amp;elem, const Elem *const neighbor)</td></tr>
<tr class="memdesc:a31abd59f95d9b6db2c0306c2480af237"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function infers based on elements if the faceinfo between them belongs to the element or not.  <a href="namespaceMoose_1_1FV.html#a31abd59f95d9b6db2c0306c2480af237">More...</a><br /></td></tr>
<tr class="separator:a31abd59f95d9b6db2c0306c2480af237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0bb339b33520523cbb821268b82f96f"><td class="memTemplParams" colspan="2">template&lt;typename OutputType &gt; </td></tr>
<tr class="memitem:ad0bb339b33520523cbb821268b82f96f"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; const Elem *, const Elem *, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMoose_1_1FV.html#ad0bb339b33520523cbb821268b82f96f">determineElemOneAndTwo</a> (const <a class="el" href="classFaceInfo.html">FaceInfo</a> &amp;fi, const <a class="el" href="classMooseVariableFV.html">MooseVariableFV</a>&lt; OutputType &gt; &amp;var)</td></tr>
<tr class="memdesc:ad0bb339b33520523cbb821268b82f96f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This utility determines element one and element two given a <code><a class="el" href="classFaceInfo.html" title="This data structure is used to store geometric and variable related metadata about each cell face in ...">FaceInfo</a></code> <code>fi</code> and variable <code>var</code>.  <a href="namespaceMoose_1_1FV.html#ad0bb339b33520523cbb821268b82f96f">More...</a><br /></td></tr>
<tr class="separator:ad0bb339b33520523cbb821268b82f96f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c7ee0e080c3ab4e65ac09c550748927"><td class="memItemLeft" align="right" valign="top">template std::tuple&lt; const Elem *, const Elem *, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMoose_1_1FV.html#a9c7ee0e080c3ab4e65ac09c550748927">determineElemOneAndTwo</a> (const <a class="el" href="classFaceInfo.html">FaceInfo</a> &amp;fi, const <a class="el" href="classMooseVariableFV.html">MooseVariableFV</a>&lt; Real &gt; &amp;var)</td></tr>
<tr class="separator:a9c7ee0e080c3ab4e65ac09c550748927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d3c061e6e9f6aeb6defdfceec29d3bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ADRealForward_8h.html#aad0af4d0bfc617796dd28a541448a4e5">ADReal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMoose_1_1FV.html#a3d3c061e6e9f6aeb6defdfceec29d3bb">gradUDotNormal</a> (const <a class="el" href="classFaceInfo.html">FaceInfo</a> &amp;face_info, const <a class="el" href="classMooseVariableFV.html">MooseVariableFV</a>&lt; Real &gt; &amp;fv_var, const <a class="el" href="structMoose_1_1StateArg.html">Moose::StateArg</a> &amp;time, bool correct_skewness=false)</td></tr>
<tr class="memdesc:a3d3c061e6e9f6aeb6defdfceec29d3bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates and returns "grad_u dot normal" on the face to be used for diffusive terms.  <a href="namespaceMoose_1_1FV.html#a3d3c061e6e9f6aeb6defdfceec29d3bb">More...</a><br /></td></tr>
<tr class="separator:a3d3c061e6e9f6aeb6defdfceec29d3bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b51d0f8c53c8cbde7a51ce35f034da4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMoose_1_1FV.html#a4b51d0f8c53c8cbde7a51ce35f034da4">onBoundary</a> (const std::set&lt; <a class="el" href="AutomaticMortarGeneration_8h.html#afb1ef82fea6170b578d48ad9cd793486">SubdomainID</a> &gt; &amp;subs, const <a class="el" href="classFaceInfo.html">FaceInfo</a> &amp;fi)</td></tr>
<tr class="memdesc:a4b51d0f8c53c8cbde7a51ce35f034da4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine whether the passed-in face is on the boundary of an object that lives on the provided subdomains.  <a href="namespaceMoose_1_1FV.html#a4b51d0f8c53c8cbde7a51ce35f034da4">More...</a><br /></td></tr>
<tr class="separator:a4b51d0f8c53c8cbde7a51ce35f034da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99cdbba7e56deab1236a2ed3efac3567"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMooseEnum.html">MooseEnum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMoose_1_1FV.html#a99cdbba7e56deab1236a2ed3efac3567">interpolationMethods</a> ()</td></tr>
<tr class="memdesc:a99cdbba7e56deab1236a2ed3efac3567"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an enum with all the currently supported interpolation methods and the current default for <a class="el" href="namespaceMoose_1_1FV.html">FV</a>: first-order upwind.  <a href="namespaceMoose_1_1FV.html#a99cdbba7e56deab1236a2ed3efac3567">More...</a><br /></td></tr>
<tr class="separator:a99cdbba7e56deab1236a2ed3efac3567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad844815080b72eb60bb577147f93e9d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classInputParameters.html">InputParameters</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMoose_1_1FV.html#ad844815080b72eb60bb577147f93e9d7">advectedInterpolationParameter</a> ()</td></tr>
<tr class="separator:ad844815080b72eb60bb577147f93e9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae730f76e979904d97c348419a6a7a796"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceMoose_1_1FV.html#a5941595b238d0963e4fe80718ab7dd50">InterpMethod</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMoose_1_1FV.html#ae730f76e979904d97c348419a6a7a796">selectInterpolationMethod</a> (const std::string &amp;interp_method)</td></tr>
<tr class="separator:ae730f76e979904d97c348419a6a7a796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2fcf2007027e2518504e33619e663c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMoose_1_1FV.html#a3a2fcf2007027e2518504e33619e663c">setInterpolationMethod</a> (const <a class="el" href="classMooseObject.html">MooseObject</a> &amp;obj, <a class="el" href="namespaceMoose_1_1FV.html#a5941595b238d0963e4fe80718ab7dd50">Moose::FV::InterpMethod</a> &amp;interp_method, const std::string &amp;param_name)</td></tr>
<tr class="memdesc:a3a2fcf2007027e2518504e33619e663c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets one interpolation method.  <a href="namespaceMoose_1_1FV.html#a3a2fcf2007027e2518504e33619e663c">More...</a><br /></td></tr>
<tr class="separator:a3a2fcf2007027e2518504e33619e663c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ac7ab327b328366cc7ebbbd739a874f"><td class="memTemplParams" colspan="2">template&lt;typename ActionFunctor &gt; </td></tr>
<tr class="memitem:a4ac7ab327b328366cc7ebbbd739a874f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMoose_1_1FV.html#a4ac7ab327b328366cc7ebbbd739a874f">loopOverElemFaceInfo</a> (const Elem &amp;elem, const <a class="el" href="classMooseMesh.html">MooseMesh</a> &amp;mesh, ActionFunctor &amp;act, const <a class="el" href="namespaceMoose.html#aa11333273856693d4c2762d764789509">Moose::CoordinateSystemType</a> coord_type, const unsigned int rz_radial_coord=libMesh::invalid_uint)</td></tr>
<tr class="separator:a4ac7ab327b328366cc7ebbbd739a874f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9390f7c56eb001f809b1a40e6568008e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Enable  = typename std::enable_if&lt;ScalarTraits&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a9390f7c56eb001f809b1a40e6568008e"><td class="memTemplItemLeft" align="right" valign="top">VectorValue&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMoose_1_1FV.html#a9390f7c56eb001f809b1a40e6568008e">greenGaussGradient</a> (const <a class="el" href="structMoose_1_1ElemArg.html">ElemArg</a> &amp;elem_arg, const <a class="el" href="structMoose_1_1StateArg.html">StateArg</a> &amp;state_arg, const <a class="el" href="classMoose_1_1FunctorBase.html">FunctorBase</a>&lt; T &gt; &amp;functor, const bool two_term_boundary_expansion, const <a class="el" href="classMooseMesh.html">MooseMesh</a> &amp;mesh)</td></tr>
<tr class="memdesc:a9390f7c56eb001f809b1a40e6568008e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a cell gradient using the method of Green-Gauss.  <a href="namespaceMoose_1_1FV.html#a9390f7c56eb001f809b1a40e6568008e">More...</a><br /></td></tr>
<tr class="separator:a9390f7c56eb001f809b1a40e6568008e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1bdd6d55239090e1f3d94bce5d7abb8"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Enable  = typename std::enable_if&lt;ScalarTraits&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:af1bdd6d55239090e1f3d94bce5d7abb8"><td class="memTemplItemLeft" align="right" valign="top">VectorValue&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMoose_1_1FV.html#af1bdd6d55239090e1f3d94bce5d7abb8">greenGaussGradient</a> (const <a class="el" href="structMoose_1_1FaceArg.html">FaceArg</a> &amp;face_arg, const <a class="el" href="structMoose_1_1StateArg.html">StateArg</a> &amp;state_arg, const <a class="el" href="classMoose_1_1FunctorBase.html">FunctorBase</a>&lt; T &gt; &amp;functor, const bool two_term_boundary_expansion, const <a class="el" href="classMooseMesh.html">MooseMesh</a> &amp;mesh)</td></tr>
<tr class="memdesc:af1bdd6d55239090e1f3d94bce5d7abb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute a face gradient from Green-Gauss cell gradients, with orthogonality correction On the boundaries, the boundary element value is used.  <a href="namespaceMoose_1_1FV.html#af1bdd6d55239090e1f3d94bce5d7abb8">More...</a><br /></td></tr>
<tr class="separator:af1bdd6d55239090e1f3d94bce5d7abb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab30763508fa761f63fac721217cd1d69"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab30763508fa761f63fac721217cd1d69"><td class="memTemplItemLeft" align="right" valign="top">TensorValue&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMoose_1_1FV.html#ab30763508fa761f63fac721217cd1d69">greenGaussGradient</a> (const <a class="el" href="structMoose_1_1ElemArg.html">ElemArg</a> &amp;elem_arg, const <a class="el" href="structMoose_1_1StateArg.html">StateArg</a> &amp;state_arg, const <a class="el" href="classMoose_1_1FunctorBase.html">Moose::FunctorBase</a>&lt; VectorValue&lt; T &gt; &gt; &amp;functor, const bool two_term_boundary_expansion, const <a class="el" href="classMooseMesh.html">MooseMesh</a> &amp;mesh)</td></tr>
<tr class="separator:ab30763508fa761f63fac721217cd1d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e28705d3772632b864c7e93250566f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab8e28705d3772632b864c7e93250566f"><td class="memTemplItemLeft" align="right" valign="top">TensorValue&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMoose_1_1FV.html#ab8e28705d3772632b864c7e93250566f">greenGaussGradient</a> (const <a class="el" href="structMoose_1_1FaceArg.html">FaceArg</a> &amp;face_arg, const <a class="el" href="structMoose_1_1StateArg.html">StateArg</a> &amp;state_arg, const <a class="el" href="classMoose_1_1FunctorBase.html">Moose::FunctorBase</a>&lt; VectorValue&lt; T &gt; &gt; &amp;functor, const bool two_term_boundary_expansion, const <a class="el" href="classMooseMesh.html">MooseMesh</a> &amp;mesh)</td></tr>
<tr class="separator:ab8e28705d3772632b864c7e93250566f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a247604c97cbe04478051dcc19da10b92"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a247604c97cbe04478051dcc19da10b92"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classMoose_1_1FunctorBase.html">Moose::FunctorBase</a>&lt; std::vector&lt; T &gt; &gt;::GradientType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMoose_1_1FV.html#a247604c97cbe04478051dcc19da10b92">greenGaussGradient</a> (const <a class="el" href="structMoose_1_1ElemArg.html">ElemArg</a> &amp;elem_arg, const <a class="el" href="structMoose_1_1StateArg.html">StateArg</a> &amp;state_arg, const <a class="el" href="classMoose_1_1FunctorBase.html">Moose::FunctorBase</a>&lt; std::vector&lt; T &gt; &gt; &amp;functor, const bool two_term_boundary_expansion, const <a class="el" href="classMooseMesh.html">MooseMesh</a> &amp;mesh)</td></tr>
<tr class="separator:a247604c97cbe04478051dcc19da10b92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a3d177e46dbb67a9b5949c8d9e6d7a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a33a3d177e46dbb67a9b5949c8d9e6d7a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classMoose_1_1FunctorBase.html">Moose::FunctorBase</a>&lt; std::vector&lt; T &gt; &gt;::GradientType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMoose_1_1FV.html#a33a3d177e46dbb67a9b5949c8d9e6d7a">greenGaussGradient</a> (const <a class="el" href="structMoose_1_1FaceArg.html">FaceArg</a> &amp;face_arg, const <a class="el" href="structMoose_1_1StateArg.html">StateArg</a> &amp;state_arg, const <a class="el" href="classMoose_1_1FunctorBase.html">Moose::FunctorBase</a>&lt; std::vector&lt; T &gt; &gt; &amp;functor, const bool two_term_boundary_expansion, const <a class="el" href="classMooseMesh.html">MooseMesh</a> &amp;mesh)</td></tr>
<tr class="separator:a33a3d177e46dbb67a9b5949c8d9e6d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08f9683e7b3fc9a3e3bfbf357ba52212"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a08f9683e7b3fc9a3e3bfbf357ba52212"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classMoose_1_1FunctorBase.html">Moose::FunctorBase</a>&lt; std::array&lt; T, N &gt; &gt;::GradientType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMoose_1_1FV.html#a08f9683e7b3fc9a3e3bfbf357ba52212">greenGaussGradient</a> (const <a class="el" href="structMoose_1_1ElemArg.html">ElemArg</a> &amp;elem_arg, const <a class="el" href="structMoose_1_1StateArg.html">StateArg</a> &amp;state_arg, const <a class="el" href="classMoose_1_1FunctorBase.html">Moose::FunctorBase</a>&lt; std::array&lt; T, N &gt; &gt; &amp;functor, const bool two_term_boundary_expansion, const <a class="el" href="classMooseMesh.html">MooseMesh</a> &amp;mesh)</td></tr>
<tr class="separator:a08f9683e7b3fc9a3e3bfbf357ba52212"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f0f08a7eaa8a0a3af7e57b85239b261"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a9f0f08a7eaa8a0a3af7e57b85239b261"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classMoose_1_1FunctorBase.html">Moose::FunctorBase</a>&lt; std::array&lt; T, N &gt; &gt;::GradientType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMoose_1_1FV.html#a9f0f08a7eaa8a0a3af7e57b85239b261">greenGaussGradient</a> (const <a class="el" href="structMoose_1_1FaceArg.html">FaceArg</a> &amp;face_arg, const <a class="el" href="structMoose_1_1StateArg.html">StateArg</a> &amp;state_arg, const <a class="el" href="classMoose_1_1FunctorBase.html">Moose::FunctorBase</a>&lt; std::array&lt; T, N &gt; &gt; &amp;functor, const bool two_term_boundary_expansion, const <a class="el" href="classMooseMesh.html">MooseMesh</a> &amp;mesh)</td></tr>
<tr class="separator:a9f0f08a7eaa8a0a3af7e57b85239b261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e347c5804ee209112eea6eab0a466f"><td class="memTemplParams" colspan="2">template&lt;typename Vector  = RealVectorValue&gt; </td></tr>
<tr class="memitem:aa8e347c5804ee209112eea6eab0a466f"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; Real, Real &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMoose_1_1FV.html#aa8e347c5804ee209112eea6eab0a466f">interpCoeffs</a> (const <a class="el" href="namespaceMoose_1_1FV.html#a5941595b238d0963e4fe80718ab7dd50">InterpMethod</a> m, const <a class="el" href="classFaceInfo.html">FaceInfo</a> &amp;fi, const bool one_is_elem, const Vector advector=Vector())</td></tr>
<tr class="memdesc:aa8e347c5804ee209112eea6eab0a466f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce the interpolation coefficients in the equation:  <a href="namespaceMoose_1_1FV.html#aa8e347c5804ee209112eea6eab0a466f">More...</a><br /></td></tr>
<tr class="separator:aa8e347c5804ee209112eea6eab0a466f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d222a7b752432de3ee9ad82a150dd80"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 &gt; </td></tr>
<tr class="memitem:a4d222a7b752432de3ee9ad82a150dd80"><td class="memTemplItemLeft" align="right" valign="top">libMesh::CompareTypes&lt; T, T2 &gt;::supertype&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMoose_1_1FV.html#a4d222a7b752432de3ee9ad82a150dd80">linearInterpolation</a> (const T &amp;value1, const T2 &amp;value2, const <a class="el" href="classFaceInfo.html">FaceInfo</a> &amp;fi, const bool one_is_elem, const <a class="el" href="namespaceMoose_1_1FV.html#a5941595b238d0963e4fe80718ab7dd50">InterpMethod</a> interp_method=<a class="el" href="namespaceMoose_1_1FV.html#a5941595b238d0963e4fe80718ab7dd50ab1897515d548a960afe49ecf66a29021">InterpMethod::Average</a>)</td></tr>
<tr class="memdesc:a4d222a7b752432de3ee9ad82a150dd80"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple linear interpolation of values between cell centers to a cell face.  <a href="namespaceMoose_1_1FV.html#a4d222a7b752432de3ee9ad82a150dd80">More...</a><br /></td></tr>
<tr class="separator:a4d222a7b752432de3ee9ad82a150dd80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c9021070513a8b6bb21753e7b662920"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a3c9021070513a8b6bb21753e7b662920"><td class="memTemplItemLeft" align="right" valign="top">libMesh::CompareTypes&lt; T1, T2 &gt;::supertype&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMoose_1_1FV.html#a3c9021070513a8b6bb21753e7b662920">harmonicInterpolation</a> (const T1 &amp;value1, const T2 &amp;value2, const <a class="el" href="classFaceInfo.html">FaceInfo</a> &amp;fi, const bool one_is_elem)</td></tr>
<tr class="memdesc:a3c9021070513a8b6bb21753e7b662920"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the harmonic mean (1/(gc/value1+(1-gc)/value2)) of Reals, RealVectorValues and RealTensorValues while accounting for the possibility that one or both of them are AD.  <a href="namespaceMoose_1_1FV.html#a3c9021070513a8b6bb21753e7b662920">More...</a><br /></td></tr>
<tr class="separator:a3c9021070513a8b6bb21753e7b662920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a200d96276412a952b11a92c2e1f564e9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 , typename T3 &gt; </td></tr>
<tr class="memitem:a200d96276412a952b11a92c2e1f564e9"><td class="memTemplItemLeft" align="right" valign="top">libMesh::CompareTypes&lt; T, T2 &gt;::supertype&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMoose_1_1FV.html#a200d96276412a952b11a92c2e1f564e9">skewCorrectedLinearInterpolation</a> (const T &amp;value1, const T2 &amp;value2, const T3 &amp;face_gradient, const <a class="el" href="classFaceInfo.html">FaceInfo</a> &amp;fi, const bool one_is_elem)</td></tr>
<tr class="memdesc:a200d96276412a952b11a92c2e1f564e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear interpolation with skewness correction using the face gradient.  <a href="namespaceMoose_1_1FV.html#a200d96276412a952b11a92c2e1f564e9">More...</a><br /></td></tr>
<tr class="separator:a200d96276412a952b11a92c2e1f564e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a181e9d146f7d17fcd56ff75f166efac6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 , typename T3 &gt; </td></tr>
<tr class="memitem:a181e9d146f7d17fcd56ff75f166efac6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMoose_1_1FV.html#a181e9d146f7d17fcd56ff75f166efac6">interpolate</a> (<a class="el" href="namespaceMoose_1_1FV.html#a5941595b238d0963e4fe80718ab7dd50">InterpMethod</a> m, T &amp;result, const T2 &amp;value1, const T3 &amp;value2, const <a class="el" href="classFaceInfo.html">FaceInfo</a> &amp;fi, const bool one_is_elem)</td></tr>
<tr class="memdesc:a181e9d146f7d17fcd56ff75f166efac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides interpolation of face values for non-advection-specific purposes (although it can/will still be used by advective kernels sometimes).  <a href="namespaceMoose_1_1FV.html#a181e9d146f7d17fcd56ff75f166efac6">More...</a><br /></td></tr>
<tr class="separator:a181e9d146f7d17fcd56ff75f166efac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3274441ca6ecde4e6ca4c5cf6108a2ac"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3274441ca6ecde4e6ca4c5cf6108a2ac"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMoose_1_1FV.html#a3274441ca6ecde4e6ca4c5cf6108a2ac">linearInterpolation</a> (const <a class="el" href="classMoose_1_1FunctorBase.html">FunctorBase</a>&lt; T &gt; &amp;functor, const <a class="el" href="structMoose_1_1FaceArg.html">FaceArg</a> &amp;face, const <a class="el" href="structMoose_1_1StateArg.html">StateArg</a> &amp;time)</td></tr>
<tr class="memdesc:a3274441ca6ecde4e6ca4c5cf6108a2ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">perform a possibly skew-corrected linear interpolation by evaluating the supplied functor with the provided functor face argument  <a href="namespaceMoose_1_1FV.html#a3274441ca6ecde4e6ca4c5cf6108a2ac">More...</a><br /></td></tr>
<tr class="separator:a3274441ca6ecde4e6ca4c5cf6108a2ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac35dff353eeb171d7fc5adc7c93943f9"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 , typename T3 , template&lt; typename &gt; class Vector1, template&lt; typename &gt; class Vector2&gt; </td></tr>
<tr class="memitem:ac35dff353eeb171d7fc5adc7c93943f9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMoose_1_1FV.html#ac35dff353eeb171d7fc5adc7c93943f9">interpolate</a> (<a class="el" href="namespaceMoose_1_1FV.html#a5941595b238d0963e4fe80718ab7dd50">InterpMethod</a> m, Vector1&lt; T1 &gt; &amp;result, const T2 &amp;fi_elem_advected, const T2 &amp;fi_neighbor_advected, const Vector2&lt; T3 &gt; &amp;fi_elem_advector, const Vector2&lt; T3 &gt; &amp;fi_neighbor_advector, const <a class="el" href="classFaceInfo.html">FaceInfo</a> &amp;fi)</td></tr>
<tr class="memdesc:ac35dff353eeb171d7fc5adc7c93943f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the product of the advected and the advector based on the given interpolation method.  <a href="namespaceMoose_1_1FV.html#ac35dff353eeb171d7fc5adc7c93943f9">More...</a><br /></td></tr>
<tr class="separator:ac35dff353eeb171d7fc5adc7c93943f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a613ba6de4c72211b02597b42f285627d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename T2 , typename T3 , typename Vector &gt; </td></tr>
<tr class="memitem:a613ba6de4c72211b02597b42f285627d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMoose_1_1FV.html#a613ba6de4c72211b02597b42f285627d">interpolate</a> (<a class="el" href="namespaceMoose_1_1FV.html#a5941595b238d0963e4fe80718ab7dd50">InterpMethod</a> m, T &amp;result, const T2 &amp;value1, const T3 &amp;value2, const Vector &amp;advector, const <a class="el" href="classFaceInfo.html">FaceInfo</a> &amp;fi, const bool one_is_elem)</td></tr>
<tr class="memdesc:a613ba6de4c72211b02597b42f285627d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides interpolation of face values for advective flux kernels.  <a href="namespaceMoose_1_1FV.html#a613ba6de4c72211b02597b42f285627d">More...</a><br /></td></tr>
<tr class="separator:a613ba6de4c72211b02597b42f285627d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce769173061499d2c553818b2e643b8"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Vector &gt; </td></tr>
<tr class="memitem:a2ce769173061499d2c553818b2e643b8"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMoose_1_1FV.html#a2ce769173061499d2c553818b2e643b8">rF</a> (const Scalar &amp;phiC, const Scalar &amp;phiD, const Vector &amp;gradC, const RealVectorValue &amp;dCD)</td></tr>
<tr class="memdesc:a2ce769173061499d2c553818b2e643b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">From Moukalled 12.30.  <a href="namespaceMoose_1_1FV.html#a2ce769173061499d2c553818b2e643b8">More...</a><br /></td></tr>
<tr class="separator:a2ce769173061499d2c553818b2e643b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c43f768c0d93b5e4a4dfddc2c60d73"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a01c43f768c0d93b5e4a4dfddc2c60d73"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; T, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMoose_1_1FV.html#a01c43f768c0d93b5e4a4dfddc2c60d73">interpCoeffs</a> (const <a class="el" href="classMoose_1_1FV_1_1Limiter.html">Limiter</a>&lt; T &gt; &amp;limiter, const T &amp;phi_upwind, const T &amp;phi_downwind, const VectorValue&lt; T &gt; *const grad_phi_upwind, const <a class="el" href="classFaceInfo.html">FaceInfo</a> &amp;fi, const bool fi_elem_is_upwind)</td></tr>
<tr class="memdesc:a01c43f768c0d93b5e4a4dfddc2c60d73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce the interpolation coefficients in the equation:  <a href="namespaceMoose_1_1FV.html#a01c43f768c0d93b5e4a4dfddc2c60d73">More...</a><br /></td></tr>
<tr class="separator:a01c43f768c0d93b5e4a4dfddc2c60d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c61f9527da5f52101404e2f2306a1d"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , typename Vector , typename Enable  = typename std::enable_if&lt;ScalarTraits&lt;Scalar&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a69c61f9527da5f52101404e2f2306a1d"><td class="memTemplItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMoose_1_1FV.html#a69c61f9527da5f52101404e2f2306a1d">interpolate</a> (const <a class="el" href="classMoose_1_1FV_1_1Limiter.html">Limiter</a>&lt; Scalar &gt; &amp;limiter, const Scalar &amp;phi_upwind, const Scalar &amp;phi_downwind, const Vector *const grad_phi_upwind, const <a class="el" href="classFaceInfo.html">FaceInfo</a> &amp;fi, const bool fi_elem_is_upwind)</td></tr>
<tr class="memdesc:a69c61f9527da5f52101404e2f2306a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolates with a limiter.  <a href="namespaceMoose_1_1FV.html#a69c61f9527da5f52101404e2f2306a1d">More...</a><br /></td></tr>
<tr class="separator:a69c61f9527da5f52101404e2f2306a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3061f2550ae0dee31012fdcb67453ae"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="classMoose_1_1FV_1_1Limiter.html">Limiter</a> , typename T , typename Tensor &gt; </td></tr>
<tr class="memitem:ab3061f2550ae0dee31012fdcb67453ae"><td class="memTemplItemLeft" align="right" valign="top">VectorValue&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMoose_1_1FV.html#ab3061f2550ae0dee31012fdcb67453ae">interpolate</a> (const <a class="el" href="classMoose_1_1FV_1_1Limiter.html">Limiter</a> &amp;limiter, const TypeVector&lt; T &gt; &amp;phi_upwind, const TypeVector&lt; T &gt; &amp;phi_downwind, const Tensor *const grad_phi_upwind, const <a class="el" href="classFaceInfo.html">FaceInfo</a> &amp;fi, const bool fi_elem_is_upwind)</td></tr>
<tr class="memdesc:ab3061f2550ae0dee31012fdcb67453ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector overload.  <a href="namespaceMoose_1_1FV.html#ab3061f2550ae0dee31012fdcb67453ae">More...</a><br /></td></tr>
<tr class="separator:ab3061f2550ae0dee31012fdcb67453ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4267099c59edd237ac32dfc1846ead"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Enable  = typename std::enable_if&lt;ScalarTraits&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:afe4267099c59edd237ac32dfc1846ead"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; std::pair&lt; T, T &gt;, std::pair&lt; T, T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMoose_1_1FV.html#afe4267099c59edd237ac32dfc1846ead">interpCoeffsAndAdvected</a> (const <a class="el" href="classMoose_1_1FunctorBase.html">FunctorBase</a>&lt; T &gt; &amp;functor, const <a class="el" href="structMoose_1_1FaceArg.html">FaceArg</a> &amp;face, const <a class="el" href="structMoose_1_1StateArg.html">StateArg</a> &amp;time)</td></tr>
<tr class="memdesc:afe4267099c59edd237ac32dfc1846ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolates with a limiter and a face argument.  <a href="namespaceMoose_1_1FV.html#afe4267099c59edd237ac32dfc1846ead">More...</a><br /></td></tr>
<tr class="separator:afe4267099c59edd237ac32dfc1846ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b16d9fd94653065b562cfc60b75b03d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Enable  = typename std::enable_if&lt;ScalarTraits&lt;T&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a5b16d9fd94653065b562cfc60b75b03d"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMoose_1_1FV.html#a5b16d9fd94653065b562cfc60b75b03d">interpolate</a> (const <a class="el" href="classMoose_1_1FunctorBase.html">FunctorBase</a>&lt; T &gt; &amp;functor, const <a class="el" href="structMoose_1_1FaceArg.html">FaceArg</a> &amp;face, const <a class="el" href="structMoose_1_1StateArg.html">StateArg</a> &amp;time)</td></tr>
<tr class="separator:a5b16d9fd94653065b562cfc60b75b03d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a1c4b434ffe35faa009e6c46ecfee3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a06a1c4b434ffe35faa009e6c46ecfee3"><td class="memTemplItemLeft" align="right" valign="top">VectorValue&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMoose_1_1FV.html#a06a1c4b434ffe35faa009e6c46ecfee3">interpolate</a> (const <a class="el" href="classMoose_1_1FunctorBase.html">FunctorBase</a>&lt; VectorValue&lt; T &gt; &gt; &amp;functor, const <a class="el" href="structMoose_1_1FaceArg.html">FaceArg</a> &amp;face, const <a class="el" href="structMoose_1_1StateArg.html">StateArg</a> &amp;time)</td></tr>
<tr class="separator:a06a1c4b434ffe35faa009e6c46ecfee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26af73ced485536f98bd9e46f124f0a5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a26af73ced485536f98bd9e46f124f0a5"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMoose_1_1FV.html#a26af73ced485536f98bd9e46f124f0a5">containerInterpolate</a> (const <a class="el" href="classMoose_1_1FunctorBase.html">FunctorBase</a>&lt; T &gt; &amp;functor, const <a class="el" href="structMoose_1_1FaceArg.html">FaceArg</a> &amp;face, const <a class="el" href="structMoose_1_1StateArg.html">StateArg</a> &amp;time)</td></tr>
<tr class="separator:a26af73ced485536f98bd9e46f124f0a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76f2e9b45452546eef0595a2b432a1b5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a76f2e9b45452546eef0595a2b432a1b5"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMoose_1_1FV.html#a76f2e9b45452546eef0595a2b432a1b5">interpolate</a> (const <a class="el" href="classMoose_1_1FunctorBase.html">FunctorBase</a>&lt; std::vector&lt; T &gt; &gt; &amp;functor, const <a class="el" href="structMoose_1_1FaceArg.html">FaceArg</a> &amp;face, const <a class="el" href="structMoose_1_1StateArg.html">StateArg</a> &amp;time)</td></tr>
<tr class="separator:a76f2e9b45452546eef0595a2b432a1b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46f1afeefa34be234231e44a8190c00"><td class="memTemplParams" colspan="2">template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ab46f1afeefa34be234231e44a8190c00"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; T, N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMoose_1_1FV.html#ab46f1afeefa34be234231e44a8190c00">interpolate</a> (const <a class="el" href="classMoose_1_1FunctorBase.html">FunctorBase</a>&lt; std::array&lt; T, N &gt; &gt; &amp;functor, const <a class="el" href="structMoose_1_1FaceArg.html">FaceArg</a> &amp;face, const <a class="el" href="structMoose_1_1StateArg.html">StateArg</a> &amp;time)</td></tr>
<tr class="separator:ab46f1afeefa34be234231e44a8190c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd8c3161f161cdaafa3cff4bdafd464e"><td class="memTemplParams" colspan="2">template&lt;typename SubdomainRestrictable &gt; </td></tr>
<tr class="memitem:abd8c3161f161cdaafa3cff4bdafd464e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMoose_1_1FV.html#abd8c3161f161cdaafa3cff4bdafd464e">onBoundary</a> (const SubdomainRestrictable &amp;obj, const <a class="el" href="classFaceInfo.html">FaceInfo</a> &amp;fi)</td></tr>
<tr class="memdesc:abd8c3161f161cdaafa3cff4bdafd464e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return whether the supplied face is on a boundary of the <code>object's</code> execution.  <a href="namespaceMoose_1_1FV.html#abd8c3161f161cdaafa3cff4bdafd464e">More...</a><br /></td></tr>
<tr class="separator:abd8c3161f161cdaafa3cff4bdafd464e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a3893e598130913ace9d549861d9c4035"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMooseEnum.html">MooseEnum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMoose_1_1FV.html#a3893e598130913ace9d549861d9c4035">moose_limiter_type</a></td></tr>
<tr class="separator:a3893e598130913ace9d549861d9c4035"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a5941595b238d0963e4fe80718ab7dd50" name="a5941595b238d0963e4fe80718ab7dd50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5941595b238d0963e4fe80718ab7dd50">&#9670;&#160;</a></span>InterpMethod</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespaceMoose_1_1FV.html#a5941595b238d0963e4fe80718ab7dd50">Moose::FV::InterpMethod</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This codifies a set of available ways to interpolate with elem+neighbor solution information to calculate values (e.g. </p>
<p >solution, material properties, etc.) at the face (centroid). These methods are used in the class's interpolate functions. Some interpolation methods are only meant to be used with advective terms (e.g. upwind), others are more generically applicable. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5941595b238d0963e4fe80718ab7dd50ab1897515d548a960afe49ecf66a29021" name="a5941595b238d0963e4fe80718ab7dd50ab1897515d548a960afe49ecf66a29021"></a>Average&#160;</td><td class="fielddoc"><p >gc*elem+(1-gc)*neighbor </p>
</td></tr>
<tr><td class="fieldname"><a id="a5941595b238d0963e4fe80718ab7dd50a7776c998287c8c720bd5638d3e3e61be" name="a5941595b238d0963e4fe80718ab7dd50a7776c998287c8c720bd5638d3e3e61be"></a>HarmonicAverage&#160;</td><td class="fielddoc"><p >1/(gc/elem+(1-gc)/neighbor) </p>
</td></tr>
<tr><td class="fieldname"><a id="a5941595b238d0963e4fe80718ab7dd50a09b24c3a49cf399c0cc973cab0d13e4a" name="a5941595b238d0963e4fe80718ab7dd50a09b24c3a49cf399c0cc973cab0d13e4a"></a>SkewCorrectedAverage&#160;</td><td class="fielddoc"><p >(gc*elem+(1-gc)*neighbor)+gradient*(rf-rf') </p>
</td></tr>
<tr><td class="fieldname"><a id="a5941595b238d0963e4fe80718ab7dd50a6d61af52253bb644a0c23a12513a8a76" name="a5941595b238d0963e4fe80718ab7dd50a6d61af52253bb644a0c23a12513a8a76"></a>Upwind&#160;</td><td class="fielddoc"><p >weighted </p>
</td></tr>
<tr><td class="fieldname"><a id="a5941595b238d0963e4fe80718ab7dd50a6fd4a9707e063a1fb5d86bf9e442888d" name="a5941595b238d0963e4fe80718ab7dd50a6fd4a9707e063a1fb5d86bf9e442888d"></a>RhieChow&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a5941595b238d0963e4fe80718ab7dd50af9b8010cbfb0219d361f7670afcc289f" name="a5941595b238d0963e4fe80718ab7dd50af9b8010cbfb0219d361f7670afcc289f"></a>VanLeer&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a5941595b238d0963e4fe80718ab7dd50ac7fdfb1f6f93b887ae2479d84991b1e2" name="a5941595b238d0963e4fe80718ab7dd50ac7fdfb1f6f93b887ae2479d84991b1e2"></a>MinMod&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a5941595b238d0963e4fe80718ab7dd50af3c08d92741209a11f476a78eea13191" name="a5941595b238d0963e4fe80718ab7dd50af3c08d92741209a11f476a78eea13191"></a>SOU&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a5941595b238d0963e4fe80718ab7dd50a7c77dcebcec67792afc15f80522fd945" name="a5941595b238d0963e4fe80718ab7dd50a7c77dcebcec67792afc15f80522fd945"></a>QUICK&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="MathFVUtils_8h_source.html#l00035">35</a> of file <a class="el" href="MathFVUtils_8h_source.html">MathFVUtils.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   36</span>{</div>
<div class="line"><span class="lineno">   38</span>  <a class="code hl_enumvalue" href="namespaceMoose_1_1FV.html#a5941595b238d0963e4fe80718ab7dd50ab1897515d548a960afe49ecf66a29021">Average</a>,</div>
<div class="line"><span class="lineno">   40</span>  <a class="code hl_enumvalue" href="namespaceMoose_1_1FV.html#a5941595b238d0963e4fe80718ab7dd50a7776c998287c8c720bd5638d3e3e61be">HarmonicAverage</a>,</div>
<div class="line"><span class="lineno">   42</span>  <a class="code hl_enumvalue" href="namespaceMoose_1_1FV.html#a5941595b238d0963e4fe80718ab7dd50a09b24c3a49cf399c0cc973cab0d13e4a">SkewCorrectedAverage</a>,</div>
<div class="line"><span class="lineno">   44</span>  <a class="code hl_enumvalue" href="namespaceMoose_1_1FV.html#a543ddcb0eef69b1aa6f7138b271c245ca6d61af52253bb644a0c23a12513a8a76">Upwind</a>,</div>
<div class="line"><span class="lineno">   45</span>  <span class="comment">// Rhie-Chow</span></div>
<div class="line"><span class="lineno">   46</span>  <a class="code hl_enumvalue" href="namespaceMoose_1_1FV.html#a5941595b238d0963e4fe80718ab7dd50a6fd4a9707e063a1fb5d86bf9e442888d">RhieChow</a>,</div>
<div class="line"><span class="lineno">   47</span>  <a class="code hl_enumvalue" href="namespaceMoose_1_1FV.html#a543ddcb0eef69b1aa6f7138b271c245caf9b8010cbfb0219d361f7670afcc289f">VanLeer</a>,</div>
<div class="line"><span class="lineno">   48</span>  <a class="code hl_enumvalue" href="namespaceMoose_1_1FV.html#a543ddcb0eef69b1aa6f7138b271c245cac7fdfb1f6f93b887ae2479d84991b1e2">MinMod</a>,</div>
<div class="line"><span class="lineno">   49</span>  <a class="code hl_enumvalue" href="namespaceMoose_1_1FV.html#a543ddcb0eef69b1aa6f7138b271c245caf3c08d92741209a11f476a78eea13191">SOU</a>,</div>
<div class="line"><span class="lineno">   50</span>  <a class="code hl_enumvalue" href="namespaceMoose_1_1FV.html#a543ddcb0eef69b1aa6f7138b271c245ca7c77dcebcec67792afc15f80522fd945">QUICK</a></div>
<div class="line"><span class="lineno">   51</span>};</div>
<div class="ttc" id="anamespaceMoose_1_1FV_html_a543ddcb0eef69b1aa6f7138b271c245ca6d61af52253bb644a0c23a12513a8a76"><div class="ttname"><a href="namespaceMoose_1_1FV.html#a543ddcb0eef69b1aa6f7138b271c245ca6d61af52253bb644a0c23a12513a8a76">Moose::FV::LimiterType::Upwind</a></div><div class="ttdeci">@ Upwind</div></div>
<div class="ttc" id="anamespaceMoose_1_1FV_html_a543ddcb0eef69b1aa6f7138b271c245ca7c77dcebcec67792afc15f80522fd945"><div class="ttname"><a href="namespaceMoose_1_1FV.html#a543ddcb0eef69b1aa6f7138b271c245ca7c77dcebcec67792afc15f80522fd945">Moose::FV::LimiterType::QUICK</a></div><div class="ttdeci">@ QUICK</div></div>
<div class="ttc" id="anamespaceMoose_1_1FV_html_a543ddcb0eef69b1aa6f7138b271c245cac7fdfb1f6f93b887ae2479d84991b1e2"><div class="ttname"><a href="namespaceMoose_1_1FV.html#a543ddcb0eef69b1aa6f7138b271c245cac7fdfb1f6f93b887ae2479d84991b1e2">Moose::FV::LimiterType::MinMod</a></div><div class="ttdeci">@ MinMod</div></div>
<div class="ttc" id="anamespaceMoose_1_1FV_html_a543ddcb0eef69b1aa6f7138b271c245caf3c08d92741209a11f476a78eea13191"><div class="ttname"><a href="namespaceMoose_1_1FV.html#a543ddcb0eef69b1aa6f7138b271c245caf3c08d92741209a11f476a78eea13191">Moose::FV::LimiterType::SOU</a></div><div class="ttdeci">@ SOU</div></div>
<div class="ttc" id="anamespaceMoose_1_1FV_html_a543ddcb0eef69b1aa6f7138b271c245caf9b8010cbfb0219d361f7670afcc289f"><div class="ttname"><a href="namespaceMoose_1_1FV.html#a543ddcb0eef69b1aa6f7138b271c245caf9b8010cbfb0219d361f7670afcc289f">Moose::FV::LimiterType::VanLeer</a></div><div class="ttdeci">@ VanLeer</div></div>
<div class="ttc" id="anamespaceMoose_1_1FV_html_a5941595b238d0963e4fe80718ab7dd50a09b24c3a49cf399c0cc973cab0d13e4a"><div class="ttname"><a href="namespaceMoose_1_1FV.html#a5941595b238d0963e4fe80718ab7dd50a09b24c3a49cf399c0cc973cab0d13e4a">Moose::FV::InterpMethod::SkewCorrectedAverage</a></div><div class="ttdeci">@ SkewCorrectedAverage</div><div class="ttdoc">(gc*elem+(1-gc)*neighbor)+gradient*(rf-rf')</div></div>
<div class="ttc" id="anamespaceMoose_1_1FV_html_a5941595b238d0963e4fe80718ab7dd50a6fd4a9707e063a1fb5d86bf9e442888d"><div class="ttname"><a href="namespaceMoose_1_1FV.html#a5941595b238d0963e4fe80718ab7dd50a6fd4a9707e063a1fb5d86bf9e442888d">Moose::FV::InterpMethod::RhieChow</a></div><div class="ttdeci">@ RhieChow</div></div>
<div class="ttc" id="anamespaceMoose_1_1FV_html_a5941595b238d0963e4fe80718ab7dd50a7776c998287c8c720bd5638d3e3e61be"><div class="ttname"><a href="namespaceMoose_1_1FV.html#a5941595b238d0963e4fe80718ab7dd50a7776c998287c8c720bd5638d3e3e61be">Moose::FV::InterpMethod::HarmonicAverage</a></div><div class="ttdeci">@ HarmonicAverage</div><div class="ttdoc">1/(gc/elem+(1-gc)/neighbor)</div></div>
<div class="ttc" id="anamespaceMoose_1_1FV_html_a5941595b238d0963e4fe80718ab7dd50ab1897515d548a960afe49ecf66a29021"><div class="ttname"><a href="namespaceMoose_1_1FV.html#a5941595b238d0963e4fe80718ab7dd50ab1897515d548a960afe49ecf66a29021">Moose::FV::InterpMethod::Average</a></div><div class="ttdeci">@ Average</div><div class="ttdoc">gc*elem+(1-gc)*neighbor</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a543ddcb0eef69b1aa6f7138b271c245c" name="a543ddcb0eef69b1aa6f7138b271c245c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a543ddcb0eef69b1aa6f7138b271c245c">&#9670;&#160;</a></span>LimiterType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="namespaceMoose_1_1FV.html#a543ddcb0eef69b1aa6f7138b271c245c">Moose::FV::LimiterType</a> : int</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a543ddcb0eef69b1aa6f7138b271c245caf9b8010cbfb0219d361f7670afcc289f" name="a543ddcb0eef69b1aa6f7138b271c245caf9b8010cbfb0219d361f7670afcc289f"></a>VanLeer&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a543ddcb0eef69b1aa6f7138b271c245ca6d61af52253bb644a0c23a12513a8a76" name="a543ddcb0eef69b1aa6f7138b271c245ca6d61af52253bb644a0c23a12513a8a76"></a>Upwind&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a543ddcb0eef69b1aa6f7138b271c245cac6f5d0a15fe7871f1df4eacfbf77bdf6" name="a543ddcb0eef69b1aa6f7138b271c245cac6f5d0a15fe7871f1df4eacfbf77bdf6"></a>CentralDifference&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a543ddcb0eef69b1aa6f7138b271c245cac7fdfb1f6f93b887ae2479d84991b1e2" name="a543ddcb0eef69b1aa6f7138b271c245cac7fdfb1f6f93b887ae2479d84991b1e2"></a>MinMod&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a543ddcb0eef69b1aa6f7138b271c245caf3c08d92741209a11f476a78eea13191" name="a543ddcb0eef69b1aa6f7138b271c245caf3c08d92741209a11f476a78eea13191"></a>SOU&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a543ddcb0eef69b1aa6f7138b271c245ca7c77dcebcec67792afc15f80522fd945" name="a543ddcb0eef69b1aa6f7138b271c245ca7c77dcebcec67792afc15f80522fd945"></a>QUICK&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="Limiter_8h_source.html#l00025">25</a> of file <a class="el" href="Limiter_8h_source.html">Limiter.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   26</span>{</div>
<div class="line"><span class="lineno">   27</span>  <a class="code hl_enumvalue" href="namespaceMoose_1_1FV.html#a543ddcb0eef69b1aa6f7138b271c245caf9b8010cbfb0219d361f7670afcc289f">VanLeer</a> = 0,</div>
<div class="line"><span class="lineno">   28</span>  <a class="code hl_enumvalue" href="namespaceMoose_1_1FV.html#a543ddcb0eef69b1aa6f7138b271c245ca6d61af52253bb644a0c23a12513a8a76">Upwind</a>,</div>
<div class="line"><span class="lineno">   29</span>  <a class="code hl_class" href="classCentralDifference.html">CentralDifference</a>,</div>
<div class="line"><span class="lineno">   30</span>  <a class="code hl_enumvalue" href="namespaceMoose_1_1FV.html#a543ddcb0eef69b1aa6f7138b271c245cac7fdfb1f6f93b887ae2479d84991b1e2">MinMod</a>,</div>
<div class="line"><span class="lineno">   31</span>  <a class="code hl_enumvalue" href="namespaceMoose_1_1FV.html#a543ddcb0eef69b1aa6f7138b271c245caf3c08d92741209a11f476a78eea13191">SOU</a>,</div>
<div class="line"><span class="lineno">   32</span>  <a class="code hl_enumvalue" href="namespaceMoose_1_1FV.html#a543ddcb0eef69b1aa6f7138b271c245ca7c77dcebcec67792afc15f80522fd945">QUICK</a></div>
<div class="line"><span class="lineno">   33</span>};</div>
<div class="ttc" id="aclassCentralDifference_html"><div class="ttname"><a href="classCentralDifference.html">CentralDifference</a></div><div class="ttdoc">Implements a truly explicit (no nonlinear solve) Central Difference time integration scheme.</div><div class="ttdef"><b>Definition:</b> <a href="CentralDifference_8h_source.html#l00018">CentralDifference.h:19</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ad844815080b72eb60bb577147f93e9d7" name="ad844815080b72eb60bb577147f93e9d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad844815080b72eb60bb577147f93e9d7">&#9670;&#160;</a></span>advectedInterpolationParameter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classInputParameters.html">InputParameters</a> Moose::FV::advectedInterpolationParameter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>An input parameters object that contains the <code>advected_interp_method</code> parameter, e.g. the interpolation method to use for an advected quantity </dd></dl>

<p class="definition">Definition at line <a class="el" href="MathFVUtils_8C_source.html#l00067">67</a> of file <a class="el" href="MathFVUtils_8C_source.html">MathFVUtils.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   68</span>{</div>
<div class="line"><span class="lineno">   69</span>  <span class="keyword">auto</span> params = <a class="code hl_function" href="InputParameters_8C.html#a8864a88488c3578d8422c986c15bf3a4">emptyInputParameters</a>();</div>
<div class="line"><span class="lineno">   70</span>  params.addParam&lt;<a class="code hl_class" href="classMooseEnum.html">MooseEnum</a>&gt;(</div>
<div class="line"><span class="lineno">   71</span>      <span class="stringliteral">&quot;advected_interp_method&quot;</span>,</div>
<div class="line"><span class="lineno">   72</span>      <a class="code hl_function" href="namespaceMoose_1_1FV.html#a99cdbba7e56deab1236a2ed3efac3567">interpolationMethods</a>(),</div>
<div class="line"><span class="lineno">   73</span>      <span class="stringliteral">&quot;The interpolation to use for the advected quantity. Options are &quot;</span></div>
<div class="line"><span class="lineno">   74</span>      <span class="stringliteral">&quot;&#39;upwind&#39;, &#39;average&#39;, &#39;sou&#39; (for second-order upwind), &#39;min_mod&#39;, &#39;vanLeer&#39;, &#39;quick&#39;, and &quot;</span></div>
<div class="line"><span class="lineno">   75</span>      <span class="stringliteral">&quot;&#39;skewness-corrected&#39; with the default being &#39;upwind&#39;.&quot;</span>);</div>
<div class="line"><span class="lineno">   76</span>  <span class="keywordflow">return</span> params;</div>
<div class="line"><span class="lineno">   77</span>}</div>
<div class="ttc" id="aInputParameters_8C_html_a8864a88488c3578d8422c986c15bf3a4"><div class="ttname"><a href="InputParameters_8C.html#a8864a88488c3578d8422c986c15bf3a4">emptyInputParameters</a></div><div class="ttdeci">InputParameters emptyInputParameters()</div><div class="ttdef"><b>Definition:</b> <a href="InputParameters_8C_source.html#l00028">InputParameters.C:28</a></div></div>
<div class="ttc" id="aclassMooseEnum_html"><div class="ttname"><a href="classMooseEnum.html">MooseEnum</a></div><div class="ttdoc">This is a &quot;smart&quot; enum class intended to replace many of the shortcomings in the C++ enum type It sho...</div><div class="ttdef"><b>Definition:</b> <a href="MooseEnum_8h_source.html#l00031">MooseEnum.h:32</a></div></div>
<div class="ttc" id="anamespaceMoose_1_1FV_html_a99cdbba7e56deab1236a2ed3efac3567"><div class="ttname"><a href="namespaceMoose_1_1FV.html#a99cdbba7e56deab1236a2ed3efac3567">Moose::FV::interpolationMethods</a></div><div class="ttdeci">MooseEnum interpolationMethods()</div><div class="ttdoc">Returns an enum with all the currently supported interpolation methods and the current default for FV...</div><div class="ttdef"><b>Definition:</b> <a href="MathFVUtils_8C_source.html#l00061">MathFVUtils.C:61</a></div></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="FVAdvection_8C_source.html#l00015">FVAdvection::validParams()</a>.</p>

</div>
</div>
<a id="a26af73ced485536f98bd9e46f124f0a5" name="a26af73ced485536f98bd9e46f124f0a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26af73ced485536f98bd9e46f124f0a5">&#9670;&#160;</a></span>containerInterpolate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Moose::FV::containerInterpolate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMoose_1_1FunctorBase.html">FunctorBase</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMoose_1_1FaceArg.html">FaceArg</a> &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMoose_1_1StateArg.html">StateArg</a> &amp;&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MathFVUtils_8h_source.html#l00633">633</a> of file <a class="el" href="MathFVUtils_8h_source.html">MathFVUtils.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  634</span>{</div>
<div class="line"><span class="lineno">  635</span>  <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code hl_typedef" href="classMoose_1_1FunctorBase.html#a685241a79ab4cfb9d48e761c87b665e8">FunctorBase&lt;T&gt;::GradientType</a> ContainerGradientType;</div>
<div class="line"><span class="lineno">  636</span>  <span class="keyword">typedef</span> <span class="keyword">typename</span> ContainerGradientType::value_type GradientType;</div>
<div class="line"><span class="lineno">  637</span>  <span class="keyword">const</span> GradientType * <span class="keyword">const</span> example_gradient = <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno">  638</span> </div>
<div class="line"><span class="lineno">  639</span>  mooseAssert(face.<a class="code hl_variable" href="structMoose_1_1FaceArg.html#adbe9c167b0afacad24a0ca70959d0a43">fi</a>, <span class="stringliteral">&quot;this must be non-null&quot;</span>);</div>
<div class="line"><span class="lineno">  640</span>  <span class="keyword">const</span> <span class="keyword">auto</span> limiter = <a class="code hl_class" href="classMoose_1_1FV_1_1Limiter.html">Limiter&lt;typename T::value_type&gt;::build</a>(face.<a class="code hl_variable" href="structMoose_1_1FaceArg.html#ac1c78c58d94868ff061cae2f1796544f">limiter_type</a>);</div>
<div class="line"><span class="lineno">  641</span> </div>
<div class="line"><span class="lineno">  642</span>  <span class="keyword">const</span> <span class="keyword">auto</span> upwind_arg = face.<a class="code hl_variable" href="structMoose_1_1FaceArg.html#a792bf64c2222c6158ad37ee0921d34ca">elem_is_upwind</a> ? face.<a class="code hl_function" href="structMoose_1_1FaceArg.html#a8c1e438f2efba06f4ba4436ff427034b">makeElem</a>() : face.<a class="code hl_function" href="structMoose_1_1FaceArg.html#a6b1b2bf253cb75ddb36a6ceca1f7b1f5">makeNeighbor</a>();</div>
<div class="line"><span class="lineno">  643</span>  <span class="keyword">const</span> <span class="keyword">auto</span> downwind_arg = face.<a class="code hl_variable" href="structMoose_1_1FaceArg.html#a792bf64c2222c6158ad37ee0921d34ca">elem_is_upwind</a> ? face.<a class="code hl_function" href="structMoose_1_1FaceArg.html#a6b1b2bf253cb75ddb36a6ceca1f7b1f5">makeNeighbor</a>() : face.<a class="code hl_function" href="structMoose_1_1FaceArg.html#a8c1e438f2efba06f4ba4436ff427034b">makeElem</a>();</div>
<div class="line"><span class="lineno">  644</span>  <span class="keyword">const</span> <span class="keyword">auto</span> phi_upwind = functor(upwind_arg, time);</div>
<div class="line"><span class="lineno">  645</span>  <span class="keyword">const</span> <span class="keyword">auto</span> phi_downwind = functor(downwind_arg, time);</div>
<div class="line"><span class="lineno">  646</span> </div>
<div class="line"><span class="lineno">  647</span>  <span class="comment">// initialize in order to get proper size</span></div>
<div class="line"><span class="lineno">  648</span>  T ret = phi_upwind;</div>
<div class="line"><span class="lineno">  649</span>  <span class="keyword">typename</span> T::value_type coeff_upwind, coeff_downwind;</div>
<div class="line"><span class="lineno">  650</span> </div>
<div class="line"><span class="lineno">  651</span>  <span class="keywordflow">if</span> (face.<a class="code hl_variable" href="structMoose_1_1FaceArg.html#ac1c78c58d94868ff061cae2f1796544f">limiter_type</a> == LimiterType::Upwind ||</div>
<div class="line"><span class="lineno">  652</span>      face.<a class="code hl_variable" href="structMoose_1_1FaceArg.html#ac1c78c58d94868ff061cae2f1796544f">limiter_type</a> == LimiterType::CentralDifference)</div>
<div class="line"><span class="lineno">  653</span>  {</div>
<div class="line"><span class="lineno">  654</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : index_range(ret))</div>
<div class="line"><span class="lineno">  655</span>    {</div>
<div class="line"><span class="lineno">  656</span>      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;component_upwind = phi_upwind[i], component_downwind = phi_downwind[i];</div>
<div class="line"><span class="lineno">  657</span>      std::tie(coeff_upwind, coeff_downwind) = <a class="code hl_function" href="namespaceMoose_1_1FV.html#aa8e347c5804ee209112eea6eab0a466f">interpCoeffs</a>(*limiter,</div>
<div class="line"><span class="lineno">  658</span>                                                            component_upwind,</div>
<div class="line"><span class="lineno">  659</span>                                                            component_downwind,</div>
<div class="line"><span class="lineno">  660</span>                                                            example_gradient,</div>
<div class="line"><span class="lineno">  661</span>                                                            *face.<a class="code hl_variable" href="structMoose_1_1FaceArg.html#adbe9c167b0afacad24a0ca70959d0a43">fi</a>,</div>
<div class="line"><span class="lineno">  662</span>                                                            face.<a class="code hl_variable" href="structMoose_1_1FaceArg.html#a792bf64c2222c6158ad37ee0921d34ca">elem_is_upwind</a>);</div>
<div class="line"><span class="lineno">  663</span>      ret[i] = coeff_upwind * component_upwind + coeff_downwind * component_downwind;</div>
<div class="line"><span class="lineno">  664</span>    }</div>
<div class="line"><span class="lineno">  665</span>  }</div>
<div class="line"><span class="lineno">  666</span>  <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  667</span>  {</div>
<div class="line"><span class="lineno">  668</span>    <span class="keyword">const</span> <span class="keyword">auto</span> grad_phi_upwind = functor.<a class="code hl_function" href="classMoose_1_1FunctorBase.html#aa28f70bdf3145308d437a8d8f26fa364">gradient</a>(upwind_arg, time);</div>
<div class="line"><span class="lineno">  669</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : index_range(ret))</div>
<div class="line"><span class="lineno">  670</span>    {</div>
<div class="line"><span class="lineno">  671</span>      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;component_upwind = phi_upwind[i], component_downwind = phi_downwind[i];</div>
<div class="line"><span class="lineno">  672</span>      <span class="keyword">const</span> <span class="keyword">auto</span> &amp; grad = grad_phi_upwind[i];</div>
<div class="line"><span class="lineno">  673</span>      std::tie(coeff_upwind, coeff_downwind) = interpCoeffs(</div>
<div class="line"><span class="lineno">  674</span>          *limiter, component_upwind, component_downwind, &amp;grad, *face.<a class="code hl_variable" href="structMoose_1_1FaceArg.html#adbe9c167b0afacad24a0ca70959d0a43">fi</a>, face.<a class="code hl_variable" href="structMoose_1_1FaceArg.html#a792bf64c2222c6158ad37ee0921d34ca">elem_is_upwind</a>);</div>
<div class="line"><span class="lineno">  675</span>      ret[i] = coeff_upwind * component_upwind + coeff_downwind * component_downwind;</div>
<div class="line"><span class="lineno">  676</span>    }</div>
<div class="line"><span class="lineno">  677</span>  }</div>
<div class="line"><span class="lineno">  678</span> </div>
<div class="line"><span class="lineno">  679</span>  <span class="keywordflow">return</span> ret;</div>
<div class="line"><span class="lineno">  680</span>}</div>
<div class="ttc" id="aclassMoose_1_1FV_1_1Limiter_html"><div class="ttname"><a href="classMoose_1_1FV_1_1Limiter.html">Moose::FV::Limiter</a></div><div class="ttdoc">Base class for defining slope limiters for finite volume or potentially reconstructed Discontinuous-G...</div><div class="ttdef"><b>Definition:</b> <a href="Limiter_8h_source.html#l00060">Limiter.h:61</a></div></div>
<div class="ttc" id="aclassMoose_1_1FunctorBase_html_a685241a79ab4cfb9d48e761c87b665e8"><div class="ttname"><a href="classMoose_1_1FunctorBase.html#a685241a79ab4cfb9d48e761c87b665e8">Moose::FunctorBase::GradientType</a></div><div class="ttdeci">typename MetaPhysicL::ReplaceAlgebraicType&lt; T, typename TensorTools::IncrementRank&lt; typename MetaPhysicL::ValueType&lt; T &gt;::type &gt;::type &gt;::type GradientType</div><div class="ttdoc">This rigmarole makes it so that a user can create functors that return containers (std::vector,...</div><div class="ttdef"><b>Definition:</b> <a href="MooseFunctor_8h_source.html#l00064">MooseFunctor.h:66</a></div></div>
<div class="ttc" id="aclassMoose_1_1FunctorBase_html_aa28f70bdf3145308d437a8d8f26fa364"><div class="ttname"><a href="classMoose_1_1FunctorBase.html#aa28f70bdf3145308d437a8d8f26fa364">Moose::FunctorBase::gradient</a></div><div class="ttdeci">GradientType gradient(const ElemArg &amp;elem, const StateArg &amp;state) const</div><div class="ttdoc">Same as their evaluateGradient overloads with the same arguments but allows for caching implementatio...</div><div class="ttdef"><b>Definition:</b> <a href="MooseFunctor_8h_source.html#l00739">MooseFunctor.h:739</a></div></div>
<div class="ttc" id="anamespaceMoose_1_1FV_html_aa8e347c5804ee209112eea6eab0a466f"><div class="ttname"><a href="namespaceMoose_1_1FV.html#aa8e347c5804ee209112eea6eab0a466f">Moose::FV::interpCoeffs</a></div><div class="ttdeci">std::pair&lt; Real, Real &gt; interpCoeffs(const InterpMethod m, const FaceInfo &amp;fi, const bool one_is_elem, const Vector advector=Vector())</div><div class="ttdoc">Produce the interpolation coefficients in the equation:</div><div class="ttdef"><b>Definition:</b> <a href="MathFVUtils_8h_source.html#l00104">MathFVUtils.h:104</a></div></div>
<div class="ttc" id="astructMoose_1_1FaceArg_html_a6b1b2bf253cb75ddb36a6ceca1f7b1f5"><div class="ttname"><a href="structMoose_1_1FaceArg.html#a6b1b2bf253cb75ddb36a6ceca1f7b1f5">Moose::FaceArg::makeNeighbor</a></div><div class="ttdeci">ElemArg makeNeighbor() const</div><div class="ttdoc">Make a ElemArg from our data using the face information neighbor.</div><div class="ttdef"><b>Definition:</b> <a href="MooseFunctorArguments_8h_source.html#l00120">MooseFunctorArguments.h:120</a></div></div>
<div class="ttc" id="astructMoose_1_1FaceArg_html_a792bf64c2222c6158ad37ee0921d34ca"><div class="ttname"><a href="structMoose_1_1FaceArg.html#a792bf64c2222c6158ad37ee0921d34ca">Moose::FaceArg::elem_is_upwind</a></div><div class="ttdeci">bool elem_is_upwind</div><div class="ttdoc">a boolean which states whether the face information element is upwind of the face</div><div class="ttdef"><b>Definition:</b> <a href="MooseFunctorArguments_8h_source.html#l00091">MooseFunctorArguments.h:91</a></div></div>
<div class="ttc" id="astructMoose_1_1FaceArg_html_a8c1e438f2efba06f4ba4436ff427034b"><div class="ttname"><a href="structMoose_1_1FaceArg.html#a8c1e438f2efba06f4ba4436ff427034b">Moose::FaceArg::makeElem</a></div><div class="ttdeci">ElemArg makeElem() const</div><div class="ttdoc">Make a ElemArg from our data using the face information element.</div><div class="ttdef"><b>Definition:</b> <a href="MooseFunctorArguments_8h_source.html#l00115">MooseFunctorArguments.h:115</a></div></div>
<div class="ttc" id="astructMoose_1_1FaceArg_html_ac1c78c58d94868ff061cae2f1796544f"><div class="ttname"><a href="structMoose_1_1FaceArg.html#ac1c78c58d94868ff061cae2f1796544f">Moose::FaceArg::limiter_type</a></div><div class="ttdeci">Moose::FV::LimiterType limiter_type</div><div class="ttdoc">a limiter which defines how the functor evaluated on either side of the face should be interpolated t...</div><div class="ttdef"><b>Definition:</b> <a href="MooseFunctorArguments_8h_source.html#l00088">MooseFunctorArguments.h:88</a></div></div>
<div class="ttc" id="astructMoose_1_1FaceArg_html_adbe9c167b0afacad24a0ca70959d0a43"><div class="ttname"><a href="structMoose_1_1FaceArg.html#adbe9c167b0afacad24a0ca70959d0a43">Moose::FaceArg::fi</a></div><div class="ttdeci">const FaceInfo * fi</div><div class="ttdoc">a face information object which defines our location in space</div><div class="ttdef"><b>Definition:</b> <a href="MooseFunctorArguments_8h_source.html#l00084">MooseFunctorArguments.h:84</a></div></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="MathFVUtils_8h_source.html#l00684">interpolate()</a>.</p>

</div>
</div>
<a id="ad0bb339b33520523cbb821268b82f96f" name="ad0bb339b33520523cbb821268b82f96f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0bb339b33520523cbb821268b82f96f">&#9670;&#160;</a></span>determineElemOneAndTwo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; const Elem *, const Elem *, bool &gt; Moose::FV::determineElemOneAndTwo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFaceInfo.html">FaceInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>fi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMooseVariableFV.html">MooseVariableFV</a>&lt; OutputType &gt; &amp;&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This utility determines element one and element two given a <code><a class="el" href="classFaceInfo.html" title="This data structure is used to store geometric and variable related metadata about each cell face in ...">FaceInfo</a></code> <code>fi</code> and variable <code>var</code>. </p>
<p >You may ask what in the world "element one" and "element two" means, and that would be a very good question. What it means is: a variable will <em>always</em> have degrees of freedom on element one. A variable may or may not have degrees of freedom on element two. So we are introducing a second terminology here. <a class="el" href="classFaceInfo.html" title="This data structure is used to store geometric and variable related metadata about each cell face in ...">FaceInfo</a> geometric objects have element-neighbor pairs. These element-neighbor pairs are purely geometric and have no relation to the algebraic system of variables. The elem1-elem2 notation introduced here is based on dof/algebraic information and may very well be different from variable to variable, e.g. elem1 may correspond to the <a class="el" href="classFaceInfo.html" title="This data structure is used to store geometric and variable related metadata about each cell face in ...">FaceInfo</a> elem for one variable (and correspondingly elem2 will be the <a class="el" href="classFaceInfo.html" title="This data structure is used to store geometric and variable related metadata about each cell face in ...">FaceInfo</a> neighbor), but elem1 may correspond to the <a class="el" href="classFaceInfo.html" title="This data structure is used to store geometric and variable related metadata about each cell face in ...">FaceInfo</a> neighbor for another variable (and correspondingly for <em>that</em> variable elem2 will be the <a class="el" href="classFaceInfo.html" title="This data structure is used to store geometric and variable related metadata about each cell face in ...">FaceInfo</a> elem). </p><dl class="section return"><dt>Returns</dt><dd>A tuple, where the first item is elem1, the second item is elem2, and the third item is a boolean indicating whether elem1 corresponds to the <a class="el" href="classFaceInfo.html" title="This data structure is used to store geometric and variable related metadata about each cell face in ...">FaceInfo</a> elem </dd></dl>

<p class="definition">Definition at line <a class="el" href="FVUtils_8C_source.html#l00038">38</a> of file <a class="el" href="FVUtils_8C_source.html">FVUtils.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   39</span>{</div>
<div class="line"><span class="lineno">   40</span>  <span class="keyword">auto</span> ft = fi.<a class="code hl_function" href="classFaceInfo.html#a3fc67abab73d4ce5cf3bd84c23f1416f">faceType</a>(std::make_pair(var.<a class="code hl_function" href="classMooseVariableBase.html#af094500e7269f8eb04a07436a95eb375">number</a>(), var.<a class="code hl_function" href="classMooseVariableBase.html#aa4839fdc7c27c696c5d0f47416a053a5">sys</a>().<a class="code hl_function" href="classSystemBase.html#a453f105633e49c69f934c1c5409c26fa">number</a>()));</div>
<div class="line"><span class="lineno">   41</span>  mooseAssert(ft == <a class="code hl_enumvalue" href="classFaceInfo.html#abc69788d7a7d2b4f238e97a058955638a6328e5e3186c227a021ef2ff77e40197">FaceInfo::VarFaceNeighbors::BOTH</a></div>
<div class="line"><span class="lineno">   42</span>                  ? var.<a class="code hl_function" href="classMooseVariableField.html#ad02712221b443c0542d2614b668328ff">hasBlocks</a>(fi.<a class="code hl_function" href="classFaceInfo.html#a788618599b20801c4ffa18a6280c9eaa">elem</a>().subdomain_id()) &amp;&amp; fi.<a class="code hl_function" href="classFaceInfo.html#a7dd2001b1afc2d5c9069924ff6889990">neighborPtr</a>() &amp;&amp;</div>
<div class="line"><span class="lineno">   43</span>                        var.<a class="code hl_function" href="classMooseVariableField.html#ad02712221b443c0542d2614b668328ff">hasBlocks</a>(fi.<a class="code hl_function" href="classFaceInfo.html#a7dd2001b1afc2d5c9069924ff6889990">neighborPtr</a>()-&gt;subdomain_id())</div>
<div class="line"><span class="lineno">   44</span>                  : <span class="keyword">true</span>,</div>
<div class="line"><span class="lineno">   45</span>              <span class="stringliteral">&quot;Finite volume variable &quot;</span> &lt;&lt; var.<a class="code hl_function" href="classMooseVariableBase.html#ac4a8e64d12402e02d1c7dd4784fc6679">name</a>()</div>
<div class="line"><span class="lineno">   46</span>                                        &lt;&lt; <span class="stringliteral">&quot; does not exist on both sides of the face despite &quot;</span></div>
<div class="line"><span class="lineno">   47</span>                                           <span class="stringliteral">&quot;what the FaceInfo is telling us.&quot;</span>);</div>
<div class="line"><span class="lineno">   48</span>  mooseAssert(ft == <a class="code hl_enumvalue" href="classFaceInfo.html#abc69788d7a7d2b4f238e97a058955638ad3e3387a4f355276d41eefead65395c5">FaceInfo::VarFaceNeighbors::ELEM</a></div>
<div class="line"><span class="lineno">   49</span>                  ? var.<a class="code hl_function" href="classMooseVariableField.html#ad02712221b443c0542d2614b668328ff">hasBlocks</a>(fi.<a class="code hl_function" href="classFaceInfo.html#a788618599b20801c4ffa18a6280c9eaa">elem</a>().subdomain_id()) &amp;&amp;</div>
<div class="line"><span class="lineno">   50</span>                        (!fi.<a class="code hl_function" href="classFaceInfo.html#a7dd2001b1afc2d5c9069924ff6889990">neighborPtr</a>() || !var.<a class="code hl_function" href="classMooseVariableField.html#ad02712221b443c0542d2614b668328ff">hasBlocks</a>(fi.<a class="code hl_function" href="classFaceInfo.html#a7dd2001b1afc2d5c9069924ff6889990">neighborPtr</a>()-&gt;subdomain_id()))</div>
<div class="line"><span class="lineno">   51</span>                  : <span class="keyword">true</span>,</div>
<div class="line"><span class="lineno">   52</span>              <span class="stringliteral">&quot;Finite volume variable &quot;</span> &lt;&lt; var.<a class="code hl_function" href="classMooseVariableBase.html#ac4a8e64d12402e02d1c7dd4784fc6679">name</a>()</div>
<div class="line"><span class="lineno">   53</span>                                        &lt;&lt; <span class="stringliteral">&quot; does not exist on or only on the elem side of the &quot;</span></div>
<div class="line"><span class="lineno">   54</span>                                           <span class="stringliteral">&quot;face despite what the FaceInfo is telling us.&quot;</span>);</div>
<div class="line"><span class="lineno">   55</span>  mooseAssert(ft == <a class="code hl_enumvalue" href="classFaceInfo.html#abc69788d7a7d2b4f238e97a058955638ae9b0a9b9d426267ff76935bfa4aa75d0">FaceInfo::VarFaceNeighbors::NEIGHBOR</a></div>
<div class="line"><span class="lineno">   56</span>                  ? fi.<a class="code hl_function" href="classFaceInfo.html#a7dd2001b1afc2d5c9069924ff6889990">neighborPtr</a>() &amp;&amp; var.<a class="code hl_function" href="classMooseVariableField.html#ad02712221b443c0542d2614b668328ff">hasBlocks</a>(fi.<a class="code hl_function" href="classFaceInfo.html#a7dd2001b1afc2d5c9069924ff6889990">neighborPtr</a>()-&gt;subdomain_id()) &amp;&amp;</div>
<div class="line"><span class="lineno">   57</span>                        !var.<a class="code hl_function" href="classMooseVariableField.html#ad02712221b443c0542d2614b668328ff">hasBlocks</a>(fi.<a class="code hl_function" href="classFaceInfo.html#a788618599b20801c4ffa18a6280c9eaa">elem</a>().subdomain_id())</div>
<div class="line"><span class="lineno">   58</span>                  : <span class="keyword">true</span>,</div>
<div class="line"><span class="lineno">   59</span>              <span class="stringliteral">&quot;Finite volume variable &quot;</span> &lt;&lt; var.<a class="code hl_function" href="classMooseVariableBase.html#ac4a8e64d12402e02d1c7dd4784fc6679">name</a>()</div>
<div class="line"><span class="lineno">   60</span>                                        &lt;&lt; <span class="stringliteral">&quot; does not exist on or only on the neighbor side of the &quot;</span></div>
<div class="line"><span class="lineno">   61</span>                                           <span class="stringliteral">&quot;face despite what the FaceInfo is telling us.&quot;</span>);</div>
<div class="line"><span class="lineno">   62</span> </div>
<div class="line"><span class="lineno">   63</span>  <span class="keyword">const</span> <span class="keywordtype">bool</span> one_is_elem =</div>
<div class="line"><span class="lineno">   64</span>      ft == <a class="code hl_enumvalue" href="classFaceInfo.html#abc69788d7a7d2b4f238e97a058955638a6328e5e3186c227a021ef2ff77e40197">FaceInfo::VarFaceNeighbors::BOTH</a> || ft == <a class="code hl_enumvalue" href="classFaceInfo.html#abc69788d7a7d2b4f238e97a058955638ad3e3387a4f355276d41eefead65395c5">FaceInfo::VarFaceNeighbors::ELEM</a>;</div>
<div class="line"><span class="lineno">   65</span>  <span class="keyword">const</span> Elem * <span class="keyword">const</span> elem_one = one_is_elem ? &amp;fi.<a class="code hl_function" href="classFaceInfo.html#a788618599b20801c4ffa18a6280c9eaa">elem</a>() : fi.<a class="code hl_function" href="classFaceInfo.html#a7dd2001b1afc2d5c9069924ff6889990">neighborPtr</a>();</div>
<div class="line"><span class="lineno">   66</span>  mooseAssert(elem_one, <span class="stringliteral">&quot;This elem should be non-null!&quot;</span>);</div>
<div class="line"><span class="lineno">   67</span>  <span class="keyword">const</span> Elem * <span class="keyword">const</span> elem_two = one_is_elem ? fi.<a class="code hl_function" href="classFaceInfo.html#a7dd2001b1afc2d5c9069924ff6889990">neighborPtr</a>() : &amp;fi.<a class="code hl_function" href="classFaceInfo.html#a788618599b20801c4ffa18a6280c9eaa">elem</a>();</div>
<div class="line"><span class="lineno">   68</span> </div>
<div class="line"><span class="lineno">   69</span>  <span class="keywordflow">return</span> std::make_tuple(elem_one, elem_two, one_is_elem);</div>
<div class="line"><span class="lineno">   70</span>}</div>
<div class="ttc" id="aclassFaceInfo_html_a3fc67abab73d4ce5cf3bd84c23f1416f"><div class="ttname"><a href="classFaceInfo.html#a3fc67abab73d4ce5cf3bd84c23f1416f">FaceInfo::faceType</a></div><div class="ttdeci">VarFaceNeighbors faceType(const std::pair&lt; unsigned int, unsigned int &gt; &amp;var_sys) const</div><div class="ttdoc">Returns which side(s) the given variable-system number pair is defined on for this face.</div><div class="ttdef"><b>Definition:</b> <a href="FaceInfo_8h_source.html#l00214">FaceInfo.h:214</a></div></div>
<div class="ttc" id="aclassFaceInfo_html_a788618599b20801c4ffa18a6280c9eaa"><div class="ttname"><a href="classFaceInfo.html#a788618599b20801c4ffa18a6280c9eaa">FaceInfo::elem</a></div><div class="ttdeci">const Elem &amp; elem() const</div><div class="ttdef"><b>Definition:</b> <a href="FaceInfo_8h_source.html#l00080">FaceInfo.h:80</a></div></div>
<div class="ttc" id="aclassFaceInfo_html_a7dd2001b1afc2d5c9069924ff6889990"><div class="ttname"><a href="classFaceInfo.html#a7dd2001b1afc2d5c9069924ff6889990">FaceInfo::neighborPtr</a></div><div class="ttdeci">const Elem * neighborPtr() const</div><div class="ttdef"><b>Definition:</b> <a href="FaceInfo_8h_source.html#l00083">FaceInfo.h:83</a></div></div>
<div class="ttc" id="aclassFaceInfo_html_abc69788d7a7d2b4f238e97a058955638a6328e5e3186c227a021ef2ff77e40197"><div class="ttname"><a href="classFaceInfo.html#abc69788d7a7d2b4f238e97a058955638a6328e5e3186c227a021ef2ff77e40197">FaceInfo::VarFaceNeighbors::BOTH</a></div><div class="ttdeci">@ BOTH</div></div>
<div class="ttc" id="aclassFaceInfo_html_abc69788d7a7d2b4f238e97a058955638ad3e3387a4f355276d41eefead65395c5"><div class="ttname"><a href="classFaceInfo.html#abc69788d7a7d2b4f238e97a058955638ad3e3387a4f355276d41eefead65395c5">FaceInfo::VarFaceNeighbors::ELEM</a></div><div class="ttdeci">@ ELEM</div></div>
<div class="ttc" id="aclassFaceInfo_html_abc69788d7a7d2b4f238e97a058955638ae9b0a9b9d426267ff76935bfa4aa75d0"><div class="ttname"><a href="classFaceInfo.html#abc69788d7a7d2b4f238e97a058955638ae9b0a9b9d426267ff76935bfa4aa75d0">FaceInfo::VarFaceNeighbors::NEIGHBOR</a></div><div class="ttdeci">@ NEIGHBOR</div></div>
<div class="ttc" id="aclassMooseVariableBase_html_aa4839fdc7c27c696c5d0f47416a053a5"><div class="ttname"><a href="classMooseVariableBase.html#aa4839fdc7c27c696c5d0f47416a053a5">MooseVariableBase::sys</a></div><div class="ttdeci">SystemBase &amp; sys()</div><div class="ttdoc">Get the system this variable is part of.</div><div class="ttdef"><b>Definition:</b> <a href="MooseVariableBase_8h_source.html#l00059">MooseVariableBase.h:59</a></div></div>
<div class="ttc" id="aclassMooseVariableBase_html_ac4a8e64d12402e02d1c7dd4784fc6679"><div class="ttname"><a href="classMooseVariableBase.html#ac4a8e64d12402e02d1c7dd4784fc6679">MooseVariableBase::name</a></div><div class="ttdeci">const std::string &amp; name() const override</div><div class="ttdoc">Get the variable name.</div><div class="ttdef"><b>Definition:</b> <a href="MooseVariableBase_8h_source.html#l00069">MooseVariableBase.h:69</a></div></div>
<div class="ttc" id="aclassMooseVariableBase_html_af094500e7269f8eb04a07436a95eb375"><div class="ttname"><a href="classMooseVariableBase.html#af094500e7269f8eb04a07436a95eb375">MooseVariableBase::number</a></div><div class="ttdeci">unsigned int number() const</div><div class="ttdoc">Get variable number coming from libMesh.</div><div class="ttdef"><b>Definition:</b> <a href="MooseVariableBase_8h_source.html#l00049">MooseVariableBase.h:49</a></div></div>
<div class="ttc" id="aclassMooseVariableField_html_ad02712221b443c0542d2614b668328ff"><div class="ttname"><a href="classMooseVariableField.html#ad02712221b443c0542d2614b668328ff">MooseVariableField::hasBlocks</a></div><div class="ttdeci">bool hasBlocks(const SubdomainID id) const override</div><div class="ttdoc">Returns whether the functor is defined on this block.</div><div class="ttdef"><b>Definition:</b> <a href="MooseVariableField_8h_source.html#l00370">MooseVariableField.h:370</a></div></div>
<div class="ttc" id="aclassSystemBase_html_a453f105633e49c69f934c1c5409c26fa"><div class="ttname"><a href="classSystemBase.html#a453f105633e49c69f934c1c5409c26fa">SystemBase::number</a></div><div class="ttdeci">unsigned int number() const</div><div class="ttdoc">Gets the number of this system.</div><div class="ttdef"><b>Definition:</b> <a href="SystemBase_8C_source.html#l01125">SystemBase.C:1125</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a9c7ee0e080c3ab4e65ac09c550748927" name="a9c7ee0e080c3ab4e65ac09c550748927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c7ee0e080c3ab4e65ac09c550748927">&#9670;&#160;</a></span>determineElemOneAndTwo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template std::tuple&lt; const Elem *, const Elem *, bool &gt; Moose::FV::determineElemOneAndTwo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFaceInfo.html">FaceInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>fi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMooseVariableFV.html">MooseVariableFV</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>var</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a31abd59f95d9b6db2c0306c2480af237" name="a31abd59f95d9b6db2c0306c2480af237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31abd59f95d9b6db2c0306c2480af237">&#9670;&#160;</a></span>elemHasFaceInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Moose::FV::elemHasFaceInfo </td>
          <td>(</td>
          <td class="paramtype">const Elem &amp;&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Elem *const&#160;</td>
          <td class="paramname"><em>neighbor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function infers based on elements if the faceinfo between them belongs to the element or not. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elem</td><td>Reference to an element </td></tr>
    <tr><td class="paramname">neighbor</td><td>Pointer to the neighbor of the element </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the element (first argument) is the owner of the faceinfo between the two elements </dd></dl>

<p class="definition">Definition at line <a class="el" href="FVUtils_8C_source.html#l00020">20</a> of file <a class="el" href="FVUtils_8C_source.html">FVUtils.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   21</span>{</div>
<div class="line"><span class="lineno">   22</span>  <span class="comment">// The face info belongs to elem:</span></div>
<div class="line"><span class="lineno">   23</span>  <span class="comment">//  * at all mesh boundaries (i.e. where there is no neighbor)</span></div>
<div class="line"><span class="lineno">   24</span>  <span class="comment">//  * if the element faces a neighbor which is on a lower refinement level</span></div>
<div class="line"><span class="lineno">   25</span>  <span class="comment">//  * if the element is active and it has a lower ID than its neighbor</span></div>
<div class="line"><span class="lineno">   26</span>  <span class="keywordflow">if</span> (!neighbor)</div>
<div class="line"><span class="lineno">   27</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">   28</span>  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (elem.level() != neighbor-&gt;level())</div>
<div class="line"><span class="lineno">   29</span>    <span class="keywordflow">return</span> neighbor-&gt;level() &lt; elem.level();</div>
<div class="line"><span class="lineno">   30</span>  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!neighbor-&gt;active())</div>
<div class="line"><span class="lineno">   31</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">   32</span>  <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">   33</span>    <span class="keywordflow">return</span> elem.id() &lt; neighbor-&gt;id();</div>
<div class="line"><span class="lineno">   34</span>}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="MooseMesh_8C_source.html#l03476">MooseMesh::buildFiniteVolumeInfo()</a>, and <a class="el" href="FVUtils_8h_source.html#l00039">loopOverElemFaceInfo()</a>.</p>

</div>
</div>
<a id="a3d3c061e6e9f6aeb6defdfceec29d3bb" name="a3d3c061e6e9f6aeb6defdfceec29d3bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d3c061e6e9f6aeb6defdfceec29d3bb">&#9670;&#160;</a></span>gradUDotNormal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ADRealForward_8h.html#aad0af4d0bfc617796dd28a541448a4e5">ADReal</a> Moose::FV::gradUDotNormal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFaceInfo.html">FaceInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>face_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMooseVariableFV.html">MooseVariableFV</a>&lt; Real &gt; &amp;&#160;</td>
          <td class="paramname"><em>fv_var</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMoose_1_1StateArg.html">Moose::StateArg</a> &amp;&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>correct_skewness</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates and returns "grad_u dot normal" on the face to be used for diffusive terms. </p>
<p >If using any cross-diffusion corrections, etc. all those calculations should be handled appropriately by this function. </p>

<p class="definition">Definition at line <a class="el" href="MathFVUtils_8C_source.html#l00018">18</a> of file <a class="el" href="MathFVUtils_8C_source.html">MathFVUtils.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   23</span>{</div>
<div class="line"><span class="lineno">   24</span>  <span class="keywordflow">return</span> fv_var.<a class="code hl_function" href="classMooseVariableFV.html#ae285a2f13d1651e1d220298e61c8b8f6">adGradSln</a>(face_info, time, correct_skewness) * face_info.<a class="code hl_function" href="classFaceInfo.html#a207d78600df922cedd8b08421f87f655">normal</a>();</div>
<div class="line"><span class="lineno">   25</span>}</div>
<div class="ttc" id="aclassFaceInfo_html_a207d78600df922cedd8b08421f87f655"><div class="ttname"><a href="classFaceInfo.html#a207d78600df922cedd8b08421f87f655">FaceInfo::normal</a></div><div class="ttdeci">const Point &amp; normal() const</div><div class="ttdoc">Returns the unit normal vector for the face oriented outward from the face's elem element.</div><div class="ttdef"><b>Definition:</b> <a href="FaceInfo_8h_source.html#l00067">FaceInfo.h:67</a></div></div>
<div class="ttc" id="aclassMooseVariableFV_html_ae285a2f13d1651e1d220298e61c8b8f6"><div class="ttname"><a href="classMooseVariableFV.html#ae285a2f13d1651e1d220298e61c8b8f6">MooseVariableFV::adGradSln</a></div><div class="ttdeci">const ADTemplateVariableGradient&lt; OutputType &gt; &amp; adGradSln() const override</div><div class="ttdoc">AD grad solution getter.</div><div class="ttdef"><b>Definition:</b> <a href="MooseVariableFV_8h_source.html#l00263">MooseVariableFV.h:263</a></div></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="FVFluxKernel_8C_source.html#l00224">FVFluxKernel::gradUDotNormal()</a>.</p>

</div>
</div>
<a id="a9390f7c56eb001f809b1a40e6568008e" name="a9390f7c56eb001f809b1a40e6568008e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9390f7c56eb001f809b1a40e6568008e">&#9670;&#160;</a></span>greenGaussGradient() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Enable  = typename std::enable_if&lt;ScalarTraits&lt;T&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VectorValue&lt; T &gt; Moose::FV::greenGaussGradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMoose_1_1ElemArg.html">ElemArg</a> &amp;&#160;</td>
          <td class="paramname"><em>elem_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMoose_1_1StateArg.html">StateArg</a> &amp;&#160;</td>
          <td class="paramname"><em>state_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMoose_1_1FunctorBase.html">FunctorBase</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>two_term_boundary_expansion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMooseMesh.html">MooseMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a cell gradient using the method of Green-Gauss. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elem_arg</td><td>An element argument specifying the current element and whether to perform skew corrections </td></tr>
    <tr><td class="paramname">state_arg</td><td>A state argument that indicates what temporal / solution iteration data to use when evaluating the provided functor </td></tr>
    <tr><td class="paramname">functor</td><td>The functor that will provide information such as cell and face value evaluations necessary to construct the cell gradient </td></tr>
    <tr><td class="paramname">two_term_boundary_expansion</td><td>Whether to perform a two-term expansion to compute extrapolated boundary face values. If this is true, then an implicit system has to be solved. If false, then the cell center value will be used as the extrapolated boundary face value </td></tr>
    <tr><td class="paramname">mesh</td><td>The mesh on which we are computing the gradient </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The computed cell gradient </dd></dl>

<p class="definition">Definition at line <a class="el" href="GreenGaussGradient_8h_source.html#l00040">40</a> of file <a class="el" href="GreenGaussGradient_8h_source.html">GreenGaussGradient.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   45</span>{</div>
<div class="line"><span class="lineno">   46</span>  mooseAssert(elem_arg.<a class="code hl_variable" href="structMoose_1_1ElemArg.html#a7d2d33f2d18ad7b62273afa16d14d393">elem</a>, <span class="stringliteral">&quot;This should be non-null&quot;</span>);</div>
<div class="line"><span class="lineno">   47</span>  <span class="keyword">const</span> <span class="keyword">auto</span> coord_type = mesh.<a class="code hl_function" href="classMooseMesh.html#a9728c2d118346e46054d3352e92af6b1">getCoordSystem</a>(elem_arg.<a class="code hl_variable" href="structMoose_1_1ElemArg.html#a7d2d33f2d18ad7b62273afa16d14d393">elem</a>-&gt;subdomain_id());</div>
<div class="line"><span class="lineno">   48</span>  <span class="keyword">const</span> <span class="keyword">auto</span> rz_radial_coord = mesh.<a class="code hl_function" href="classMooseMesh.html#a0fdf1cce97ad1421fa00c8621865ca07">getAxisymmetricRadialCoord</a>();</div>
<div class="line"><span class="lineno">   49</span> </div>
<div class="line"><span class="lineno">   50</span>  T elem_value = functor(elem_arg, state_arg);</div>
<div class="line"><span class="lineno">   51</span> </div>
<div class="line"><span class="lineno">   52</span>  <span class="comment">// We&#39;ll count the extrapolated boundaries</span></div>
<div class="line"><span class="lineno">   53</span>  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> num_ebfs = 0;</div>
<div class="line"><span class="lineno">   54</span> </div>
<div class="line"><span class="lineno">   55</span>  <span class="keywordflow">try</span></div>
<div class="line"><span class="lineno">   56</span>  {</div>
<div class="line"><span class="lineno">   57</span>    VectorValue&lt;T&gt; grad;</div>
<div class="line"><span class="lineno">   58</span> </div>
<div class="line"><span class="lineno">   59</span>    <span class="keywordtype">bool</span> volume_set = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">   60</span>    Real volume = 0;</div>
<div class="line"><span class="lineno">   61</span> </div>
<div class="line"><span class="lineno">   62</span>    <span class="comment">// If we are performing a two term Taylor expansion for extrapolated boundary faces (faces on</span></div>
<div class="line"><span class="lineno">   63</span>    <span class="comment">// boundaries that do not have associated Dirichlet conditions), then the element gradient</span></div>
<div class="line"><span class="lineno">   64</span>    <span class="comment">// depends on the boundary face value and the boundary face value depends on the element</span></div>
<div class="line"><span class="lineno">   65</span>    <span class="comment">// gradient, so we have a system of equations to solve. Here is the system:</span></div>
<div class="line"><span class="lineno">   66</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno">   67</span>    <span class="comment">// \nabla \phi_C - \frac{1}{V} \sum_{ebf} \phi_{ebf} \vec{S_f} =</span></div>
<div class="line"><span class="lineno">   68</span>    <span class="comment">//   \frac{1}{V} \sum_{of} \phi_{of} \vec{S_f}                       eqn. 1</span></div>
<div class="line"><span class="lineno">   69</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno">   70</span>    <span class="comment">// \phi_{ebf} - \vec{d_{Cf}} \cdot \nabla \phi_C = \phi_C            eqn. 2</span></div>
<div class="line"><span class="lineno">   71</span>    <span class="comment">//</span></div>
<div class="line"><span class="lineno">   72</span>    <span class="comment">// where $C$ refers to the cell centroid, $ebf$ refers to an extrapolated boundary face, $of$</span></div>
<div class="line"><span class="lineno">   73</span>    <span class="comment">// refers to &quot;other faces&quot;, e.g. non-ebf faces, and $f$ is a general face. $d_{Cf}$ is the</span></div>
<div class="line"><span class="lineno">   74</span>    <span class="comment">// vector drawn from the element centroid to the face centroid, and $\vec{S_f}$ is the surface</span></div>
<div class="line"><span class="lineno">   75</span>    <span class="comment">// vector, e.g. the face area times the outward facing normal</span></div>
<div class="line"><span class="lineno">   76</span> </div>
<div class="line"><span class="lineno">   77</span>    <span class="comment">// ebf eqns: element gradient coefficients, e.g. eqn. 2, LHS term 2 coefficient</span></div>
<div class="line"><span class="lineno">   78</span>    std::vector&lt;VectorValue&lt;Real&gt;&gt; ebf_grad_coeffs;</div>
<div class="line"><span class="lineno">   79</span>    <span class="comment">// ebf eqns: rhs b values. These will actually correspond to the elem_value so we can use a</span></div>
<div class="line"><span class="lineno">   80</span>    <span class="comment">// pointer and avoid copying. This is the RHS of eqn. 2</span></div>
<div class="line"><span class="lineno">   81</span>    std::vector&lt;const T *&gt; ebf_b;</div>
<div class="line"><span class="lineno">   82</span> </div>
<div class="line"><span class="lineno">   83</span>    <span class="comment">// elem grad eqns: ebf coefficients, e.g. eqn. 1, LHS term 2 coefficients</span></div>
<div class="line"><span class="lineno">   84</span>    std::vector&lt;VectorValue&lt;Real&gt;&gt; grad_ebf_coeffs;</div>
<div class="line"><span class="lineno">   85</span>    <span class="comment">// elem grad eqns: rhs b value, e.g. eqn. 1 RHS</span></div>
<div class="line"><span class="lineno">   86</span>    VectorValue&lt;T&gt; grad_b = 0;</div>
<div class="line"><span class="lineno">   87</span> </div>
<div class="line"><span class="lineno">   88</span>    <span class="keyword">auto</span> action_functor = [&amp;volume_set,</div>
<div class="line"><span class="lineno">   89</span>                           &amp;volume,</div>
<div class="line"><span class="lineno">   90</span>                           &amp;elem_value,</div>
<div class="line"><span class="lineno">   91</span>                           &amp;elem_arg,</div>
<div class="line"><span class="lineno">   92</span>                           &amp;num_ebfs,</div>
<div class="line"><span class="lineno">   93</span>                           &amp;ebf_grad_coeffs,</div>
<div class="line"><span class="lineno">   94</span>                           &amp;ebf_b,</div>
<div class="line"><span class="lineno">   95</span>                           &amp;grad_ebf_coeffs,</div>
<div class="line"><span class="lineno">   96</span>                           &amp;grad_b,</div>
<div class="line"><span class="lineno">   97</span>                           &amp;state_arg,</div>
<div class="line"><span class="lineno">   98</span>                           &amp;functor,</div>
<div class="line"><span class="lineno">   99</span>                           two_term_boundary_expansion,</div>
<div class="line"><span class="lineno">  100</span>                           coord_type,</div>
<div class="line"><span class="lineno">  101</span>                           rz_radial_coord](<span class="keyword">const</span> Elem &amp; libmesh_dbg_var(functor_elem),</div>
<div class="line"><span class="lineno">  102</span>                                            <span class="keyword">const</span> Elem *,</div>
<div class="line"><span class="lineno">  103</span>                                            <span class="keyword">const</span> <a class="code hl_class" href="classFaceInfo.html">FaceInfo</a> * <span class="keyword">const</span> fi,</div>
<div class="line"><span class="lineno">  104</span>                                            <span class="keyword">const</span> Point &amp; surface_vector,</div>
<div class="line"><span class="lineno">  105</span>                                            Real coord,</div>
<div class="line"><span class="lineno">  106</span>                                            <span class="keyword">const</span> <span class="keywordtype">bool</span> elem_has_info)</div>
<div class="line"><span class="lineno">  107</span>    {</div>
<div class="line"><span class="lineno">  108</span>      mooseAssert(fi, <span class="stringliteral">&quot;We need a FaceInfo for this action_functor&quot;</span>);</div>
<div class="line"><span class="lineno">  109</span>      mooseAssert(elem_arg.elem == &amp;functor_elem,</div>
<div class="line"><span class="lineno">  110</span>                  <span class="stringliteral">&quot;Just a sanity check that the element being passed in is the one we passed out.&quot;</span>);</div>
<div class="line"><span class="lineno">  111</span> </div>
<div class="line"><span class="lineno">  112</span>      <span class="keywordflow">if</span> (functor.isExtrapolatedBoundaryFace(*fi, elem_arg.elem, state_arg))</div>
<div class="line"><span class="lineno">  113</span>      {</div>
<div class="line"><span class="lineno">  114</span>        <span class="keywordflow">if</span> (two_term_boundary_expansion)</div>
<div class="line"><span class="lineno">  115</span>        {</div>
<div class="line"><span class="lineno">  116</span>          num_ebfs += 1;</div>
<div class="line"><span class="lineno">  117</span> </div>
<div class="line"><span class="lineno">  118</span>          <span class="comment">// eqn. 2</span></div>
<div class="line"><span class="lineno">  119</span>          ebf_grad_coeffs.push_back(-1. * (elem_has_info</div>
<div class="line"><span class="lineno">  120</span>                                               ? (fi-&gt;faceCentroid() - fi-&gt;elemCentroid())</div>
<div class="line"><span class="lineno">  121</span>                                               : (fi-&gt;faceCentroid() - fi-&gt;neighborCentroid())));</div>
<div class="line"><span class="lineno">  122</span>          ebf_b.push_back(&amp;elem_value);</div>
<div class="line"><span class="lineno">  123</span> </div>
<div class="line"><span class="lineno">  124</span>          <span class="comment">// eqn. 1</span></div>
<div class="line"><span class="lineno">  125</span>          grad_ebf_coeffs.push_back(-surface_vector);</div>
<div class="line"><span class="lineno">  126</span>        }</div>
<div class="line"><span class="lineno">  127</span>        <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  128</span>          <span class="comment">// We are doing a one-term expansion for the extrapolated boundary faces, in which case we</span></div>
<div class="line"><span class="lineno">  129</span>          <span class="comment">// have no eqn. 2 and we have no second term in the LHS of eqn. 1. Instead we apply the</span></div>
<div class="line"><span class="lineno">  130</span>          <span class="comment">// element centroid value as the face value (one-term expansion) in the RHS of eqn. 1</span></div>
<div class="line"><span class="lineno">  131</span>          grad_b += surface_vector * elem_value;</div>
<div class="line"><span class="lineno">  132</span>      }</div>
<div class="line"><span class="lineno">  133</span>      <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  134</span>        grad_b += surface_vector * functor(<a class="code hl_struct" href="structMoose_1_1FaceArg.html">Moose::FaceArg</a>{fi,</div>
<div class="line"><span class="lineno">  135</span>                                                          <a class="code hl_enumvalue" href="namespaceMoose_1_1FV.html#a543ddcb0eef69b1aa6f7138b271c245cac6f5d0a15fe7871f1df4eacfbf77bdf6">Moose::FV::LimiterType::CentralDifference</a>,</div>
<div class="line"><span class="lineno">  136</span>                                                          <span class="keyword">true</span>,</div>
<div class="line"><span class="lineno">  137</span>                                                          elem_arg.correct_skewness,</div>
<div class="line"><span class="lineno">  138</span>                                                          elem_arg.elem},</div>
<div class="line"><span class="lineno">  139</span>                                           state_arg);</div>
<div class="line"><span class="lineno">  140</span> </div>
<div class="line"><span class="lineno">  141</span>      <span class="keywordflow">if</span> (!volume_set)</div>
<div class="line"><span class="lineno">  142</span>      {</div>
<div class="line"><span class="lineno">  143</span>        <span class="comment">// We use the FaceInfo volumes because those values have been pre-computed and cached.</span></div>
<div class="line"><span class="lineno">  144</span>        <span class="comment">// An explicit call to elem-&gt;volume() here would incur unnecessary expense</span></div>
<div class="line"><span class="lineno">  145</span>        <span class="keywordflow">if</span> (elem_has_info)</div>
<div class="line"><span class="lineno">  146</span>        {</div>
<div class="line"><span class="lineno">  147</span>          <a class="code hl_function" href="namespaceMooseMeshUtils.html#ac86ee3e4df0290ff749248d993eb354e">MooseMeshUtils::coordTransformFactor</a>(</div>
<div class="line"><span class="lineno">  148</span>              fi-&gt;elemCentroid(), coord, coord_type, rz_radial_coord);</div>
<div class="line"><span class="lineno">  149</span>          volume = fi-&gt;elemVolume() * coord;</div>
<div class="line"><span class="lineno">  150</span>        }</div>
<div class="line"><span class="lineno">  151</span>        <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  152</span>        {</div>
<div class="line"><span class="lineno">  153</span>          <a class="code hl_function" href="namespaceMooseMeshUtils.html#ac86ee3e4df0290ff749248d993eb354e">MooseMeshUtils::coordTransformFactor</a>(</div>
<div class="line"><span class="lineno">  154</span>              fi-&gt;neighborCentroid(), coord, coord_type, rz_radial_coord);</div>
<div class="line"><span class="lineno">  155</span>          volume = fi-&gt;neighborVolume() * coord;</div>
<div class="line"><span class="lineno">  156</span>        }</div>
<div class="line"><span class="lineno">  157</span> </div>
<div class="line"><span class="lineno">  158</span>        volume_set = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  159</span>      }</div>
<div class="line"><span class="lineno">  160</span>    };</div>
<div class="line"><span class="lineno">  161</span> </div>
<div class="line"><span class="lineno">  162</span>    <a class="code hl_function" href="namespaceMoose_1_1FV.html#a4ac7ab327b328366cc7ebbbd739a874f">Moose::FV::loopOverElemFaceInfo</a>(</div>
<div class="line"><span class="lineno">  163</span>        *elem_arg.elem, mesh, action_functor, coord_type, rz_radial_coord);</div>
<div class="line"><span class="lineno">  164</span> </div>
<div class="line"><span class="lineno">  165</span>    mooseAssert(volume_set &amp;&amp; volume &gt; 0, <span class="stringliteral">&quot;We should have set the volume&quot;</span>);</div>
<div class="line"><span class="lineno">  166</span>    grad_b /= volume;</div>
<div class="line"><span class="lineno">  167</span> </div>
<div class="line"><span class="lineno">  168</span>    <span class="keywordflow">if</span> (coord_type == <a class="code hl_enumvalue" href="namespaceMoose.html#aa11333273856693d4c2762d764789509a64fcffb37e2cc00c84e2cba948f12cfd">Moose::CoordinateSystemType::COORD_RZ</a>)</div>
<div class="line"><span class="lineno">  169</span>    {</div>
<div class="line"><span class="lineno">  170</span>      mooseAssert(rz_radial_coord != libMesh::invalid_uint, <span class="stringliteral">&quot;rz_radial_coord must be set&quot;</span>);</div>
<div class="line"><span class="lineno">  171</span>      grad_b(rz_radial_coord) -= elem_value / elem_arg.elem-&gt;vertex_average()(rz_radial_coord);</div>
<div class="line"><span class="lineno">  172</span>    }</div>
<div class="line"><span class="lineno">  173</span> </div>
<div class="line"><span class="lineno">  174</span>    mooseAssert(</div>
<div class="line"><span class="lineno">  175</span>        coord_type != <a class="code hl_enumvalue" href="namespaceMoose.html#aa11333273856693d4c2762d764789509adeb047c3d71bcc5b8d9bb45490dfc3cb">Moose::CoordinateSystemType::COORD_RSPHERICAL</a>,</div>
<div class="line"><span class="lineno">  176</span>        <span class="stringliteral">&quot;We have not yet implemented the correct translation from gradient to divergence for &quot;</span></div>
<div class="line"><span class="lineno">  177</span>        <span class="stringliteral">&quot;spherical coordinates yet.&quot;</span>);</div>
<div class="line"><span class="lineno">  178</span> </div>
<div class="line"><span class="lineno">  179</span>    <span class="comment">// test for simple case</span></div>
<div class="line"><span class="lineno">  180</span>    <span class="keywordflow">if</span> (num_ebfs == 0)</div>
<div class="line"><span class="lineno">  181</span>      grad = grad_b;</div>
<div class="line"><span class="lineno">  182</span>    <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  183</span>    {</div>
<div class="line"><span class="lineno">  184</span>      <span class="comment">// We have to solve a system</span></div>
<div class="line"><span class="lineno">  185</span>      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sys_dim = <a class="code hl_variable" href="namespaceMoose.html#a87e3992d5ec454469678e28370766430">Moose::dim</a> + num_ebfs;</div>
<div class="line"><span class="lineno">  186</span>      DenseVector&lt;T&gt; x(sys_dim), b(sys_dim);</div>
<div class="line"><span class="lineno">  187</span>      DenseMatrix&lt;T&gt; A(sys_dim, sys_dim);</div>
<div class="line"><span class="lineno">  188</span> </div>
<div class="line"><span class="lineno">  189</span>      <span class="comment">// Let&#39;s make i refer to Moose::dim indices, and j refer to num_ebfs indices</span></div>
<div class="line"><span class="lineno">  190</span> </div>
<div class="line"><span class="lineno">  191</span>      <span class="comment">// eqn. 1</span></div>
<div class="line"><span class="lineno">  192</span>      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : make_range(<a class="code hl_variable" href="namespaceMoose.html#a87e3992d5ec454469678e28370766430">Moose::dim</a>))</div>
<div class="line"><span class="lineno">  193</span>      {</div>
<div class="line"><span class="lineno">  194</span>        <span class="comment">// LHS term 1 coeffs</span></div>
<div class="line"><span class="lineno">  195</span>        A(i, i) = 1;</div>
<div class="line"><span class="lineno">  196</span> </div>
<div class="line"><span class="lineno">  197</span>        <span class="comment">// LHS term 2 coeffs</span></div>
<div class="line"><span class="lineno">  198</span>        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> j : make_range(num_ebfs))</div>
<div class="line"><span class="lineno">  199</span>          A(i, <a class="code hl_variable" href="namespaceMoose.html#a87e3992d5ec454469678e28370766430">Moose::dim</a> + j) = grad_ebf_coeffs[j](i) / volume;</div>
<div class="line"><span class="lineno">  200</span> </div>
<div class="line"><span class="lineno">  201</span>        <span class="comment">// RHS</span></div>
<div class="line"><span class="lineno">  202</span>        b(i) = grad_b(i);</div>
<div class="line"><span class="lineno">  203</span>      }</div>
<div class="line"><span class="lineno">  204</span> </div>
<div class="line"><span class="lineno">  205</span>      <span class="comment">// eqn. 2</span></div>
<div class="line"><span class="lineno">  206</span>      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> j : make_range(num_ebfs))</div>
<div class="line"><span class="lineno">  207</span>      {</div>
<div class="line"><span class="lineno">  208</span>        <span class="comment">// LHS term 1 coeffs</span></div>
<div class="line"><span class="lineno">  209</span>        A(<a class="code hl_variable" href="namespaceMoose.html#a87e3992d5ec454469678e28370766430">Moose::dim</a> + j, <a class="code hl_variable" href="namespaceMoose.html#a87e3992d5ec454469678e28370766430">Moose::dim</a> + j) = 1;</div>
<div class="line"><span class="lineno">  210</span> </div>
<div class="line"><span class="lineno">  211</span>        <span class="comment">// LHS term 2 coeffs</span></div>
<div class="line"><span class="lineno">  212</span>        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : make_range(<span class="keywordtype">unsigned</span>(<a class="code hl_variable" href="namespaceMoose.html#a87e3992d5ec454469678e28370766430">Moose::dim</a>)))</div>
<div class="line"><span class="lineno">  213</span>          A(<a class="code hl_variable" href="namespaceMoose.html#a87e3992d5ec454469678e28370766430">Moose::dim</a> + j, i) = ebf_grad_coeffs[j](i);</div>
<div class="line"><span class="lineno">  214</span> </div>
<div class="line"><span class="lineno">  215</span>        <span class="comment">// RHS</span></div>
<div class="line"><span class="lineno">  216</span>        b(<a class="code hl_variable" href="namespaceMoose.html#a87e3992d5ec454469678e28370766430">Moose::dim</a> + j) = *ebf_b[j];</div>
<div class="line"><span class="lineno">  217</span>      }</div>
<div class="line"><span class="lineno">  218</span> </div>
<div class="line"><span class="lineno">  219</span>      A.lu_solve(b, x);</div>
<div class="line"><span class="lineno">  220</span>      <span class="comment">// libMesh is generous about what it considers nonsingular. Let&#39;s check a little more strictly</span></div>
<div class="line"><span class="lineno">  221</span>      <span class="keywordflow">if</span> (<a class="code hl_function" href="namespaceMooseUtils.html#ad9865895ce5bb2c18722efa26d5c7693">MooseUtils::absoluteFuzzyEqual</a>(<a class="code hl_function" href="namespaceMetaPhysicL.html#a1c0a19c861d5f7813f7fb6825d8fe146">MetaPhysicL::raw_value</a>(A(sys_dim - 1, sys_dim - 1)), 0))</div>
<div class="line"><span class="lineno">  222</span>        <span class="keywordflow">throw</span> libMesh::LogicError(<span class="stringliteral">&quot;Matrix A is singular!&quot;</span>);</div>
<div class="line"><span class="lineno">  223</span>      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : make_range(<a class="code hl_variable" href="namespaceMoose.html#a87e3992d5ec454469678e28370766430">Moose::dim</a>))</div>
<div class="line"><span class="lineno">  224</span>        grad(i) = x(i);</div>
<div class="line"><span class="lineno">  225</span>    }</div>
<div class="line"><span class="lineno">  226</span> </div>
<div class="line"><span class="lineno">  227</span>    <span class="keywordflow">return</span> grad;</div>
<div class="line"><span class="lineno">  228</span>  }</div>
<div class="line"><span class="lineno">  229</span>  <span class="keywordflow">catch</span> (libMesh::LogicError &amp; e)</div>
<div class="line"><span class="lineno">  230</span>  {</div>
<div class="line"><span class="lineno">  231</span>    <span class="comment">// Retry without two-term</span></div>
<div class="line"><span class="lineno">  232</span>    <span class="keywordflow">if</span> (!two_term_boundary_expansion)</div>
<div class="line"><span class="lineno">  233</span>      <a class="code hl_function" href="MooseError_8h.html#aa959168eed29caa7aaa85ffc1319a9ad">mooseError</a>(</div>
<div class="line"><span class="lineno">  234</span>          <span class="stringliteral">&quot;I believe we should only get singular systems when two-term boundary expansion is &quot;</span></div>
<div class="line"><span class="lineno">  235</span>          <span class="stringliteral">&quot;being used. The error thrown during the computation of the gradient: &quot;</span>,</div>
<div class="line"><span class="lineno">  236</span>          e.what());</div>
<div class="line"><span class="lineno">  237</span>    <span class="keyword">const</span> <span class="keyword">auto</span> grad = <a class="code hl_function" href="namespaceMoose_1_1FV.html#a9390f7c56eb001f809b1a40e6568008e">greenGaussGradient</a>(elem_arg, state_arg, functor, <span class="keyword">false</span>, mesh);</div>
<div class="line"><span class="lineno">  238</span> </div>
<div class="line"><span class="lineno">  239</span>    <span class="keywordflow">return</span> grad;</div>
<div class="line"><span class="lineno">  240</span>  }</div>
<div class="line"><span class="lineno">  241</span>}</div>
<div class="ttc" id="aMooseError_8h_html_aa959168eed29caa7aaa85ffc1319a9ad"><div class="ttname"><a href="MooseError_8h.html#aa959168eed29caa7aaa85ffc1319a9ad">mooseError</a></div><div class="ttdeci">void mooseError(Args &amp;&amp;... args)</div><div class="ttdoc">Emit an error message with the given stringified, concatenated args and terminate the application.</div><div class="ttdef"><b>Definition:</b> <a href="MooseError_8h_source.html#l00284">MooseError.h:284</a></div></div>
<div class="ttc" id="aclassFaceInfo_html"><div class="ttname"><a href="classFaceInfo.html">FaceInfo</a></div><div class="ttdoc">This data structure is used to store geometric and variable related metadata about each cell face in ...</div><div class="ttdef"><b>Definition:</b> <a href="FaceInfo_8h_source.html#l00035">FaceInfo.h:36</a></div></div>
<div class="ttc" id="aclassMooseMesh_html_a0fdf1cce97ad1421fa00c8621865ca07"><div class="ttname"><a href="classMooseMesh.html#a0fdf1cce97ad1421fa00c8621865ca07">MooseMesh::getAxisymmetricRadialCoord</a></div><div class="ttdeci">unsigned int getAxisymmetricRadialCoord() const</div><div class="ttdoc">Returns the desired radial direction for RZ coordinate transformation.</div><div class="ttdef"><b>Definition:</b> <a href="MooseMesh_8C_source.html#l03992">MooseMesh.C:3992</a></div></div>
<div class="ttc" id="aclassMooseMesh_html_a9728c2d118346e46054d3352e92af6b1"><div class="ttname"><a href="classMooseMesh.html#a9728c2d118346e46054d3352e92af6b1">MooseMesh::getCoordSystem</a></div><div class="ttdeci">Moose::CoordinateSystemType getCoordSystem(SubdomainID sid) const</div><div class="ttdoc">Get the coordinate system type, e.g.</div><div class="ttdef"><b>Definition:</b> <a href="MooseMesh_8C_source.html#l03873">MooseMesh.C:3873</a></div></div>
<div class="ttc" id="anamespaceMetaPhysicL_html_a1c0a19c861d5f7813f7fb6825d8fe146"><div class="ttname"><a href="namespaceMetaPhysicL.html#a1c0a19c861d5f7813f7fb6825d8fe146">MetaPhysicL::raw_value</a></div><div class="ttdeci">auto raw_value(const Eigen::Map&lt; T &gt; &amp;in)</div><div class="ttdef"><b>Definition:</b> <a href="ADReal_8h_source.html#l00073">ADReal.h:73</a></div></div>
<div class="ttc" id="anamespaceMooseMeshUtils_html_ac86ee3e4df0290ff749248d993eb354e"><div class="ttname"><a href="namespaceMooseMeshUtils.html#ac86ee3e4df0290ff749248d993eb354e">MooseMeshUtils::coordTransformFactor</a></div><div class="ttdeci">void coordTransformFactor(const P &amp;point, C &amp;factor, const Moose::CoordinateSystemType coord_type, const unsigned int rz_radial_coord=libMesh::invalid_uint)</div><div class="ttdoc">compute a coordinate transformation factor</div><div class="ttdef"><b>Definition:</b> <a href="MooseMeshUtils_8h_source.html#l00130">MooseMeshUtils.h:130</a></div></div>
<div class="ttc" id="anamespaceMooseUtils_html_ad9865895ce5bb2c18722efa26d5c7693"><div class="ttname"><a href="namespaceMooseUtils.html#ad9865895ce5bb2c18722efa26d5c7693">MooseUtils::absoluteFuzzyEqual</a></div><div class="ttdeci">bool absoluteFuzzyEqual(const T &amp;var1, const T2 &amp;var2, const T3 &amp;tol=libMesh::TOLERANCE *libMesh::TOLERANCE)</div><div class="ttdoc">Function to check whether two variables are equal within an absolute tolerance.</div><div class="ttdef"><b>Definition:</b> <a href="MooseUtils_8h_source.html#l00337">MooseUtils.h:337</a></div></div>
<div class="ttc" id="anamespaceMoose_1_1FV_html_a4ac7ab327b328366cc7ebbbd739a874f"><div class="ttname"><a href="namespaceMoose_1_1FV.html#a4ac7ab327b328366cc7ebbbd739a874f">Moose::FV::loopOverElemFaceInfo</a></div><div class="ttdeci">void loopOverElemFaceInfo(const Elem &amp;elem, const MooseMesh &amp;mesh, ActionFunctor &amp;act, const Moose::CoordinateSystemType coord_type, const unsigned int rz_radial_coord=libMesh::invalid_uint)</div><div class="ttdef"><b>Definition:</b> <a href="FVUtils_8h_source.html#l00039">FVUtils.h:39</a></div></div>
<div class="ttc" id="anamespaceMoose_1_1FV_html_a543ddcb0eef69b1aa6f7138b271c245cac6f5d0a15fe7871f1df4eacfbf77bdf6"><div class="ttname"><a href="namespaceMoose_1_1FV.html#a543ddcb0eef69b1aa6f7138b271c245cac6f5d0a15fe7871f1df4eacfbf77bdf6">Moose::FV::LimiterType::CentralDifference</a></div><div class="ttdeci">@ CentralDifference</div></div>
<div class="ttc" id="anamespaceMoose_1_1FV_html_a9390f7c56eb001f809b1a40e6568008e"><div class="ttname"><a href="namespaceMoose_1_1FV.html#a9390f7c56eb001f809b1a40e6568008e">Moose::FV::greenGaussGradient</a></div><div class="ttdeci">VectorValue&lt; T &gt; greenGaussGradient(const ElemArg &amp;elem_arg, const StateArg &amp;state_arg, const FunctorBase&lt; T &gt; &amp;functor, const bool two_term_boundary_expansion, const MooseMesh &amp;mesh)</div><div class="ttdoc">Compute a cell gradient using the method of Green-Gauss.</div><div class="ttdef"><b>Definition:</b> <a href="GreenGaussGradient_8h_source.html#l00040">GreenGaussGradient.h:40</a></div></div>
<div class="ttc" id="anamespaceMoose_html_a87e3992d5ec454469678e28370766430"><div class="ttname"><a href="namespaceMoose.html#a87e3992d5ec454469678e28370766430">Moose::dim</a></div><div class="ttdeci">static constexpr std::size_t dim</div><div class="ttdoc">This is the dimension of all vector and tensor datastructures used in MOOSE.</div><div class="ttdef"><b>Definition:</b> <a href="Moose_8h_source.html#l00147">Moose.h:147</a></div></div>
<div class="ttc" id="anamespaceMoose_html_aa11333273856693d4c2762d764789509a64fcffb37e2cc00c84e2cba948f12cfd"><div class="ttname"><a href="namespaceMoose.html#aa11333273856693d4c2762d764789509a64fcffb37e2cc00c84e2cba948f12cfd">Moose::COORD_RZ</a></div><div class="ttdeci">@ COORD_RZ</div><div class="ttdef"><b>Definition:</b> <a href="MooseTypes_8h_source.html#l00723">MooseTypes.h:723</a></div></div>
<div class="ttc" id="anamespaceMoose_html_aa11333273856693d4c2762d764789509adeb047c3d71bcc5b8d9bb45490dfc3cb"><div class="ttname"><a href="namespaceMoose.html#aa11333273856693d4c2762d764789509adeb047c3d71bcc5b8d9bb45490dfc3cb">Moose::COORD_RSPHERICAL</a></div><div class="ttdeci">@ COORD_RSPHERICAL</div><div class="ttdef"><b>Definition:</b> <a href="MooseTypes_8h_source.html#l00725">MooseTypes.h:724</a></div></div>
<div class="ttc" id="astructMoose_1_1ElemArg_html_a7d2d33f2d18ad7b62273afa16d14d393"><div class="ttname"><a href="structMoose_1_1ElemArg.html#a7d2d33f2d18ad7b62273afa16d14d393">Moose::ElemArg::elem</a></div><div class="ttdeci">const libMesh::Elem * elem</div><div class="ttdef"><b>Definition:</b> <a href="MooseFunctorArguments_8h_source.html#l00028">MooseFunctorArguments.h:28</a></div></div>
<div class="ttc" id="astructMoose_1_1FaceArg_html"><div class="ttname"><a href="structMoose_1_1FaceArg.html">Moose::FaceArg</a></div><div class="ttdoc">A structure defining a &quot;face&quot; evaluation calling argument for Moose functors.</div><div class="ttdef"><b>Definition:</b> <a href="MooseFunctorArguments_8h_source.html#l00081">MooseFunctorArguments.h:82</a></div></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="PiecewiseByBlockLambdaFunctor_8h_source.html#l00303">PiecewiseByBlockLambdaFunctor&lt; T &gt;::evaluateGradient()</a>, and <a class="el" href="GreenGaussGradient_8h_source.html#l00040">greenGaussGradient()</a>.</p>

</div>
</div>
<a id="a08f9683e7b3fc9a3e3bfbf357ba52212" name="a08f9683e7b3fc9a3e3bfbf357ba52212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08f9683e7b3fc9a3e3bfbf357ba52212">&#9670;&#160;</a></span>greenGaussGradient() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMoose_1_1FunctorBase.html">Moose::FunctorBase</a>&lt; std::array&lt; T, N &gt; &gt;::GradientType Moose::FV::greenGaussGradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMoose_1_1ElemArg.html">ElemArg</a> &amp;&#160;</td>
          <td class="paramname"><em>elem_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMoose_1_1StateArg.html">StateArg</a> &amp;&#160;</td>
          <td class="paramname"><em>state_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMoose_1_1FunctorBase.html">Moose::FunctorBase</a>&lt; std::array&lt; T, N &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>two_term_boundary_expansion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMooseMesh.html">MooseMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="GreenGaussGradient_8h_source.html#l00410">410</a> of file <a class="el" href="GreenGaussGradient_8h_source.html">GreenGaussGradient.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  415</span>{</div>
<div class="line"><span class="lineno">  416</span>  <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code hl_class" href="classMoose_1_1FunctorBase.html">Moose::FunctorBase&lt;std::array&lt;T, N&gt;</a>&gt;::GradientType GradientType;</div>
<div class="line"><span class="lineno">  417</span>  GradientType ret;</div>
<div class="line"><span class="lineno">  418</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : make_range(N))</div>
<div class="line"><span class="lineno">  419</span>  {</div>
<div class="line"><span class="lineno">  420</span>    <span class="comment">// Note that this can be very inefficient. Within the scalar greenGaussGradient routine we&#39;re</span></div>
<div class="line"><span class="lineno">  421</span>    <span class="comment">// going to do value type evaluations of the array functor from scalar_functor and we will be</span></div>
<div class="line"><span class="lineno">  422</span>    <span class="comment">// discarding all the value type evaluations other than the one corresponding to i</span></div>
<div class="line"><span class="lineno">  423</span>    <a class="code hl_class" href="classMoose_1_1ArrayComponentFunctor.html">ArrayComponentFunctor&lt;T, FunctorBase&lt;std::array&lt;T, N&gt;</a>&gt;&gt; scalar_functor(functor, i);</div>
<div class="line"><span class="lineno">  424</span>    ret[i] =</div>
<div class="line"><span class="lineno">  425</span>        <a class="code hl_function" href="namespaceMoose_1_1FV.html#a9390f7c56eb001f809b1a40e6568008e">greenGaussGradient</a>(elem_arg, state_arg, scalar_functor, two_term_boundary_expansion, mesh);</div>
<div class="line"><span class="lineno">  426</span>  }</div>
<div class="line"><span class="lineno">  427</span> </div>
<div class="line"><span class="lineno">  428</span>  <span class="keywordflow">return</span> ret;</div>
<div class="line"><span class="lineno">  429</span>}</div>
<div class="ttc" id="aclassMoose_1_1ArrayComponentFunctor_html"><div class="ttname"><a href="classMoose_1_1ArrayComponentFunctor.html">Moose::ArrayComponentFunctor</a></div><div class="ttdoc">This is essentially a forwarding functor that forwards the spatial and temporal evaluation arguments ...</div><div class="ttdef"><b>Definition:</b> <a href="ArrayComponentFunctor_8h_source.html#l00021">ArrayComponentFunctor.h:22</a></div></div>
<div class="ttc" id="aclassMoose_1_1FunctorBase_html"><div class="ttname"><a href="classMoose_1_1FunctorBase.html">Moose::FunctorBase</a></div><div class="ttdoc">Base class template for functor objects.</div><div class="ttdef"><b>Definition:</b> <a href="MooseFunctor_8h_source.html#l00051">MooseFunctor.h:52</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a247604c97cbe04478051dcc19da10b92" name="a247604c97cbe04478051dcc19da10b92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a247604c97cbe04478051dcc19da10b92">&#9670;&#160;</a></span>greenGaussGradient() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMoose_1_1FunctorBase.html">Moose::FunctorBase</a>&lt; std::vector&lt; T &gt; &gt;::GradientType Moose::FV::greenGaussGradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMoose_1_1ElemArg.html">ElemArg</a> &amp;&#160;</td>
          <td class="paramname"><em>elem_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMoose_1_1StateArg.html">StateArg</a> &amp;&#160;</td>
          <td class="paramname"><em>state_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMoose_1_1FunctorBase.html">Moose::FunctorBase</a>&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>two_term_boundary_expansion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMooseMesh.html">MooseMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="GreenGaussGradient_8h_source.html#l00360">360</a> of file <a class="el" href="GreenGaussGradient_8h_source.html">GreenGaussGradient.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  365</span>{</div>
<div class="line"><span class="lineno">  366</span>  <span class="comment">// Determine the size of the container</span></div>
<div class="line"><span class="lineno">  367</span>  <span class="keyword">const</span> <span class="keyword">auto</span> vals = functor(elem_arg, state_arg);</div>
<div class="line"><span class="lineno">  368</span>  <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code hl_class" href="classMoose_1_1FunctorBase.html">Moose::FunctorBase&lt;std::vector&lt;T&gt;</a>&gt;::GradientType GradientType;</div>
<div class="line"><span class="lineno">  369</span>  GradientType ret(vals.size());</div>
<div class="line"><span class="lineno">  370</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : index_range(ret))</div>
<div class="line"><span class="lineno">  371</span>  {</div>
<div class="line"><span class="lineno">  372</span>    <span class="comment">// Note that this can be very inefficient. Within the scalar greenGaussGradient routine we&#39;re</span></div>
<div class="line"><span class="lineno">  373</span>    <span class="comment">// going to do value type evaluations of the array functor from scalar_functor and we will be</span></div>
<div class="line"><span class="lineno">  374</span>    <span class="comment">// discarding all the value type evaluations other than the one corresponding to i</span></div>
<div class="line"><span class="lineno">  375</span>    <a class="code hl_class" href="classMoose_1_1ArrayComponentFunctor.html">ArrayComponentFunctor&lt;T, FunctorBase&lt;std::vector&lt;T&gt;</a>&gt;&gt; scalar_functor(functor, i);</div>
<div class="line"><span class="lineno">  376</span>    ret[i] =</div>
<div class="line"><span class="lineno">  377</span>        <a class="code hl_function" href="namespaceMoose_1_1FV.html#a9390f7c56eb001f809b1a40e6568008e">greenGaussGradient</a>(elem_arg, state_arg, scalar_functor, two_term_boundary_expansion, mesh);</div>
<div class="line"><span class="lineno">  378</span>  }</div>
<div class="line"><span class="lineno">  379</span> </div>
<div class="line"><span class="lineno">  380</span>  <span class="keywordflow">return</span> ret;</div>
<div class="line"><span class="lineno">  381</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab30763508fa761f63fac721217cd1d69" name="ab30763508fa761f63fac721217cd1d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab30763508fa761f63fac721217cd1d69">&#9670;&#160;</a></span>greenGaussGradient() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TensorValue&lt; T &gt; Moose::FV::greenGaussGradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMoose_1_1ElemArg.html">ElemArg</a> &amp;&#160;</td>
          <td class="paramname"><em>elem_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMoose_1_1StateArg.html">StateArg</a> &amp;&#160;</td>
          <td class="paramname"><em>state_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMoose_1_1FunctorBase.html">Moose::FunctorBase</a>&lt; VectorValue&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>two_term_boundary_expansion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMooseMesh.html">MooseMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="GreenGaussGradient_8h_source.html#l00318">318</a> of file <a class="el" href="GreenGaussGradient_8h_source.html">GreenGaussGradient.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  323</span>{</div>
<div class="line"><span class="lineno">  324</span>  TensorValue&lt;T&gt; ret;</div>
<div class="line"><span class="lineno">  325</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : make_range(<a class="code hl_variable" href="namespaceMoose.html#a87e3992d5ec454469678e28370766430">Moose::dim</a>))</div>
<div class="line"><span class="lineno">  326</span>  {</div>
<div class="line"><span class="lineno">  327</span>    <a class="code hl_class" href="classMoose_1_1VectorComponentFunctor.html">VectorComponentFunctor&lt;T&gt;</a> scalar_functor(functor, i);</div>
<div class="line"><span class="lineno">  328</span>    <span class="keyword">const</span> <span class="keyword">auto</span> row_gradient =</div>
<div class="line"><span class="lineno">  329</span>        <a class="code hl_function" href="namespaceMoose_1_1FV.html#a9390f7c56eb001f809b1a40e6568008e">greenGaussGradient</a>(elem_arg, state_arg, scalar_functor, two_term_boundary_expansion, mesh);</div>
<div class="line"><span class="lineno">  330</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> j : make_range(<span class="keywordtype">unsigned</span>(<a class="code hl_variable" href="namespaceMoose.html#a87e3992d5ec454469678e28370766430">Moose::dim</a>)))</div>
<div class="line"><span class="lineno">  331</span>      ret(i, j) = row_gradient(j);</div>
<div class="line"><span class="lineno">  332</span>  }</div>
<div class="line"><span class="lineno">  333</span> </div>
<div class="line"><span class="lineno">  334</span>  <span class="keywordflow">return</span> ret;</div>
<div class="line"><span class="lineno">  335</span>}</div>
<div class="ttc" id="aclassMoose_1_1VectorComponentFunctor_html"><div class="ttname"><a href="classMoose_1_1VectorComponentFunctor.html">Moose::VectorComponentFunctor</a></div><div class="ttdoc">This is essentially a forwarding functor that forwards the spatial and temporal evaluation arguments ...</div><div class="ttdef"><b>Definition:</b> <a href="VectorComponentFunctor_8h_source.html#l00021">VectorComponentFunctor.h:22</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="af1bdd6d55239090e1f3d94bce5d7abb8" name="af1bdd6d55239090e1f3d94bce5d7abb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1bdd6d55239090e1f3d94bce5d7abb8">&#9670;&#160;</a></span>greenGaussGradient() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Enable  = typename std::enable_if&lt;ScalarTraits&lt;T&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VectorValue&lt; T &gt; Moose::FV::greenGaussGradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMoose_1_1FaceArg.html">FaceArg</a> &amp;&#160;</td>
          <td class="paramname"><em>face_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMoose_1_1StateArg.html">StateArg</a> &amp;&#160;</td>
          <td class="paramname"><em>state_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMoose_1_1FunctorBase.html">FunctorBase</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>two_term_boundary_expansion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMooseMesh.html">MooseMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute a face gradient from Green-Gauss cell gradients, with orthogonality correction On the boundaries, the boundary element value is used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">face_arg</td><td>A face argument specifying the current faceand whether to perform skew corrections </td></tr>
    <tr><td class="paramname">state_arg</td><td>A state argument that indicates what temporal / solution iteration data to use when evaluating the provided functor </td></tr>
    <tr><td class="paramname">functor</td><td>The functor that will provide information such as cell and face value evaluations necessary to construct the cell gradient </td></tr>
    <tr><td class="paramname">two_term_boundary_expansion</td><td>Whether to perform a two-term expansion to compute extrapolated boundary face values. If this is true, then an implicit system has to be solved. If false, then the cell center value will be used as the extrapolated boundary face value </td></tr>
    <tr><td class="paramname">mesh</td><td>The mesh on which we are computing the gradient </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The computed cell gradient </dd></dl>

<p class="definition">Definition at line <a class="el" href="GreenGaussGradient_8h_source.html#l00260">260</a> of file <a class="el" href="GreenGaussGradient_8h_source.html">GreenGaussGradient.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  265</span>{</div>
<div class="line"><span class="lineno">  266</span>  mooseAssert(face_arg.<a class="code hl_variable" href="structMoose_1_1FaceArg.html#adbe9c167b0afacad24a0ca70959d0a43">fi</a>, <span class="stringliteral">&quot;We should have a face info to compute a face gradient&quot;</span>);</div>
<div class="line"><span class="lineno">  267</span>  <span class="keyword">const</span> <span class="keyword">auto</span> &amp; fi = *(face_arg.<a class="code hl_variable" href="structMoose_1_1FaceArg.html#adbe9c167b0afacad24a0ca70959d0a43">fi</a>);</div>
<div class="line"><span class="lineno">  268</span>  <span class="keyword">const</span> <span class="keyword">auto</span> &amp; elem_arg = face_arg.<a class="code hl_function" href="structMoose_1_1FaceArg.html#a8c1e438f2efba06f4ba4436ff427034b">makeElem</a>();</div>
<div class="line"><span class="lineno">  269</span>  <span class="keyword">const</span> <span class="keyword">auto</span> &amp; neighbor_arg = face_arg.<a class="code hl_function" href="structMoose_1_1FaceArg.html#a6b1b2bf253cb75ddb36a6ceca1f7b1f5">makeNeighbor</a>();</div>
<div class="line"><span class="lineno">  270</span>  <span class="keyword">const</span> <span class="keywordtype">bool</span> defined_on_elem = functor.<a class="code hl_function" href="classMoose_1_1FunctorBase.html#a5e50a49fcfdb8fbd219de440171a26dd">hasBlocks</a>(fi.elemSubdomainID());</div>
<div class="line"><span class="lineno">  271</span>  <span class="keyword">const</span> <span class="keywordtype">bool</span> defined_on_neighbor = fi.neighborPtr() &amp;&amp; functor.<a class="code hl_function" href="classMoose_1_1FunctorBase.html#a5e50a49fcfdb8fbd219de440171a26dd">hasBlocks</a>(fi.neighborSubdomainID());</div>
<div class="line"><span class="lineno">  272</span> </div>
<div class="line"><span class="lineno">  273</span>  <span class="keywordflow">if</span> (defined_on_elem &amp;&amp; defined_on_neighbor)</div>
<div class="line"><span class="lineno">  274</span>  {</div>
<div class="line"><span class="lineno">  275</span>    <span class="keyword">const</span> <span class="keyword">auto</span> &amp; value_elem = functor(elem_arg, state_arg);</div>
<div class="line"><span class="lineno">  276</span>    <span class="keyword">const</span> <span class="keyword">auto</span> &amp; value_neighbor = functor(neighbor_arg, state_arg);</div>
<div class="line"><span class="lineno">  277</span> </div>
<div class="line"><span class="lineno">  278</span>    <span class="comment">// This is the component of the gradient which is parallel to the line connecting</span></div>
<div class="line"><span class="lineno">  279</span>    <span class="comment">// the cell centers. Therefore, we can use our second order, central difference</span></div>
<div class="line"><span class="lineno">  280</span>    <span class="comment">// scheme to approximate it.</span></div>
<div class="line"><span class="lineno">  281</span>    VectorValue&lt;T&gt; face_gradient = (value_neighbor - value_elem) / fi.dCNMag() * fi.eCN();</div>
<div class="line"><span class="lineno">  282</span> </div>
<div class="line"><span class="lineno">  283</span>    <span class="comment">// We only need nonorthogonal correctors in 2+ dimensions</span></div>
<div class="line"><span class="lineno">  284</span>    <span class="keywordflow">if</span> (mesh.<a class="code hl_function" href="classMooseMesh.html#a197914260c452478db68edb610880087">dimension</a>() &gt; 1)</div>
<div class="line"><span class="lineno">  285</span>    {</div>
<div class="line"><span class="lineno">  286</span>      <span class="comment">// We are using an orthogonal approach for the non-orthogonal correction, for more information</span></div>
<div class="line"><span class="lineno">  287</span>      <span class="comment">// see Hrvoje Jasak&#39;s PhD Thesis (Imperial College, 1996)</span></div>
<div class="line"><span class="lineno">  288</span>      VectorValue&lt;T&gt; interpolated_gradient;</div>
<div class="line"><span class="lineno">  289</span> </div>
<div class="line"><span class="lineno">  290</span>      <span class="comment">// Compute the gradients in the two cells on both sides of the face</span></div>
<div class="line"><span class="lineno">  291</span>      <span class="keyword">const</span> <span class="keyword">auto</span> &amp; grad_elem =</div>
<div class="line"><span class="lineno">  292</span>          <a class="code hl_function" href="namespaceMoose_1_1FV.html#a9390f7c56eb001f809b1a40e6568008e">greenGaussGradient</a>(elem_arg, state_arg, functor, two_term_boundary_expansion, mesh);</div>
<div class="line"><span class="lineno">  293</span>      <span class="keyword">const</span> <span class="keyword">auto</span> &amp; grad_neighbor =</div>
<div class="line"><span class="lineno">  294</span>          <a class="code hl_function" href="namespaceMoose_1_1FV.html#a9390f7c56eb001f809b1a40e6568008e">greenGaussGradient</a>(neighbor_arg, state_arg, functor, two_term_boundary_expansion, mesh);</div>
<div class="line"><span class="lineno">  295</span> </div>
<div class="line"><span class="lineno">  296</span>      <a class="code hl_function" href="namespaceMoose_1_1FV.html#a181e9d146f7d17fcd56ff75f166efac6">Moose::FV::interpolate</a>(<a class="code hl_enumvalue" href="namespaceMoose_1_1FV.html#a5941595b238d0963e4fe80718ab7dd50ab1897515d548a960afe49ecf66a29021">Moose::FV::InterpMethod::Average</a>,</div>
<div class="line"><span class="lineno">  297</span>                             interpolated_gradient,</div>
<div class="line"><span class="lineno">  298</span>                             grad_elem,</div>
<div class="line"><span class="lineno">  299</span>                             grad_neighbor,</div>
<div class="line"><span class="lineno">  300</span>                             fi,</div>
<div class="line"><span class="lineno">  301</span>                             <span class="keyword">true</span>);</div>
<div class="line"><span class="lineno">  302</span> </div>
<div class="line"><span class="lineno">  303</span>      face_gradient += interpolated_gradient - (interpolated_gradient * fi.eCN()) * fi.eCN();</div>
<div class="line"><span class="lineno">  304</span>    }</div>
<div class="line"><span class="lineno">  305</span> </div>
<div class="line"><span class="lineno">  306</span>    <span class="keywordflow">return</span> face_gradient;</div>
<div class="line"><span class="lineno">  307</span>  }</div>
<div class="line"><span class="lineno">  308</span>  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (defined_on_elem)</div>
<div class="line"><span class="lineno">  309</span>    <span class="keywordflow">return</span> functor.<a class="code hl_function" href="classMoose_1_1FunctorBase.html#aa28f70bdf3145308d437a8d8f26fa364">gradient</a>(elem_arg, state_arg);</div>
<div class="line"><span class="lineno">  310</span>  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (defined_on_neighbor)</div>
<div class="line"><span class="lineno">  311</span>    <span class="keywordflow">return</span> functor.<a class="code hl_function" href="classMoose_1_1FunctorBase.html#aa28f70bdf3145308d437a8d8f26fa364">gradient</a>(neighbor_arg, state_arg);</div>
<div class="line"><span class="lineno">  312</span>  <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  313</span>    <a class="code hl_function" href="MooseError_8h.html#aa959168eed29caa7aaa85ffc1319a9ad">mooseError</a>(<span class="stringliteral">&quot;The functor must be defined on one of the sides&quot;</span>);</div>
<div class="line"><span class="lineno">  314</span>}</div>
<div class="ttc" id="aclassMooseMesh_html_a197914260c452478db68edb610880087"><div class="ttname"><a href="classMooseMesh.html#a197914260c452478db68edb610880087">MooseMesh::dimension</a></div><div class="ttdeci">virtual unsigned int dimension() const</div><div class="ttdoc">Returns MeshBase::mesh_dimension(), (not MeshBase::spatial_dimension()!) of the underlying libMesh me...</div><div class="ttdef"><b>Definition:</b> <a href="MooseMesh_8C_source.html#l02668">MooseMesh.C:2668</a></div></div>
<div class="ttc" id="aclassMoose_1_1FunctorBase_html_a5e50a49fcfdb8fbd219de440171a26dd"><div class="ttname"><a href="classMoose_1_1FunctorBase.html#a5e50a49fcfdb8fbd219de440171a26dd">Moose::FunctorBase::hasBlocks</a></div><div class="ttdeci">virtual bool hasBlocks(SubdomainID) const</div><div class="ttdoc">Returns whether the functor is defined on this block.</div><div class="ttdef"><b>Definition:</b> <a href="MooseFunctor_8h_source.html#l00144">MooseFunctor.h:144</a></div></div>
<div class="ttc" id="anamespaceMoose_1_1FV_html_a181e9d146f7d17fcd56ff75f166efac6"><div class="ttname"><a href="namespaceMoose_1_1FV.html#a181e9d146f7d17fcd56ff75f166efac6">Moose::FV::interpolate</a></div><div class="ttdeci">void interpolate(InterpMethod m, T &amp;result, const T2 &amp;value1, const T3 &amp;value2, const FaceInfo &amp;fi, const bool one_is_elem)</div><div class="ttdoc">Provides interpolation of face values for non-advection-specific purposes (although it can/will still...</div><div class="ttdef"><b>Definition:</b> <a href="MathFVUtils_8h_source.html#l00272">MathFVUtils.h:272</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a9f0f08a7eaa8a0a3af7e57b85239b261" name="a9f0f08a7eaa8a0a3af7e57b85239b261"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f0f08a7eaa8a0a3af7e57b85239b261">&#9670;&#160;</a></span>greenGaussGradient() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMoose_1_1FunctorBase.html">Moose::FunctorBase</a>&lt; std::array&lt; T, N &gt; &gt;::GradientType Moose::FV::greenGaussGradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMoose_1_1FaceArg.html">FaceArg</a> &amp;&#160;</td>
          <td class="paramname"><em>face_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMoose_1_1StateArg.html">StateArg</a> &amp;&#160;</td>
          <td class="paramname"><em>state_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMoose_1_1FunctorBase.html">Moose::FunctorBase</a>&lt; std::array&lt; T, N &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>two_term_boundary_expansion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMooseMesh.html">MooseMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="GreenGaussGradient_8h_source.html#l00433">433</a> of file <a class="el" href="GreenGaussGradient_8h_source.html">GreenGaussGradient.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  438</span>{</div>
<div class="line"><span class="lineno">  439</span>  <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code hl_class" href="classMoose_1_1FunctorBase.html">Moose::FunctorBase&lt;std::array&lt;T, N&gt;</a>&gt;::GradientType GradientType;</div>
<div class="line"><span class="lineno">  440</span>  GradientType ret;</div>
<div class="line"><span class="lineno">  441</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : make_range(N))</div>
<div class="line"><span class="lineno">  442</span>  {</div>
<div class="line"><span class="lineno">  443</span>    <span class="comment">// Note that this can be very inefficient. Within the scalar greenGaussGradient routine we&#39;re</span></div>
<div class="line"><span class="lineno">  444</span>    <span class="comment">// going to do value type evaluations of the array functor from scalar_functor and we will be</span></div>
<div class="line"><span class="lineno">  445</span>    <span class="comment">// discarding all the value type evaluations other than the one corresponding to i</span></div>
<div class="line"><span class="lineno">  446</span>    <a class="code hl_class" href="classMoose_1_1ArrayComponentFunctor.html">ArrayComponentFunctor&lt;T, FunctorBase&lt;std::array&lt;T, N&gt;</a>&gt;&gt; scalar_functor(functor, i);</div>
<div class="line"><span class="lineno">  447</span>    ret[i] =</div>
<div class="line"><span class="lineno">  448</span>        <a class="code hl_function" href="namespaceMoose_1_1FV.html#a9390f7c56eb001f809b1a40e6568008e">greenGaussGradient</a>(face_arg, state_arg, scalar_functor, two_term_boundary_expansion, mesh);</div>
<div class="line"><span class="lineno">  449</span>  }</div>
<div class="line"><span class="lineno">  450</span> </div>
<div class="line"><span class="lineno">  451</span>  <span class="keywordflow">return</span> ret;</div>
<div class="line"><span class="lineno">  452</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a33a3d177e46dbb67a9b5949c8d9e6d7a" name="a33a3d177e46dbb67a9b5949c8d9e6d7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33a3d177e46dbb67a9b5949c8d9e6d7a">&#9670;&#160;</a></span>greenGaussGradient() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMoose_1_1FunctorBase.html">Moose::FunctorBase</a>&lt; std::vector&lt; T &gt; &gt;::GradientType Moose::FV::greenGaussGradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMoose_1_1FaceArg.html">FaceArg</a> &amp;&#160;</td>
          <td class="paramname"><em>face_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMoose_1_1StateArg.html">StateArg</a> &amp;&#160;</td>
          <td class="paramname"><em>state_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMoose_1_1FunctorBase.html">Moose::FunctorBase</a>&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>two_term_boundary_expansion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMooseMesh.html">MooseMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="GreenGaussGradient_8h_source.html#l00385">385</a> of file <a class="el" href="GreenGaussGradient_8h_source.html">GreenGaussGradient.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  390</span>{</div>
<div class="line"><span class="lineno">  391</span>  <span class="comment">// Determine the size of the container</span></div>
<div class="line"><span class="lineno">  392</span>  <span class="keyword">const</span> <span class="keyword">auto</span> vals = functor(face_arg, state_arg);</div>
<div class="line"><span class="lineno">  393</span>  <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code hl_class" href="classMoose_1_1FunctorBase.html">Moose::FunctorBase&lt;std::vector&lt;T&gt;</a>&gt;::GradientType GradientType;</div>
<div class="line"><span class="lineno">  394</span>  GradientType ret(vals.size());</div>
<div class="line"><span class="lineno">  395</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : index_range(ret))</div>
<div class="line"><span class="lineno">  396</span>  {</div>
<div class="line"><span class="lineno">  397</span>    <span class="comment">// Note that this can be very inefficient. Within the scalar greenGaussGradient routine we&#39;re</span></div>
<div class="line"><span class="lineno">  398</span>    <span class="comment">// going to do value type evaluations of the array functor from scalar_functor and we will be</span></div>
<div class="line"><span class="lineno">  399</span>    <span class="comment">// discarding all the value type evaluations other than the one corresponding to i</span></div>
<div class="line"><span class="lineno">  400</span>    <a class="code hl_class" href="classMoose_1_1ArrayComponentFunctor.html">ArrayComponentFunctor&lt;T, FunctorBase&lt;std::vector&lt;T&gt;</a>&gt;&gt; scalar_functor(functor, i);</div>
<div class="line"><span class="lineno">  401</span>    ret[i] =</div>
<div class="line"><span class="lineno">  402</span>        <a class="code hl_function" href="namespaceMoose_1_1FV.html#a9390f7c56eb001f809b1a40e6568008e">greenGaussGradient</a>(face_arg, state_arg, scalar_functor, two_term_boundary_expansion, mesh);</div>
<div class="line"><span class="lineno">  403</span>  }</div>
<div class="line"><span class="lineno">  404</span> </div>
<div class="line"><span class="lineno">  405</span>  <span class="keywordflow">return</span> ret;</div>
<div class="line"><span class="lineno">  406</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab8e28705d3772632b864c7e93250566f" name="ab8e28705d3772632b864c7e93250566f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8e28705d3772632b864c7e93250566f">&#9670;&#160;</a></span>greenGaussGradient() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TensorValue&lt; T &gt; Moose::FV::greenGaussGradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structMoose_1_1FaceArg.html">FaceArg</a> &amp;&#160;</td>
          <td class="paramname"><em>face_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMoose_1_1StateArg.html">StateArg</a> &amp;&#160;</td>
          <td class="paramname"><em>state_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMoose_1_1FunctorBase.html">Moose::FunctorBase</a>&lt; VectorValue&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>two_term_boundary_expansion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMooseMesh.html">MooseMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="GreenGaussGradient_8h_source.html#l00339">339</a> of file <a class="el" href="GreenGaussGradient_8h_source.html">GreenGaussGradient.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  344</span>{</div>
<div class="line"><span class="lineno">  345</span>  TensorValue&lt;T&gt; ret;</div>
<div class="line"><span class="lineno">  346</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : make_range(<span class="keywordtype">unsigned</span>(<a class="code hl_variable" href="namespaceMoose.html#a87e3992d5ec454469678e28370766430">Moose::dim</a>)))</div>
<div class="line"><span class="lineno">  347</span>  {</div>
<div class="line"><span class="lineno">  348</span>    <a class="code hl_class" href="classMoose_1_1VectorComponentFunctor.html">VectorComponentFunctor&lt;T&gt;</a> scalar_functor(functor, i);</div>
<div class="line"><span class="lineno">  349</span>    <span class="keyword">const</span> <span class="keyword">auto</span> row_gradient =</div>
<div class="line"><span class="lineno">  350</span>        <a class="code hl_function" href="namespaceMoose_1_1FV.html#a9390f7c56eb001f809b1a40e6568008e">greenGaussGradient</a>(face_arg, state_arg, scalar_functor, two_term_boundary_expansion, mesh);</div>
<div class="line"><span class="lineno">  351</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> j : make_range(<span class="keywordtype">unsigned</span>(<a class="code hl_variable" href="namespaceMoose.html#a87e3992d5ec454469678e28370766430">Moose::dim</a>)))</div>
<div class="line"><span class="lineno">  352</span>      ret(i, j) = row_gradient(j);</div>
<div class="line"><span class="lineno">  353</span>  }</div>
<div class="line"><span class="lineno">  354</span> </div>
<div class="line"><span class="lineno">  355</span>  <span class="keywordflow">return</span> ret;</div>
<div class="line"><span class="lineno">  356</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3c9021070513a8b6bb21753e7b662920" name="a3c9021070513a8b6bb21753e7b662920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c9021070513a8b6bb21753e7b662920">&#9670;&#160;</a></span>harmonicInterpolation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">libMesh::CompareTypes&lt; T1, T2 &gt;::supertype Moose::FV::harmonicInterpolation </td>
          <td>(</td>
          <td class="paramtype">const T1 &amp;&#160;</td>
          <td class="paramname"><em>value1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>value2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFaceInfo.html">FaceInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>fi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>one_is_elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the harmonic mean (1/(gc/value1+(1-gc)/value2)) of Reals, RealVectorValues and RealTensorValues while accounting for the possibility that one or both of them are AD. </p>
<p >For tensors, we use a component-wise mean instead of the matrix-inverse based option. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value1</td><td>Reference to value1 in the (1/(gc/value1+(1-gc)/value2)) expression </td></tr>
    <tr><td class="paramname">value2</td><td>Reference to value2 in the (1/(gc/value1+(1-gc)/value2)) expression </td></tr>
    <tr><td class="paramname">fi</td><td>Reference to the <a class="el" href="classFaceInfo.html" title="This data structure is used to store geometric and variable related metadata about each cell face in ...">FaceInfo</a> of the face on which the interpolation is requested </td></tr>
    <tr><td class="paramname">one_is_elem</td><td>Boolean indicating if the interpolation weight on <a class="el" href="classFaceInfo.html" title="This data structure is used to store geometric and variable related metadata about each cell face in ...">FaceInfo</a> belongs to the element corresponding to value1 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The interpolated value </dd></dl>

<p class="definition">Definition at line <a class="el" href="MathFVUtils_8h_source.html#l00167">167</a> of file <a class="el" href="MathFVUtils_8h_source.html">MathFVUtils.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  171</span>{</div>
<div class="line"><span class="lineno">  172</span>  <span class="comment">// We check if the base values of the given template types match, if not we throw a compile-time</span></div>
<div class="line"><span class="lineno">  173</span>  <span class="comment">// error</span></div>
<div class="line"><span class="lineno">  174</span>  <span class="keyword">static_assert</span>(std::is_same&lt;typename MetaPhysicL::RawType&lt;T1&gt;::value_type,</div>
<div class="line"><span class="lineno">  175</span>                             <span class="keyword">typename</span> MetaPhysicL::RawType&lt;T2&gt;::value_type&gt;::value,</div>
<div class="line"><span class="lineno">  176</span>                <span class="stringliteral">&quot;The input values for harmonic interpolation need to have the same raw-value!&quot;</span>);</div>
<div class="line"><span class="lineno">  177</span> </div>
<div class="line"><span class="lineno">  178</span>  <span class="comment">// Fetch the interpolation coefficients, we use the exact same coefficients as for a simple</span></div>
<div class="line"><span class="lineno">  179</span>  <span class="comment">// weighted average</span></div>
<div class="line"><span class="lineno">  180</span>  <span class="keyword">const</span> <span class="keyword">auto</span> coeffs = <a class="code hl_function" href="namespaceMoose_1_1FV.html#aa8e347c5804ee209112eea6eab0a466f">interpCoeffs</a>(InterpMethod::Average, fi, one_is_elem);</div>
<div class="line"><span class="lineno">  181</span> </div>
<div class="line"><span class="lineno">  182</span>  <span class="comment">// We check if the types are fit to compute the harmonic mean of. This is done compile-time</span></div>
<div class="line"><span class="lineno">  183</span>  <span class="comment">// using constexpr. We start with Real/ADReal which is straightforward if the input values are</span></div>
<div class="line"><span class="lineno">  184</span>  <span class="comment">// positive.</span></div>
<div class="line"><span class="lineno">  185</span>  <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (libMesh::TensorTools::TensorTraits&lt;T1&gt;::rank == 0)</div>
<div class="line"><span class="lineno">  186</span>  {</div>
<div class="line"><span class="lineno">  187</span>    <span class="comment">// The harmonic mean of mixed positive and negative numbers (and 0 as well) is not well-defined</span></div>
<div class="line"><span class="lineno">  188</span>    <span class="comment">// so we assert that the input values shall be positive.</span></div>
<div class="line"><span class="lineno">  189</span><span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line"><span class="lineno">  190</span>    <span class="keywordflow">if</span> (value1 * value2 &lt;= 0)</div>
<div class="line"><span class="lineno">  191</span>      <a class="code hl_function" href="MooseError_8h.html#a3d351254665674621ecbd38f57bb28ae">mooseWarning</a>(<span class="stringliteral">&quot;Input values (&quot;</span> + <a class="code hl_function" href="namespaceMoose.html#a8575af67e4a573c2c942b82e49fbcf8a">Moose::stringify</a>(<a class="code hl_function" href="namespaceMetaPhysicL.html#a1c0a19c861d5f7813f7fb6825d8fe146">MetaPhysicL::raw_value</a>(value1)) + <span class="stringliteral">&quot; &amp; &quot;</span> +</div>
<div class="line"><span class="lineno">  192</span>                   <a class="code hl_function" href="namespaceMoose.html#a8575af67e4a573c2c942b82e49fbcf8a">Moose::stringify</a>(<a class="code hl_function" href="namespaceMetaPhysicL.html#a1c0a19c861d5f7813f7fb6825d8fe146">MetaPhysicL::raw_value</a>(value2)) +</div>
<div class="line"><span class="lineno">  193</span>                   <span class="stringliteral">&quot;) must be of the same sign for harmonic interpolation&quot;</span>);</div>
<div class="line"><span class="lineno">  194</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno">  195</span>    <span class="keywordflow">return</span> 1.0 / (coeffs.first / value1 + coeffs.second / value2);</div>
<div class="line"><span class="lineno">  196</span>  }</div>
<div class="line"><span class="lineno">  197</span>  <span class="comment">// For vectors (ADRealVectorValue, VectorValue), we take the component-wise harmonic mean</span></div>
<div class="line"><span class="lineno">  198</span>  <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (libMesh::TensorTools::TensorTraits&lt;T1&gt;::rank == 1)</div>
<div class="line"><span class="lineno">  199</span>  {</div>
<div class="line"><span class="lineno">  200</span>    <span class="keyword">typename</span> libMesh::CompareTypes&lt;T1, T2&gt;::supertype result;</div>
<div class="line"><span class="lineno">  201</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : make_range(<a class="code hl_variable" href="namespaceMoose.html#a87e3992d5ec454469678e28370766430">Moose::dim</a>))</div>
<div class="line"><span class="lineno">  202</span>    {</div>
<div class="line"><span class="lineno">  203</span><span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line"><span class="lineno">  204</span>      <span class="keywordflow">if</span> (value1(i) * value2(i) &lt;= 0)</div>
<div class="line"><span class="lineno">  205</span>        <a class="code hl_function" href="MooseError_8h.html#a3d351254665674621ecbd38f57bb28ae">mooseWarning</a>(<span class="stringliteral">&quot;Component &quot;</span> + std::to_string(i) + <span class="stringliteral">&quot; of input values (&quot;</span> +</div>
<div class="line"><span class="lineno">  206</span>                     <a class="code hl_function" href="namespaceMoose.html#a8575af67e4a573c2c942b82e49fbcf8a">Moose::stringify</a>(<a class="code hl_function" href="namespaceMetaPhysicL.html#a1c0a19c861d5f7813f7fb6825d8fe146">MetaPhysicL::raw_value</a>(value1(i))) + <span class="stringliteral">&quot; &amp; &quot;</span> +</div>
<div class="line"><span class="lineno">  207</span>                     <a class="code hl_function" href="namespaceMoose.html#a8575af67e4a573c2c942b82e49fbcf8a">Moose::stringify</a>(<a class="code hl_function" href="namespaceMetaPhysicL.html#a1c0a19c861d5f7813f7fb6825d8fe146">MetaPhysicL::raw_value</a>(value2(i))) +</div>
<div class="line"><span class="lineno">  208</span>                     <span class="stringliteral">&quot;) must be of the same sign for harmonic interpolation&quot;</span>);</div>
<div class="line"><span class="lineno">  209</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno">  210</span>      result(i) = 1.0 / (coeffs.first / value1(i) + coeffs.second / value2(i));</div>
<div class="line"><span class="lineno">  211</span>    }</div>
<div class="line"><span class="lineno">  212</span>    <span class="keywordflow">return</span> result;</div>
<div class="line"><span class="lineno">  213</span>  }</div>
<div class="line"><span class="lineno">  214</span>  <span class="comment">// For tensors (ADRealTensorValue, TensorValue), similarly to the vectors,</span></div>
<div class="line"><span class="lineno">  215</span>  <span class="comment">// we take the component-wise harmonic mean instead of the matrix-inverse approach</span></div>
<div class="line"><span class="lineno">  216</span>  <span class="keywordflow">else</span> <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (libMesh::TensorTools::TensorTraits&lt;T1&gt;::rank == 2)</div>
<div class="line"><span class="lineno">  217</span>  {</div>
<div class="line"><span class="lineno">  218</span>    <span class="keyword">typename</span> libMesh::CompareTypes&lt;T1, T2&gt;::supertype result;</div>
<div class="line"><span class="lineno">  219</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : make_range(<a class="code hl_variable" href="namespaceMoose.html#a87e3992d5ec454469678e28370766430">Moose::dim</a>))</div>
<div class="line"><span class="lineno">  220</span>      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> j : make_range(<a class="code hl_variable" href="namespaceMoose.html#a87e3992d5ec454469678e28370766430">Moose::dim</a>))</div>
<div class="line"><span class="lineno">  221</span>      {</div>
<div class="line"><span class="lineno">  222</span><span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line"><span class="lineno">  223</span>        <span class="keywordflow">if</span> (value1(i, j) * value2(i, j) &lt;= 0)</div>
<div class="line"><span class="lineno">  224</span>          <a class="code hl_function" href="MooseError_8h.html#a3d351254665674621ecbd38f57bb28ae">mooseWarning</a>(<span class="stringliteral">&quot;Component (&quot;</span> + std::to_string(i) + <span class="stringliteral">&quot;,&quot;</span> + std::to_string(j) +</div>
<div class="line"><span class="lineno">  225</span>                       <span class="stringliteral">&quot;) of input values (&quot;</span> +</div>
<div class="line"><span class="lineno">  226</span>                       <a class="code hl_function" href="namespaceMoose.html#a8575af67e4a573c2c942b82e49fbcf8a">Moose::stringify</a>(<a class="code hl_function" href="namespaceMetaPhysicL.html#a1c0a19c861d5f7813f7fb6825d8fe146">MetaPhysicL::raw_value</a>(value1(i, j))) + <span class="stringliteral">&quot; &amp; &quot;</span> +</div>
<div class="line"><span class="lineno">  227</span>                       <a class="code hl_function" href="namespaceMoose.html#a8575af67e4a573c2c942b82e49fbcf8a">Moose::stringify</a>(<a class="code hl_function" href="namespaceMetaPhysicL.html#a1c0a19c861d5f7813f7fb6825d8fe146">MetaPhysicL::raw_value</a>(value2(i, j))) +</div>
<div class="line"><span class="lineno">  228</span>                       <span class="stringliteral">&quot;) must be of the same sign for harmonic interpolation&quot;</span>);</div>
<div class="line"><span class="lineno">  229</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno">  230</span>        result(i, j) = 1.0 / (coeffs.first / value1(i, j) + coeffs.second / value2(i, j));</div>
<div class="line"><span class="lineno">  231</span>      }</div>
<div class="line"><span class="lineno">  232</span>    <span class="keywordflow">return</span> result;</div>
<div class="line"><span class="lineno">  233</span>  }</div>
<div class="line"><span class="lineno">  234</span>  <span class="comment">// We ran out of options, harmonic mean is not supported for other types at the moment</span></div>
<div class="line"><span class="lineno">  235</span>  <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  236</span>    <span class="comment">// This line is supposed to throw an error when the user tries to compile this function with</span></div>
<div class="line"><span class="lineno">  237</span>    <span class="comment">// types that are not supported. This is the reason we needed the always_false function. Hope as</span></div>
<div class="line"><span class="lineno">  238</span>    <span class="comment">// C++ gets nicer, we can do this in a nicer way.</span></div>
<div class="line"><span class="lineno">  239</span>    <span class="keyword">static_assert</span>(Moose::always_false&lt;T1&gt;,</div>
<div class="line"><span class="lineno">  240</span>                  <span class="stringliteral">&quot;Harmonic interpolation is not implemented for the used type!&quot;</span>);</div>
<div class="line"><span class="lineno">  241</span>}</div>
<div class="ttc" id="aMooseError_8h_html_a3d351254665674621ecbd38f57bb28ae"><div class="ttname"><a href="MooseError_8h.html#a3d351254665674621ecbd38f57bb28ae">mooseWarning</a></div><div class="ttdeci">void mooseWarning(Args &amp;&amp;... args)</div><div class="ttdoc">Emit a warning message with the given stringified, concatenated args.</div><div class="ttdef"><b>Definition:</b> <a href="MooseError_8h_source.html#l00296">MooseError.h:296</a></div></div>
<div class="ttc" id="anamespaceMoose_html_a8575af67e4a573c2c942b82e49fbcf8a"><div class="ttname"><a href="namespaceMoose.html#a8575af67e4a573c2c942b82e49fbcf8a">Moose::stringify</a></div><div class="ttdeci">std::string stringify(const RelationshipManagerType &amp;t)</div><div class="ttdef"><b>Definition:</b> <a href="Conversion_8C_source.html#l00324">Conversion.C:324</a></div></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="MathFVUtils_8h_source.html#l00272">interpolate()</a>.</p>

</div>
</div>
<a id="aa8e347c5804ee209112eea6eab0a466f" name="aa8e347c5804ee209112eea6eab0a466f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8e347c5804ee209112eea6eab0a466f">&#9670;&#160;</a></span>interpCoeffs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vector  = RealVectorValue&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; Real, Real &gt; Moose::FV::interpCoeffs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceMoose_1_1FV.html#a5941595b238d0963e4fe80718ab7dd50">InterpMethod</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFaceInfo.html">FaceInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>fi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>one_is_elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector&#160;</td>
          <td class="paramname"><em>advector</em> = <code>Vector()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Produce the interpolation coefficients in the equation: </p>
<p >\phi_f = c_1 * \phi_{F1} + c_2 * \phi_{F2}</p>
<p >A couple of examples: if we are doing an average interpolation with an orthogonal regular grid, then the pair will be (0.5, 0.5). If we are doing an upwind interpolation with the velocity facing outward from the F1 element, then the pair will be (1.0, 0.0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The interpolation method </td></tr>
    <tr><td class="paramname">fi</td><td>The face information </td></tr>
    <tr><td class="paramname">one_is_elem</td><td>Whether fi.elem() == F1 </td></tr>
    <tr><td class="paramname">advector</td><td>The advecting velocity. Not relevant for an Average interpolation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair where the first Real is c_1 and the second Real is c_2 </dd></dl>

<p class="definition">Definition at line <a class="el" href="MathFVUtils_8h_source.html#l00104">104</a> of file <a class="el" href="MathFVUtils_8h_source.html">MathFVUtils.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  108</span>{</div>
<div class="line"><span class="lineno">  109</span>  <span class="keywordflow">switch</span> (m)</div>
<div class="line"><span class="lineno">  110</span>  {</div>
<div class="line"><span class="lineno">  111</span>    <span class="keywordflow">case</span> InterpMethod::Average:</div>
<div class="line"><span class="lineno">  112</span>    <span class="keywordflow">case</span> InterpMethod::SkewCorrectedAverage:</div>
<div class="line"><span class="lineno">  113</span>    {</div>
<div class="line"><span class="lineno">  114</span>      <span class="keywordflow">if</span> (one_is_elem)</div>
<div class="line"><span class="lineno">  115</span>        <span class="keywordflow">return</span> std::make_pair(fi.<a class="code hl_function" href="classFaceInfo.html#ae8b96282e17476a9e8260fee7646d231">gC</a>(), 1. - fi.<a class="code hl_function" href="classFaceInfo.html#ae8b96282e17476a9e8260fee7646d231">gC</a>());</div>
<div class="line"><span class="lineno">  116</span>      <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  117</span>        <span class="keywordflow">return</span> std::make_pair(1. - fi.<a class="code hl_function" href="classFaceInfo.html#ae8b96282e17476a9e8260fee7646d231">gC</a>(), fi.<a class="code hl_function" href="classFaceInfo.html#ae8b96282e17476a9e8260fee7646d231">gC</a>());</div>
<div class="line"><span class="lineno">  118</span>    }</div>
<div class="line"><span class="lineno">  119</span> </div>
<div class="line"><span class="lineno">  120</span>    <span class="keywordflow">case</span> InterpMethod::Upwind:</div>
<div class="line"><span class="lineno">  121</span>    {</div>
<div class="line"><span class="lineno">  122</span>      <span class="keywordflow">if</span> ((advector * fi.<a class="code hl_function" href="classFaceInfo.html#a207d78600df922cedd8b08421f87f655">normal</a>() &gt; 0) == one_is_elem)</div>
<div class="line"><span class="lineno">  123</span>        <span class="keywordflow">return</span> std::make_pair(1., 0.);</div>
<div class="line"><span class="lineno">  124</span>      <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  125</span>        <span class="keywordflow">return</span> std::make_pair(0., 1.);</div>
<div class="line"><span class="lineno">  126</span>    }</div>
<div class="line"><span class="lineno">  127</span> </div>
<div class="line"><span class="lineno">  128</span>    <span class="keywordflow">default</span>:</div>
<div class="line"><span class="lineno">  129</span>      <a class="code hl_function" href="MooseError_8h.html#aa959168eed29caa7aaa85ffc1319a9ad">mooseError</a>(<span class="stringliteral">&quot;Unrecognized interpolation method&quot;</span>);</div>
<div class="line"><span class="lineno">  130</span>  }</div>
<div class="line"><span class="lineno">  131</span>}</div>
<div class="ttc" id="aclassFaceInfo_html_ae8b96282e17476a9e8260fee7646d231"><div class="ttname"><a href="classFaceInfo.html#ae8b96282e17476a9e8260fee7646d231">FaceInfo::gC</a></div><div class="ttdeci">Real gC() const</div><div class="ttdoc">Return the geometric weighting factor.</div><div class="ttdef"><b>Definition:</b> <a href="FaceInfo_8h_source.html#l00128">FaceInfo.h:128</a></div></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="MathFVUtils_8h_source.html#l00633">containerInterpolate()</a>, <a class="el" href="MathFVUtils_8h_source.html#l00167">harmonicInterpolation()</a>, <a class="el" href="MathFVUtils_8h_source.html#l00534">interpCoeffsAndAdvected()</a>, <a class="el" href="MathFVUtils_8h_source.html#l00386">interpolate()</a>, <a class="el" href="MathFVUtils_8h_source.html#l00140">linearInterpolation()</a>, and <a class="el" href="MathFVUtils_8h_source.html#l00251">skewCorrectedLinearInterpolation()</a>.</p>

</div>
</div>
<a id="a01c43f768c0d93b5e4a4dfddc2c60d73" name="a01c43f768c0d93b5e4a4dfddc2c60d73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01c43f768c0d93b5e4a4dfddc2c60d73">&#9670;&#160;</a></span>interpCoeffs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; T, T &gt; Moose::FV::interpCoeffs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMoose_1_1FV_1_1Limiter.html">Limiter</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>limiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>phi_upwind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>phi_downwind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorValue&lt; T &gt; *const&#160;</td>
          <td class="paramname"><em>grad_phi_upwind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFaceInfo.html">FaceInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>fi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>fi_elem_is_upwind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Produce the interpolation coefficients in the equation: </p>
<p >\phi_f = c_upwind * \phi_{upwind} + c_downwind * \phi_{downwind}</p>
<p >A couple of examples: if we are doing an average interpolation with an orthogonal regular grid, then the pair will be (0.5, 0.5). If we are doing an upwind interpolation then the pair will be (1.0, 0.0).</p>
<dl class="section return"><dt>Returns</dt><dd>a pair where the first Real is c_upwind and the second Real is c_downwind </dd></dl>

<p class="definition">Definition at line <a class="el" href="MathFVUtils_8h_source.html#l00456">456</a> of file <a class="el" href="MathFVUtils_8h_source.html">MathFVUtils.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  462</span>{</div>
<div class="line"><span class="lineno">  463</span>  <span class="comment">// Using beta, w_f, g nomenclature from Greenshields</span></div>
<div class="line"><span class="lineno">  464</span>  <span class="keyword">const</span> <span class="keyword">auto</span> beta = limiter(</div>
<div class="line"><span class="lineno">  465</span>      phi_upwind, phi_downwind, grad_phi_upwind, fi_elem_is_upwind ? fi.<a class="code hl_function" href="classFaceInfo.html#acc87707f37348ceb831440067b53f35e">dCN</a>() : Point(-fi.<a class="code hl_function" href="classFaceInfo.html#acc87707f37348ceb831440067b53f35e">dCN</a>()));</div>
<div class="line"><span class="lineno">  466</span> </div>
<div class="line"><span class="lineno">  467</span>  <span class="keyword">const</span> <span class="keyword">auto</span> w_f = fi_elem_is_upwind ? fi.<a class="code hl_function" href="classFaceInfo.html#ae8b96282e17476a9e8260fee7646d231">gC</a>() : (1. - fi.<a class="code hl_function" href="classFaceInfo.html#ae8b96282e17476a9e8260fee7646d231">gC</a>());</div>
<div class="line"><span class="lineno">  468</span> </div>
<div class="line"><span class="lineno">  469</span>  <span class="keyword">const</span> <span class="keyword">auto</span> g = beta * (1. - w_f);</div>
<div class="line"><span class="lineno">  470</span> </div>
<div class="line"><span class="lineno">  471</span>  <span class="keywordflow">return</span> std::make_pair(1. - g, g);</div>
<div class="line"><span class="lineno">  472</span>}</div>
<div class="ttc" id="aclassFaceInfo_html_acc87707f37348ceb831440067b53f35e"><div class="ttname"><a href="classFaceInfo.html#acc87707f37348ceb831440067b53f35e">FaceInfo::dCN</a></div><div class="ttdeci">const Point &amp; dCN() const</div><div class="ttdef"><b>Definition:</b> <a href="FaceInfo_8h_source.html#l00134">FaceInfo.h:134</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="afe4267099c59edd237ac32dfc1846ead" name="afe4267099c59edd237ac32dfc1846ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe4267099c59edd237ac32dfc1846ead">&#9670;&#160;</a></span>interpCoeffsAndAdvected()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Enable  = typename std::enable_if&lt;ScalarTraits&lt;T&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::pair&lt; T, T &gt;, std::pair&lt; T, T &gt; &gt; Moose::FV::interpCoeffsAndAdvected </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMoose_1_1FunctorBase.html">FunctorBase</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMoose_1_1FaceArg.html">FaceArg</a> &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMoose_1_1StateArg.html">StateArg</a> &amp;&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolates with a limiter and a face argument. </p>
<dl class="section return"><dt>Returns</dt><dd>a pair of pairs. The first pair corresponds to the interpolation coefficients with the first corresponding to the face information element and the second corresponding to the face information neighbor. This pair should sum to unity. The second pair corresponds to the face information functor element value and neighbor </dd></dl>

<p class="definition">Definition at line <a class="el" href="MathFVUtils_8h_source.html#l00534">534</a> of file <a class="el" href="MathFVUtils_8h_source.html">MathFVUtils.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  535</span>{</div>
<div class="line"><span class="lineno">  536</span>  <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code hl_typedef" href="classMoose_1_1FunctorBase.html#a685241a79ab4cfb9d48e761c87b665e8">FunctorBase&lt;T&gt;::GradientType</a> GradientType;</div>
<div class="line"><span class="lineno">  537</span>  <span class="keyword">static</span> <span class="keyword">const</span> GradientType zero(0);</div>
<div class="line"><span class="lineno">  538</span> </div>
<div class="line"><span class="lineno">  539</span>  mooseAssert(face.<a class="code hl_variable" href="structMoose_1_1FaceArg.html#adbe9c167b0afacad24a0ca70959d0a43">fi</a>, <span class="stringliteral">&quot;this must be non-null&quot;</span>);</div>
<div class="line"><span class="lineno">  540</span>  <span class="keyword">const</span> <span class="keyword">auto</span> limiter = <a class="code hl_class" href="classMoose_1_1FV_1_1Limiter.html">Limiter&lt;typename LimiterValueType&lt;T&gt;::value_type</a>&gt;::build(face.<a class="code hl_variable" href="structMoose_1_1FaceArg.html#ac1c78c58d94868ff061cae2f1796544f">limiter_type</a>);</div>
<div class="line"><span class="lineno">  541</span> </div>
<div class="line"><span class="lineno">  542</span>  <span class="keyword">const</span> <span class="keyword">auto</span> upwind_arg = face.<a class="code hl_variable" href="structMoose_1_1FaceArg.html#a792bf64c2222c6158ad37ee0921d34ca">elem_is_upwind</a> ? face.<a class="code hl_function" href="structMoose_1_1FaceArg.html#a8c1e438f2efba06f4ba4436ff427034b">makeElem</a>() : face.<a class="code hl_function" href="structMoose_1_1FaceArg.html#a6b1b2bf253cb75ddb36a6ceca1f7b1f5">makeNeighbor</a>();</div>
<div class="line"><span class="lineno">  543</span>  <span class="keyword">const</span> <span class="keyword">auto</span> downwind_arg = face.<a class="code hl_variable" href="structMoose_1_1FaceArg.html#a792bf64c2222c6158ad37ee0921d34ca">elem_is_upwind</a> ? face.<a class="code hl_function" href="structMoose_1_1FaceArg.html#a6b1b2bf253cb75ddb36a6ceca1f7b1f5">makeNeighbor</a>() : face.<a class="code hl_function" href="structMoose_1_1FaceArg.html#a8c1e438f2efba06f4ba4436ff427034b">makeElem</a>();</div>
<div class="line"><span class="lineno">  544</span>  <span class="keyword">auto</span> phi_upwind = functor(upwind_arg, time);</div>
<div class="line"><span class="lineno">  545</span>  <span class="keyword">auto</span> phi_downwind = functor(downwind_arg, time);</div>
<div class="line"><span class="lineno">  546</span> </div>
<div class="line"><span class="lineno">  547</span>  std::pair&lt;T, T&gt; interp_coeffs;</div>
<div class="line"><span class="lineno">  548</span>  <span class="keywordflow">if</span> (face.<a class="code hl_variable" href="structMoose_1_1FaceArg.html#ac1c78c58d94868ff061cae2f1796544f">limiter_type</a> == LimiterType::Upwind ||</div>
<div class="line"><span class="lineno">  549</span>      face.<a class="code hl_variable" href="structMoose_1_1FaceArg.html#ac1c78c58d94868ff061cae2f1796544f">limiter_type</a> == LimiterType::CentralDifference)</div>
<div class="line"><span class="lineno">  550</span>    interp_coeffs =</div>
<div class="line"><span class="lineno">  551</span>        <a class="code hl_function" href="namespaceMoose_1_1FV.html#aa8e347c5804ee209112eea6eab0a466f">interpCoeffs</a>(*limiter, phi_upwind, phi_downwind, &amp;zero, *face.<a class="code hl_variable" href="structMoose_1_1FaceArg.html#adbe9c167b0afacad24a0ca70959d0a43">fi</a>, face.<a class="code hl_variable" href="structMoose_1_1FaceArg.html#a792bf64c2222c6158ad37ee0921d34ca">elem_is_upwind</a>);</div>
<div class="line"><span class="lineno">  552</span>  <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  553</span>  {</div>
<div class="line"><span class="lineno">  554</span>    <span class="keyword">const</span> <span class="keyword">auto</span> grad_phi_upwind = functor.<a class="code hl_function" href="classMoose_1_1FunctorBase.html#aa28f70bdf3145308d437a8d8f26fa364">gradient</a>(upwind_arg, time);</div>
<div class="line"><span class="lineno">  555</span>    interp_coeffs = <a class="code hl_function" href="namespaceMoose_1_1FV.html#aa8e347c5804ee209112eea6eab0a466f">interpCoeffs</a>(</div>
<div class="line"><span class="lineno">  556</span>        *limiter, phi_upwind, phi_downwind, &amp;grad_phi_upwind, *face.<a class="code hl_variable" href="structMoose_1_1FaceArg.html#adbe9c167b0afacad24a0ca70959d0a43">fi</a>, face.<a class="code hl_variable" href="structMoose_1_1FaceArg.html#a792bf64c2222c6158ad37ee0921d34ca">elem_is_upwind</a>);</div>
<div class="line"><span class="lineno">  557</span>  }</div>
<div class="line"><span class="lineno">  558</span> </div>
<div class="line"><span class="lineno">  559</span>  <span class="keywordflow">if</span> (face.<a class="code hl_variable" href="structMoose_1_1FaceArg.html#a792bf64c2222c6158ad37ee0921d34ca">elem_is_upwind</a>)</div>
<div class="line"><span class="lineno">  560</span>    <span class="keywordflow">return</span> std::make_pair(std::move(interp_coeffs),</div>
<div class="line"><span class="lineno">  561</span>                          std::make_pair(std::move(phi_upwind), std::move(phi_downwind)));</div>
<div class="line"><span class="lineno">  562</span>  <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  563</span>    <span class="keywordflow">return</span> std::make_pair(</div>
<div class="line"><span class="lineno">  564</span>        std::make_pair(std::move(interp_coeffs.second), std::move(interp_coeffs.first)),</div>
<div class="line"><span class="lineno">  565</span>        std::make_pair(std::move(phi_downwind), std::move(phi_upwind)));</div>
<div class="line"><span class="lineno">  566</span>}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="MathFVUtils_8h_source.html#l00570">interpolate()</a>.</p>

</div>
</div>
<a id="ab46f1afeefa34be234231e44a8190c00" name="ab46f1afeefa34be234231e44a8190c00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab46f1afeefa34be234231e44a8190c00">&#9670;&#160;</a></span>interpolate() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; T, N &gt; Moose::FV::interpolate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMoose_1_1FunctorBase.html">FunctorBase</a>&lt; std::array&lt; T, N &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMoose_1_1FaceArg.html">FaceArg</a> &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMoose_1_1StateArg.html">StateArg</a> &amp;&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MathFVUtils_8h_source.html#l00693">693</a> of file <a class="el" href="MathFVUtils_8h_source.html">MathFVUtils.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  696</span>{</div>
<div class="line"><span class="lineno">  697</span>  <span class="keywordflow">return</span> <a class="code hl_function" href="namespaceMoose_1_1FV.html#a26af73ced485536f98bd9e46f124f0a5">containerInterpolate</a>(functor, face, time);</div>
<div class="line"><span class="lineno">  698</span>}</div>
<div class="ttc" id="anamespaceMoose_1_1FV_html_a26af73ced485536f98bd9e46f124f0a5"><div class="ttname"><a href="namespaceMoose_1_1FV.html#a26af73ced485536f98bd9e46f124f0a5">Moose::FV::containerInterpolate</a></div><div class="ttdeci">T containerInterpolate(const FunctorBase&lt; T &gt; &amp;functor, const FaceArg &amp;face, const StateArg &amp;time)</div><div class="ttdef"><b>Definition:</b> <a href="MathFVUtils_8h_source.html#l00633">MathFVUtils.h:633</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a76f2e9b45452546eef0595a2b432a1b5" name="a76f2e9b45452546eef0595a2b432a1b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76f2e9b45452546eef0595a2b432a1b5">&#9670;&#160;</a></span>interpolate() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; T &gt; Moose::FV::interpolate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMoose_1_1FunctorBase.html">FunctorBase</a>&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMoose_1_1FaceArg.html">FaceArg</a> &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMoose_1_1StateArg.html">StateArg</a> &amp;&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MathFVUtils_8h_source.html#l00684">684</a> of file <a class="el" href="MathFVUtils_8h_source.html">MathFVUtils.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  687</span>{</div>
<div class="line"><span class="lineno">  688</span>  <span class="keywordflow">return</span> <a class="code hl_function" href="namespaceMoose_1_1FV.html#a26af73ced485536f98bd9e46f124f0a5">containerInterpolate</a>(functor, face, time);</div>
<div class="line"><span class="lineno">  689</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5b16d9fd94653065b562cfc60b75b03d" name="a5b16d9fd94653065b562cfc60b75b03d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b16d9fd94653065b562cfc60b75b03d">&#9670;&#160;</a></span>interpolate() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Enable  = typename std::enable_if&lt;ScalarTraits&lt;T&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Moose::FV::interpolate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMoose_1_1FunctorBase.html">FunctorBase</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMoose_1_1FaceArg.html">FaceArg</a> &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMoose_1_1StateArg.html">StateArg</a> &amp;&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MathFVUtils_8h_source.html#l00570">570</a> of file <a class="el" href="MathFVUtils_8h_source.html">MathFVUtils.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  571</span>{</div>
<div class="line"><span class="lineno">  572</span>  <span class="comment">// Special handling for central differencing as it is the only interpolation method which</span></div>
<div class="line"><span class="lineno">  573</span>  <span class="comment">// currently supports skew correction</span></div>
<div class="line"><span class="lineno">  574</span>  <span class="keywordflow">if</span> (face.<a class="code hl_variable" href="structMoose_1_1FaceArg.html#ac1c78c58d94868ff061cae2f1796544f">limiter_type</a> == LimiterType::CentralDifference)</div>
<div class="line"><span class="lineno">  575</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="namespaceMoose_1_1FV.html#a4d222a7b752432de3ee9ad82a150dd80">linearInterpolation</a>(functor, face, time);</div>
<div class="line"><span class="lineno">  576</span> </div>
<div class="line"><span class="lineno">  577</span>  <span class="keyword">const</span> <span class="keyword">auto</span> [interp_coeffs, advected] = <a class="code hl_function" href="namespaceMoose_1_1FV.html#afe4267099c59edd237ac32dfc1846ead">interpCoeffsAndAdvected</a>(functor, face, time);</div>
<div class="line"><span class="lineno">  578</span>  <span class="keywordflow">return</span> interp_coeffs.first * advected.first + interp_coeffs.second * advected.second;</div>
<div class="line"><span class="lineno">  579</span>}</div>
<div class="ttc" id="anamespaceMoose_1_1FV_html_a4d222a7b752432de3ee9ad82a150dd80"><div class="ttname"><a href="namespaceMoose_1_1FV.html#a4d222a7b752432de3ee9ad82a150dd80">Moose::FV::linearInterpolation</a></div><div class="ttdeci">libMesh::CompareTypes&lt; T, T2 &gt;::supertype linearInterpolation(const T &amp;value1, const T2 &amp;value2, const FaceInfo &amp;fi, const bool one_is_elem, const InterpMethod interp_method=InterpMethod::Average)</div><div class="ttdoc">A simple linear interpolation of values between cell centers to a cell face.</div><div class="ttdef"><b>Definition:</b> <a href="MathFVUtils_8h_source.html#l00140">MathFVUtils.h:140</a></div></div>
<div class="ttc" id="anamespaceMoose_1_1FV_html_afe4267099c59edd237ac32dfc1846ead"><div class="ttname"><a href="namespaceMoose_1_1FV.html#afe4267099c59edd237ac32dfc1846ead">Moose::FV::interpCoeffsAndAdvected</a></div><div class="ttdeci">std::pair&lt; std::pair&lt; T, T &gt;, std::pair&lt; T, T &gt; &gt; interpCoeffsAndAdvected(const FunctorBase&lt; T &gt; &amp;functor, const FaceArg &amp;face, const StateArg &amp;time)</div><div class="ttdoc">Interpolates with a limiter and a face argument.</div><div class="ttdef"><b>Definition:</b> <a href="MathFVUtils_8h_source.html#l00534">MathFVUtils.h:534</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a06a1c4b434ffe35faa009e6c46ecfee3" name="a06a1c4b434ffe35faa009e6c46ecfee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06a1c4b434ffe35faa009e6c46ecfee3">&#9670;&#160;</a></span>interpolate() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VectorValue&lt; T &gt; Moose::FV::interpolate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMoose_1_1FunctorBase.html">FunctorBase</a>&lt; VectorValue&lt; T &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMoose_1_1FaceArg.html">FaceArg</a> &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMoose_1_1StateArg.html">StateArg</a> &amp;&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MathFVUtils_8h_source.html#l00583">583</a> of file <a class="el" href="MathFVUtils_8h_source.html">MathFVUtils.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  586</span>{</div>
<div class="line"><span class="lineno">  587</span>  <span class="keyword">static</span> <span class="keyword">const</span> VectorValue&lt;T&gt; grad_zero(0);</div>
<div class="line"><span class="lineno">  588</span> </div>
<div class="line"><span class="lineno">  589</span>  mooseAssert(face.<a class="code hl_variable" href="structMoose_1_1FaceArg.html#adbe9c167b0afacad24a0ca70959d0a43">fi</a>, <span class="stringliteral">&quot;this must be non-null&quot;</span>);</div>
<div class="line"><span class="lineno">  590</span>  <span class="keyword">const</span> <span class="keyword">auto</span> limiter = <a class="code hl_class" href="classMoose_1_1FV_1_1Limiter.html">Limiter&lt;typename LimiterValueType&lt;T&gt;::value_type</a>&gt;::build(face.<a class="code hl_variable" href="structMoose_1_1FaceArg.html#ac1c78c58d94868ff061cae2f1796544f">limiter_type</a>);</div>
<div class="line"><span class="lineno">  591</span> </div>
<div class="line"><span class="lineno">  592</span>  <span class="keyword">const</span> <span class="keyword">auto</span> upwind_arg = face.<a class="code hl_variable" href="structMoose_1_1FaceArg.html#a792bf64c2222c6158ad37ee0921d34ca">elem_is_upwind</a> ? face.<a class="code hl_function" href="structMoose_1_1FaceArg.html#a8c1e438f2efba06f4ba4436ff427034b">makeElem</a>() : face.<a class="code hl_function" href="structMoose_1_1FaceArg.html#a6b1b2bf253cb75ddb36a6ceca1f7b1f5">makeNeighbor</a>();</div>
<div class="line"><span class="lineno">  593</span>  <span class="keyword">const</span> <span class="keyword">auto</span> downwind_arg = face.<a class="code hl_variable" href="structMoose_1_1FaceArg.html#a792bf64c2222c6158ad37ee0921d34ca">elem_is_upwind</a> ? face.<a class="code hl_function" href="structMoose_1_1FaceArg.html#a6b1b2bf253cb75ddb36a6ceca1f7b1f5">makeNeighbor</a>() : face.<a class="code hl_function" href="structMoose_1_1FaceArg.html#a8c1e438f2efba06f4ba4436ff427034b">makeElem</a>();</div>
<div class="line"><span class="lineno">  594</span>  <span class="keyword">auto</span> phi_upwind = functor(upwind_arg, time);</div>
<div class="line"><span class="lineno">  595</span>  <span class="keyword">auto</span> phi_downwind = functor(downwind_arg, time);</div>
<div class="line"><span class="lineno">  596</span> </div>
<div class="line"><span class="lineno">  597</span>  VectorValue&lt;T&gt; ret;</div>
<div class="line"><span class="lineno">  598</span>  T coeff_upwind, coeff_downwind;</div>
<div class="line"><span class="lineno">  599</span> </div>
<div class="line"><span class="lineno">  600</span>  <span class="keywordflow">if</span> (face.<a class="code hl_variable" href="structMoose_1_1FaceArg.html#ac1c78c58d94868ff061cae2f1796544f">limiter_type</a> == LimiterType::Upwind ||</div>
<div class="line"><span class="lineno">  601</span>      face.<a class="code hl_variable" href="structMoose_1_1FaceArg.html#ac1c78c58d94868ff061cae2f1796544f">limiter_type</a> == LimiterType::CentralDifference)</div>
<div class="line"><span class="lineno">  602</span>  {</div>
<div class="line"><span class="lineno">  603</span>    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; LIBMESH_DIM; ++i)</div>
<div class="line"><span class="lineno">  604</span>    {</div>
<div class="line"><span class="lineno">  605</span>      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;component_upwind = phi_upwind(i), component_downwind = phi_downwind(i);</div>
<div class="line"><span class="lineno">  606</span>      std::tie(coeff_upwind, coeff_downwind) = <a class="code hl_function" href="namespaceMoose_1_1FV.html#aa8e347c5804ee209112eea6eab0a466f">interpCoeffs</a>(*limiter,</div>
<div class="line"><span class="lineno">  607</span>                                                            component_upwind,</div>
<div class="line"><span class="lineno">  608</span>                                                            component_downwind,</div>
<div class="line"><span class="lineno">  609</span>                                                            &amp;grad_zero,</div>
<div class="line"><span class="lineno">  610</span>                                                            *face.<a class="code hl_variable" href="structMoose_1_1FaceArg.html#adbe9c167b0afacad24a0ca70959d0a43">fi</a>,</div>
<div class="line"><span class="lineno">  611</span>                                                            face.<a class="code hl_variable" href="structMoose_1_1FaceArg.html#a792bf64c2222c6158ad37ee0921d34ca">elem_is_upwind</a>);</div>
<div class="line"><span class="lineno">  612</span>      ret(i) = coeff_upwind * component_upwind + coeff_downwind * component_downwind;</div>
<div class="line"><span class="lineno">  613</span>    }</div>
<div class="line"><span class="lineno">  614</span>  }</div>
<div class="line"><span class="lineno">  615</span>  <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  616</span>  {</div>
<div class="line"><span class="lineno">  617</span>    <span class="keyword">const</span> <span class="keyword">auto</span> grad_phi_upwind = functor.<a class="code hl_function" href="classMoose_1_1FunctorBase.html#aa28f70bdf3145308d437a8d8f26fa364">gradient</a>(upwind_arg, time);</div>
<div class="line"><span class="lineno">  618</span>    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; LIBMESH_DIM; ++i)</div>
<div class="line"><span class="lineno">  619</span>    {</div>
<div class="line"><span class="lineno">  620</span>      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;component_upwind = phi_upwind(i), component_downwind = phi_downwind(i);</div>
<div class="line"><span class="lineno">  621</span>      <span class="keyword">const</span> VectorValue&lt;T&gt; grad = grad_phi_upwind.row(i);</div>
<div class="line"><span class="lineno">  622</span>      std::tie(coeff_upwind, coeff_downwind) = interpCoeffs(</div>
<div class="line"><span class="lineno">  623</span>          *limiter, component_upwind, component_downwind, &amp;grad, *face.<a class="code hl_variable" href="structMoose_1_1FaceArg.html#adbe9c167b0afacad24a0ca70959d0a43">fi</a>, face.<a class="code hl_variable" href="structMoose_1_1FaceArg.html#a792bf64c2222c6158ad37ee0921d34ca">elem_is_upwind</a>);</div>
<div class="line"><span class="lineno">  624</span>      ret(i) = coeff_upwind * component_upwind + coeff_downwind * component_downwind;</div>
<div class="line"><span class="lineno">  625</span>    }</div>
<div class="line"><span class="lineno">  626</span>  }</div>
<div class="line"><span class="lineno">  627</span> </div>
<div class="line"><span class="lineno">  628</span>  <span class="keywordflow">return</span> ret;</div>
<div class="line"><span class="lineno">  629</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab3061f2550ae0dee31012fdcb67453ae" name="ab3061f2550ae0dee31012fdcb67453ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3061f2550ae0dee31012fdcb67453ae">&#9670;&#160;</a></span>interpolate() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="classMoose_1_1FV_1_1Limiter.html">Limiter</a> , typename T , typename Tensor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VectorValue&lt; T &gt; Moose::FV::interpolate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMoose_1_1FV_1_1Limiter.html">Limiter</a> &amp;&#160;</td>
          <td class="paramname"><em>limiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TypeVector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi_upwind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TypeVector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>phi_downwind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tensor *const&#160;</td>
          <td class="paramname"><em>grad_phi_upwind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFaceInfo.html">FaceInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>fi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>fi_elem_is_upwind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector overload. </p>

<p class="definition">Definition at line <a class="el" href="MathFVUtils_8h_source.html#l00497">497</a> of file <a class="el" href="MathFVUtils_8h_source.html">MathFVUtils.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  503</span>{</div>
<div class="line"><span class="lineno">  504</span>  mooseAssert(limiter.<a class="code hl_function" href="classMoose_1_1FV_1_1Limiter.html#aba006a62f86fe81d25afd41723851733">constant</a>() || grad_phi_upwind,</div>
<div class="line"><span class="lineno">  505</span>              <span class="stringliteral">&quot;Non-null gradient only supported for constant limiters.&quot;</span>);</div>
<div class="line"><span class="lineno">  506</span> </div>
<div class="line"><span class="lineno">  507</span>  <span class="keyword">const</span> VectorValue&lt;T&gt; * <span class="keyword">const</span> gradient_example = <span class="keyword">nullptr</span>;</div>
<div class="line"><span class="lineno">  508</span>  VectorValue&lt;T&gt; ret;</div>
<div class="line"><span class="lineno">  509</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : make_range(<span class="keywordtype">unsigned</span>(LIBMESH_DIM)))</div>
<div class="line"><span class="lineno">  510</span>  {</div>
<div class="line"><span class="lineno">  511</span>    <span class="keywordflow">if</span> (grad_phi_upwind)</div>
<div class="line"><span class="lineno">  512</span>    {</div>
<div class="line"><span class="lineno">  513</span>      <span class="keyword">const</span> VectorValue&lt;T&gt; gradient = grad_phi_upwind-&gt;row(i);</div>
<div class="line"><span class="lineno">  514</span>      ret(i) =</div>
<div class="line"><span class="lineno">  515</span>          <a class="code hl_function" href="namespaceMoose_1_1FV.html#a181e9d146f7d17fcd56ff75f166efac6">interpolate</a>(limiter, phi_upwind(i), phi_downwind(i), &amp;gradient, fi, fi_elem_is_upwind);</div>
<div class="line"><span class="lineno">  516</span>    }</div>
<div class="line"><span class="lineno">  517</span>    <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  518</span>      ret(i) = interpolate(</div>
<div class="line"><span class="lineno">  519</span>          limiter, phi_upwind(i), phi_downwind(i), gradient_example, fi, fi_elem_is_upwind);</div>
<div class="line"><span class="lineno">  520</span>  }</div>
<div class="line"><span class="lineno">  521</span> </div>
<div class="line"><span class="lineno">  522</span>  <span class="keywordflow">return</span> ret;</div>
<div class="line"><span class="lineno">  523</span>}</div>
<div class="ttc" id="aclassMoose_1_1FV_1_1Limiter_html_aba006a62f86fe81d25afd41723851733"><div class="ttname"><a href="classMoose_1_1FV_1_1Limiter.html#aba006a62f86fe81d25afd41723851733">Moose::FV::Limiter::constant</a></div><div class="ttdeci">virtual bool constant() const =0</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a69c61f9527da5f52101404e2f2306a1d" name="a69c61f9527da5f52101404e2f2306a1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69c61f9527da5f52101404e2f2306a1d">&#9670;&#160;</a></span>interpolate() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename Vector , typename Enable  = typename std::enable_if&lt;ScalarTraits&lt;Scalar&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Scalar Moose::FV::interpolate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMoose_1_1FV_1_1Limiter.html">Limiter</a>&lt; Scalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>limiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>phi_upwind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>phi_downwind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector *const&#160;</td>
          <td class="paramname"><em>grad_phi_upwind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFaceInfo.html">FaceInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>fi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>fi_elem_is_upwind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolates with a limiter. </p>

<p class="definition">Definition at line <a class="el" href="MathFVUtils_8h_source.html#l00481">481</a> of file <a class="el" href="MathFVUtils_8h_source.html">MathFVUtils.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  487</span>{</div>
<div class="line"><span class="lineno">  488</span>  <span class="keyword">auto</span> pr = <a class="code hl_function" href="namespaceMoose_1_1FV.html#aa8e347c5804ee209112eea6eab0a466f">interpCoeffs</a>(limiter, phi_upwind, phi_downwind, grad_phi_upwind, fi, fi_elem_is_upwind);</div>
<div class="line"><span class="lineno">  489</span>  <span class="keywordflow">return</span> pr.first * phi_upwind + pr.second * phi_downwind;</div>
<div class="line"><span class="lineno">  490</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a181e9d146f7d17fcd56ff75f166efac6" name="a181e9d146f7d17fcd56ff75f166efac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a181e9d146f7d17fcd56ff75f166efac6">&#9670;&#160;</a></span>interpolate() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 , typename T3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Moose::FV::interpolate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceMoose_1_1FV.html#a5941595b238d0963e4fe80718ab7dd50">InterpMethod</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>value1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T3 &amp;&#160;</td>
          <td class="paramname"><em>value2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFaceInfo.html">FaceInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>fi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>one_is_elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides interpolation of face values for non-advection-specific purposes (although it can/will still be used by advective kernels sometimes). </p>
<p >The interpolated value is stored in result. This should be called when a face value needs to be computed from two neighboring cells/elements. value1 and value2 represent the cell property/values from which to compute the face value. The <code>one_is_elem</code> parameter indicates whether value1 corresponds to the <a class="el" href="classFaceInfo.html" title="This data structure is used to store geometric and variable related metadata about each cell face in ...">FaceInfo</a> elem value; else it corresponds to the <a class="el" href="classFaceInfo.html" title="This data structure is used to store geometric and variable related metadata about each cell face in ...">FaceInfo</a> neighbor value </p>

<p class="definition">Definition at line <a class="el" href="MathFVUtils_8h_source.html#l00272">272</a> of file <a class="el" href="MathFVUtils_8h_source.html">MathFVUtils.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  278</span>{</div>
<div class="line"><span class="lineno">  279</span>  <span class="keywordflow">switch</span> (m)</div>
<div class="line"><span class="lineno">  280</span>  {</div>
<div class="line"><span class="lineno">  281</span>    <span class="keywordflow">case</span> InterpMethod::Average:</div>
<div class="line"><span class="lineno">  282</span>    <span class="keywordflow">case</span> InterpMethod::SkewCorrectedAverage:</div>
<div class="line"><span class="lineno">  283</span>      result = <a class="code hl_function" href="namespaceMoose_1_1FV.html#a4d222a7b752432de3ee9ad82a150dd80">linearInterpolation</a>(value1, value2, fi, one_is_elem);</div>
<div class="line"><span class="lineno">  284</span>      <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  285</span>    <span class="keywordflow">case</span> InterpMethod::HarmonicAverage:</div>
<div class="line"><span class="lineno">  286</span>      result = <a class="code hl_function" href="namespaceMoose_1_1FV.html#a3c9021070513a8b6bb21753e7b662920">harmonicInterpolation</a>(value1, value2, fi, one_is_elem);</div>
<div class="line"><span class="lineno">  287</span>      <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  288</span>    <span class="keywordflow">default</span>:</div>
<div class="line"><span class="lineno">  289</span>      <a class="code hl_function" href="MooseError_8h.html#aa959168eed29caa7aaa85ffc1319a9ad">mooseError</a>(<span class="stringliteral">&quot;unsupported interpolation method for interpolate() function&quot;</span>);</div>
<div class="line"><span class="lineno">  290</span>  }</div>
<div class="line"><span class="lineno">  291</span>}</div>
<div class="ttc" id="anamespaceMoose_1_1FV_html_a3c9021070513a8b6bb21753e7b662920"><div class="ttname"><a href="namespaceMoose_1_1FV.html#a3c9021070513a8b6bb21753e7b662920">Moose::FV::harmonicInterpolation</a></div><div class="ttdeci">libMesh::CompareTypes&lt; T1, T2 &gt;::supertype harmonicInterpolation(const T1 &amp;value1, const T2 &amp;value2, const FaceInfo &amp;fi, const bool one_is_elem)</div><div class="ttdoc">Computes the harmonic mean (1/(gc/value1+(1-gc)/value2)) of Reals, RealVectorValues and RealTensorVal...</div><div class="ttdef"><b>Definition:</b> <a href="MathFVUtils_8h_source.html#l00167">MathFVUtils.h:167</a></div></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="FVOrthogonalDiffusion_8C_source.html#l00040">FVOrthogonalDiffusion::computeQpResidual()</a>, <a class="el" href="MooseVariableFV_8C_source.html#l00747">MooseVariableFV&lt; OutputType &gt;::evaluate()</a>, <a class="el" href="GreenGaussGradient_8h_source.html#l00260">greenGaussGradient()</a>, and <a class="el" href="MathFVUtils_8h_source.html#l00497">interpolate()</a>.</p>

</div>
</div>
<a id="a613ba6de4c72211b02597b42f285627d" name="a613ba6de4c72211b02597b42f285627d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a613ba6de4c72211b02597b42f285627d">&#9670;&#160;</a></span>interpolate() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 , typename T3 , typename Vector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Moose::FV::interpolate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceMoose_1_1FV.html#a5941595b238d0963e4fe80718ab7dd50">InterpMethod</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>value1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T3 &amp;&#160;</td>
          <td class="paramname"><em>value2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>advector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFaceInfo.html">FaceInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>fi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>one_is_elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Provides interpolation of face values for advective flux kernels. </p>
<p >This should be called by advective kernels when a face value is needed from two neighboring cells/elements. The interpolated value is stored in result. value1 and value2 represent the two neighboring advected cell property/values. advector represents the vector quantity at the face that is doing the advecting (e.g. the flow velocity at the face); this value often will have been computed using a call to the non-advective interpolate function. The <code>one_is_elem</code> parameter indicates whether value1 corresponds to the <a class="el" href="classFaceInfo.html" title="This data structure is used to store geometric and variable related metadata about each cell face in ...">FaceInfo</a> elem value; else it corresponds to the <a class="el" href="classFaceInfo.html" title="This data structure is used to store geometric and variable related metadata about each cell face in ...">FaceInfo</a> neighbor value </p>

<p class="definition">Definition at line <a class="el" href="MathFVUtils_8h_source.html#l00386">386</a> of file <a class="el" href="MathFVUtils_8h_source.html">MathFVUtils.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  393</span>{</div>
<div class="line"><span class="lineno">  394</span>  <span class="keyword">const</span> <span class="keyword">auto</span> coeffs = <a class="code hl_function" href="namespaceMoose_1_1FV.html#aa8e347c5804ee209112eea6eab0a466f">interpCoeffs</a>(m, fi, one_is_elem, advector);</div>
<div class="line"><span class="lineno">  395</span>  result = coeffs.first * value1 + coeffs.second * value2;</div>
<div class="line"><span class="lineno">  396</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac35dff353eeb171d7fc5adc7c93943f9" name="ac35dff353eeb171d7fc5adc7c93943f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac35dff353eeb171d7fc5adc7c93943f9">&#9670;&#160;</a></span>interpolate() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 , typename T3 , template&lt; typename &gt; class Vector1, template&lt; typename &gt; class Vector2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Moose::FV::interpolate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceMoose_1_1FV.html#a5941595b238d0963e4fe80718ab7dd50">InterpMethod</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector1&lt; T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>fi_elem_advected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>fi_neighbor_advected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector2&lt; T3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>fi_elem_advector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector2&lt; T3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>fi_neighbor_advector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFaceInfo.html">FaceInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>fi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the product of the advected and the advector based on the given interpolation method. </p>

<p class="definition">Definition at line <a class="el" href="MathFVUtils_8h_source.html#l00339">339</a> of file <a class="el" href="MathFVUtils_8h_source.html">MathFVUtils.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  346</span>{</div>
<div class="line"><span class="lineno">  347</span>  <span class="keywordflow">switch</span> (m)</div>
<div class="line"><span class="lineno">  348</span>  {</div>
<div class="line"><span class="lineno">  349</span>    <span class="keywordflow">case</span> InterpMethod::Average:</div>
<div class="line"><span class="lineno">  350</span>      result = <a class="code hl_function" href="namespaceMoose_1_1FV.html#a4d222a7b752432de3ee9ad82a150dd80">linearInterpolation</a>(fi_elem_advected * fi_elem_advector,</div>
<div class="line"><span class="lineno">  351</span>                                   fi_neighbor_advected * fi_neighbor_advector,</div>
<div class="line"><span class="lineno">  352</span>                                   fi,</div>
<div class="line"><span class="lineno">  353</span>                                   <span class="keyword">true</span>);</div>
<div class="line"><span class="lineno">  354</span>      <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  355</span>    <span class="keywordflow">case</span> InterpMethod::Upwind:</div>
<div class="line"><span class="lineno">  356</span>    {</div>
<div class="line"><span class="lineno">  357</span>      <span class="keyword">const</span> <span class="keyword">auto</span> face_advector = <a class="code hl_function" href="namespaceMoose_1_1FV.html#a4d222a7b752432de3ee9ad82a150dd80">linearInterpolation</a>(<a class="code hl_function" href="namespaceMetaPhysicL.html#a1c0a19c861d5f7813f7fb6825d8fe146">MetaPhysicL::raw_value</a>(fi_elem_advector),</div>
<div class="line"><span class="lineno">  358</span>                                                     <a class="code hl_function" href="namespaceMetaPhysicL.html#a1c0a19c861d5f7813f7fb6825d8fe146">MetaPhysicL::raw_value</a>(fi_neighbor_advector),</div>
<div class="line"><span class="lineno">  359</span>                                                     fi,</div>
<div class="line"><span class="lineno">  360</span>                                                     <span class="keyword">true</span>);</div>
<div class="line"><span class="lineno">  361</span>      Real elem_coeff, neighbor_coeff;</div>
<div class="line"><span class="lineno">  362</span>      <span class="keywordflow">if</span> (face_advector * fi.<a class="code hl_function" href="classFaceInfo.html#a207d78600df922cedd8b08421f87f655">normal</a>() &gt; 0)</div>
<div class="line"><span class="lineno">  363</span>        elem_coeff = 1, neighbor_coeff = 0;</div>
<div class="line"><span class="lineno">  364</span>      <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  365</span>        elem_coeff = 0, neighbor_coeff = 1;</div>
<div class="line"><span class="lineno">  366</span> </div>
<div class="line"><span class="lineno">  367</span>      result = elem_coeff * fi_elem_advected * fi_elem_advector +</div>
<div class="line"><span class="lineno">  368</span>               neighbor_coeff * fi_neighbor_advected * fi_neighbor_advector;</div>
<div class="line"><span class="lineno">  369</span>      <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  370</span>    }</div>
<div class="line"><span class="lineno">  371</span>    <span class="keywordflow">default</span>:</div>
<div class="line"><span class="lineno">  372</span>      <a class="code hl_function" href="MooseError_8h.html#aa959168eed29caa7aaa85ffc1319a9ad">mooseError</a>(<span class="stringliteral">&quot;unsupported interpolation method for FVFaceInterface::interpolate&quot;</span>);</div>
<div class="line"><span class="lineno">  373</span>  }</div>
<div class="line"><span class="lineno">  374</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a99cdbba7e56deab1236a2ed3efac3567" name="a99cdbba7e56deab1236a2ed3efac3567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99cdbba7e56deab1236a2ed3efac3567">&#9670;&#160;</a></span>interpolationMethods()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMooseEnum.html">MooseEnum</a> Moose::FV::interpolationMethods </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an enum with all the currently supported interpolation methods and the current default for <a class="el" href="namespaceMoose_1_1FV.html">FV</a>: first-order upwind. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classMooseEnum.html" title="This is a &quot;smart&quot; enum class intended to replace many of the shortcomings in the C++ enum type It sho...">MooseEnum</a> with all the face interpolation methods supported </dd></dl>

<p class="definition">Definition at line <a class="el" href="MathFVUtils_8C_source.html#l00061">61</a> of file <a class="el" href="MathFVUtils_8C_source.html">MathFVUtils.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   62</span>{</div>
<div class="line"><span class="lineno">   63</span>  <span class="keywordflow">return</span> <a class="code hl_class" href="classMooseEnum.html">MooseEnum</a>(<span class="stringliteral">&quot;average upwind sou min_mod vanLeer quick skewness-corrected&quot;</span>, <span class="stringliteral">&quot;upwind&quot;</span>);</div>
<div class="line"><span class="lineno">   64</span>}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="MathFVUtils_8C_source.html#l00067">advectedInterpolationParameter()</a>.</p>

</div>
</div>
<a id="a34d562f52c0ec819e7ffb51d54c8cf4d" name="a34d562f52c0ec819e7ffb51d54c8cf4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34d562f52c0ec819e7ffb51d54c8cf4d">&#9670;&#160;</a></span>limiterType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceMoose_1_1FV.html#a543ddcb0eef69b1aa6f7138b271c245c">LimiterType</a> Moose::FV::limiterType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceMoose_1_1FV.html#a5941595b238d0963e4fe80718ab7dd50">InterpMethod</a>&#160;</td>
          <td class="paramname"><em>interp_method</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the limiter type associated with the supplied interpolation method. </p>

<p class="definition">Definition at line <a class="el" href="Limiter_8C_source.html#l00059">59</a> of file <a class="el" href="Limiter_8C_source.html">Limiter.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   60</span>{</div>
<div class="line"><span class="lineno">   61</span>  <span class="keywordflow">switch</span> (interp_method)</div>
<div class="line"><span class="lineno">   62</span>  {</div>
<div class="line"><span class="lineno">   63</span>    <span class="keywordflow">case</span> InterpMethod::Average:</div>
<div class="line"><span class="lineno">   64</span>    <span class="keywordflow">case</span> InterpMethod::SkewCorrectedAverage:</div>
<div class="line"><span class="lineno">   65</span>      <span class="keywordflow">return</span> LimiterType::CentralDifference;</div>
<div class="line"><span class="lineno">   66</span> </div>
<div class="line"><span class="lineno">   67</span>    <span class="keywordflow">case</span> InterpMethod::Upwind:</div>
<div class="line"><span class="lineno">   68</span>      <span class="keywordflow">return</span> LimiterType::Upwind;</div>
<div class="line"><span class="lineno">   69</span> </div>
<div class="line"><span class="lineno">   70</span>    <span class="keywordflow">case</span> InterpMethod::VanLeer:</div>
<div class="line"><span class="lineno">   71</span>      <span class="keywordflow">return</span> LimiterType::VanLeer;</div>
<div class="line"><span class="lineno">   72</span> </div>
<div class="line"><span class="lineno">   73</span>    <span class="keywordflow">case</span> InterpMethod::MinMod:</div>
<div class="line"><span class="lineno">   74</span>      <span class="keywordflow">return</span> LimiterType::MinMod;</div>
<div class="line"><span class="lineno">   75</span> </div>
<div class="line"><span class="lineno">   76</span>    <span class="keywordflow">case</span> InterpMethod::SOU:</div>
<div class="line"><span class="lineno">   77</span>      <span class="keywordflow">return</span> LimiterType::SOU;</div>
<div class="line"><span class="lineno">   78</span> </div>
<div class="line"><span class="lineno">   79</span>    <span class="keywordflow">case</span> InterpMethod::QUICK:</div>
<div class="line"><span class="lineno">   80</span>      <span class="keywordflow">return</span> LimiterType::QUICK;</div>
<div class="line"><span class="lineno">   81</span> </div>
<div class="line"><span class="lineno">   82</span>    <span class="keywordflow">default</span>:</div>
<div class="line"><span class="lineno">   83</span>      <a class="code hl_function" href="MooseError_8h.html#aa959168eed29caa7aaa85ffc1319a9ad">mooseError</a>(<span class="stringliteral">&quot;Unrecognized interpolation method type.&quot;</span>);</div>
<div class="line"><span class="lineno">   84</span>  }</div>
<div class="line"><span class="lineno">   85</span>}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="FVAdvection_8C_source.html#l00043">FVAdvection::computeQpResidual()</a>, and <a class="el" href="FVDivergence_8C_source.html#l00031">FVDivergence::computeQpResidual()</a>.</p>

</div>
</div>
<a id="a3274441ca6ecde4e6ca4c5cf6108a2ac" name="a3274441ca6ecde4e6ca4c5cf6108a2ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3274441ca6ecde4e6ca4c5cf6108a2ac">&#9670;&#160;</a></span>linearInterpolation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Moose::FV::linearInterpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMoose_1_1FunctorBase.html">FunctorBase</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>functor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMoose_1_1FaceArg.html">FaceArg</a> &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMoose_1_1StateArg.html">StateArg</a> &amp;&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>perform a possibly skew-corrected linear interpolation by evaluating the supplied functor with the provided functor face argument </p>

<p class="definition">Definition at line <a class="el" href="MathFVUtils_8h_source.html#l00299">299</a> of file <a class="el" href="MathFVUtils_8h_source.html">MathFVUtils.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  300</span>{</div>
<div class="line"><span class="lineno">  301</span>  mooseAssert(face.<a class="code hl_variable" href="structMoose_1_1FaceArg.html#ac1c78c58d94868ff061cae2f1796544f">limiter_type</a> == LimiterType::CentralDifference,</div>
<div class="line"><span class="lineno">  302</span>              <span class="stringliteral">&quot;this interpolation method is meant for linear interpolations&quot;</span>);</div>
<div class="line"><span class="lineno">  303</span> </div>
<div class="line"><span class="lineno">  304</span>  mooseAssert(face.<a class="code hl_variable" href="structMoose_1_1FaceArg.html#adbe9c167b0afacad24a0ca70959d0a43">fi</a>,</div>
<div class="line"><span class="lineno">  305</span>              <span class="stringliteral">&quot;We must have a non-null face_info in order to prepare our ElemFromFace tuples&quot;</span>);</div>
<div class="line"><span class="lineno">  306</span> </div>
<div class="line"><span class="lineno">  307</span>  <span class="keyword">const</span> <span class="keyword">auto</span> elem_arg = face.<a class="code hl_function" href="structMoose_1_1FaceArg.html#a8c1e438f2efba06f4ba4436ff427034b">makeElem</a>();</div>
<div class="line"><span class="lineno">  308</span>  <span class="keyword">const</span> <span class="keyword">auto</span> neighbor_arg = face.<a class="code hl_function" href="structMoose_1_1FaceArg.html#a6b1b2bf253cb75ddb36a6ceca1f7b1f5">makeNeighbor</a>();</div>
<div class="line"><span class="lineno">  309</span> </div>
<div class="line"><span class="lineno">  310</span>  <span class="keywordflow">if</span> (face.<a class="code hl_variable" href="structMoose_1_1FaceArg.html#aa338322714c07b72adc20a6e06e05e6e">correct_skewness</a>)</div>
<div class="line"><span class="lineno">  311</span>  {</div>
<div class="line"><span class="lineno">  312</span>    <span class="comment">// This condition ensures that the recursive algorithm (face_center-&gt;</span></div>
<div class="line"><span class="lineno">  313</span>    <span class="comment">// face_gradient -&gt; cell_gradient -&gt; face_center -&gt; ...) terminates after</span></div>
<div class="line"><span class="lineno">  314</span>    <span class="comment">// one loop. It is hardcoded to one loop at this point since it yields</span></div>
<div class="line"><span class="lineno">  315</span>    <span class="comment">// 2nd order accuracy on skewed meshes with the minimum additional effort.</span></div>
<div class="line"><span class="lineno">  316</span>    <a class="code hl_struct" href="structMoose_1_1FaceArg.html">FaceArg</a> new_face(face);</div>
<div class="line"><span class="lineno">  317</span>    new_face.correct_skewness = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  318</span>    <span class="keyword">const</span> <span class="keyword">auto</span> surface_gradient = functor.<a class="code hl_function" href="classMoose_1_1FunctorBase.html#aa28f70bdf3145308d437a8d8f26fa364">gradient</a>(new_face, time);</div>
<div class="line"><span class="lineno">  319</span> </div>
<div class="line"><span class="lineno">  320</span>    <span class="keywordflow">return</span> <a class="code hl_function" href="namespaceMoose_1_1FV.html#a200d96276412a952b11a92c2e1f564e9">skewCorrectedLinearInterpolation</a>(</div>
<div class="line"><span class="lineno">  321</span>        functor(elem_arg, time), functor(neighbor_arg, time), surface_gradient, *face.<a class="code hl_variable" href="structMoose_1_1FaceArg.html#adbe9c167b0afacad24a0ca70959d0a43">fi</a>, <span class="keyword">true</span>);</div>
<div class="line"><span class="lineno">  322</span>  }</div>
<div class="line"><span class="lineno">  323</span>  <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  324</span>    <span class="keywordflow">return</span> linearInterpolation(</div>
<div class="line"><span class="lineno">  325</span>        functor(elem_arg, time), functor(neighbor_arg, time), *face.<a class="code hl_variable" href="structMoose_1_1FaceArg.html#adbe9c167b0afacad24a0ca70959d0a43">fi</a>, <span class="keyword">true</span>);</div>
<div class="line"><span class="lineno">  326</span>}</div>
<div class="ttc" id="anamespaceMoose_1_1FV_html_a200d96276412a952b11a92c2e1f564e9"><div class="ttname"><a href="namespaceMoose_1_1FV.html#a200d96276412a952b11a92c2e1f564e9">Moose::FV::skewCorrectedLinearInterpolation</a></div><div class="ttdeci">libMesh::CompareTypes&lt; T, T2 &gt;::supertype skewCorrectedLinearInterpolation(const T &amp;value1, const T2 &amp;value2, const T3 &amp;face_gradient, const FaceInfo &amp;fi, const bool one_is_elem)</div><div class="ttdoc">Linear interpolation with skewness correction using the face gradient.</div><div class="ttdef"><b>Definition:</b> <a href="MathFVUtils_8h_source.html#l00251">MathFVUtils.h:251</a></div></div>
<div class="ttc" id="astructMoose_1_1FaceArg_html_aa338322714c07b72adc20a6e06e05e6e"><div class="ttname"><a href="structMoose_1_1FaceArg.html#aa338322714c07b72adc20a6e06e05e6e">Moose::FaceArg::correct_skewness</a></div><div class="ttdeci">bool correct_skewness</div><div class="ttdoc">Whether to perform skew correction.</div><div class="ttdef"><b>Definition:</b> <a href="MooseFunctorArguments_8h_source.html#l00094">MooseFunctorArguments.h:94</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a4d222a7b752432de3ee9ad82a150dd80" name="a4d222a7b752432de3ee9ad82a150dd80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d222a7b752432de3ee9ad82a150dd80">&#9670;&#160;</a></span>linearInterpolation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">libMesh::CompareTypes&lt; T, T2 &gt;::supertype Moose::FV::linearInterpolation </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>value2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFaceInfo.html">FaceInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>fi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>one_is_elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMoose_1_1FV.html#a5941595b238d0963e4fe80718ab7dd50">InterpMethod</a>&#160;</td>
          <td class="paramname"><em>interp_method</em> = <code><a class="el" href="namespaceMoose_1_1FV.html#a5941595b238d0963e4fe80718ab7dd50ab1897515d548a960afe49ecf66a29021">InterpMethod::Average</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A simple linear interpolation of values between cell centers to a cell face. </p>
<p >The <code>one_is_elem</code> parameter indicates whether value1 corresponds to the <a class="el" href="classFaceInfo.html" title="This data structure is used to store geometric and variable related metadata about each cell face in ...">FaceInfo</a> elem value; else it corresponds to the <a class="el" href="classFaceInfo.html" title="This data structure is used to store geometric and variable related metadata about each cell face in ...">FaceInfo</a> neighbor value </p>

<p class="definition">Definition at line <a class="el" href="MathFVUtils_8h_source.html#l00140">140</a> of file <a class="el" href="MathFVUtils_8h_source.html">MathFVUtils.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  145</span>{</div>
<div class="line"><span class="lineno">  146</span>  mooseAssert(interp_method == InterpMethod::Average ||</div>
<div class="line"><span class="lineno">  147</span>                  interp_method == InterpMethod::SkewCorrectedAverage,</div>
<div class="line"><span class="lineno">  148</span>              <span class="stringliteral">&quot;The selected interpolation function only works with average or skewness-corrected &quot;</span></div>
<div class="line"><span class="lineno">  149</span>              <span class="stringliteral">&quot;average options!&quot;</span>);</div>
<div class="line"><span class="lineno">  150</span>  <span class="keyword">const</span> <span class="keyword">auto</span> coeffs = <a class="code hl_function" href="namespaceMoose_1_1FV.html#aa8e347c5804ee209112eea6eab0a466f">interpCoeffs</a>(interp_method, fi, one_is_elem);</div>
<div class="line"><span class="lineno">  151</span>  <span class="keywordflow">return</span> coeffs.first * value1 + coeffs.second * value2;</div>
<div class="line"><span class="lineno">  152</span>}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="MooseVariableFV_8C_source.html#l00722">MooseVariableFV&lt; Real &gt;::clearCaches()</a>, <a class="el" href="MathFVUtils_8h_source.html#l00272">interpolate()</a>, and <a class="el" href="MathFVUtils_8h_source.html#l00299">linearInterpolation()</a>.</p>

</div>
</div>
<a id="a4ac7ab327b328366cc7ebbbd739a874f" name="a4ac7ab327b328366cc7ebbbd739a874f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ac7ab327b328366cc7ebbbd739a874f">&#9670;&#160;</a></span>loopOverElemFaceInfo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ActionFunctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Moose::FV::loopOverElemFaceInfo </td>
          <td>(</td>
          <td class="paramtype">const Elem &amp;&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMooseMesh.html">MooseMesh</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ActionFunctor &amp;&#160;</td>
          <td class="paramname"><em>act</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMoose.html#aa11333273856693d4c2762d764789509">Moose::CoordinateSystemType</a>&#160;</td>
          <td class="paramname"><em>coord_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>rz_radial_coord</em> = <code>libMesh::invalid_uint</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="FVUtils_8h_source.html#l00039">39</a> of file <a class="el" href="FVUtils_8h_source.html">FVUtils.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   44</span>{</div>
<div class="line"><span class="lineno">   45</span>  mooseAssert(elem.active(), <span class="stringliteral">&quot;We should never call this method with an inactive element&quot;</span>);</div>
<div class="line"><span class="lineno">   46</span> </div>
<div class="line"><span class="lineno">   47</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> side : elem.side_index_range())</div>
<div class="line"><span class="lineno">   48</span>  {</div>
<div class="line"><span class="lineno">   49</span>    <span class="keyword">const</span> Elem * <span class="keyword">const</span> candidate_neighbor = elem.neighbor_ptr(side);</div>
<div class="line"><span class="lineno">   50</span> </div>
<div class="line"><span class="lineno">   51</span>    <span class="keywordtype">bool</span> elem_has_info = <a class="code hl_function" href="namespaceMoose_1_1FV.html#a31abd59f95d9b6db2c0306c2480af237">elemHasFaceInfo</a>(elem, candidate_neighbor);</div>
<div class="line"><span class="lineno">   52</span> </div>
<div class="line"><span class="lineno">   53</span>    std::set&lt;const Elem *&gt; neighbors;</div>
<div class="line"><span class="lineno">   54</span> </div>
<div class="line"><span class="lineno">   55</span>    <span class="keyword">const</span> <span class="keywordtype">bool</span> inactive_neighbor_detected =</div>
<div class="line"><span class="lineno">   56</span>        candidate_neighbor ? !candidate_neighbor-&gt;active() : <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">   57</span> </div>
<div class="line"><span class="lineno">   58</span>    <span class="comment">// See MooseMesh::buildFaceInfo for corresponding checks/additions of FaceInfo</span></div>
<div class="line"><span class="lineno">   59</span>    <span class="keywordflow">if</span> (inactive_neighbor_detected)</div>
<div class="line"><span class="lineno">   60</span>    {</div>
<div class="line"><span class="lineno">   61</span>      <span class="comment">// We must be next to an element that has been refined</span></div>
<div class="line"><span class="lineno">   62</span>      mooseAssert(candidate_neighbor-&gt;has_children(), <span class="stringliteral">&quot;We should have children&quot;</span>);</div>
<div class="line"><span class="lineno">   63</span> </div>
<div class="line"><span class="lineno">   64</span>      <span class="keyword">const</span> <span class="keyword">auto</span> candidate_neighbor_side = candidate_neighbor-&gt;which_neighbor_am_i(&amp;elem);</div>
<div class="line"><span class="lineno">   65</span> </div>
<div class="line"><span class="lineno">   66</span>      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> child_num : make_range(candidate_neighbor-&gt;n_children()))</div>
<div class="line"><span class="lineno">   67</span>        <span class="keywordflow">if</span> (candidate_neighbor-&gt;is_child_on_side(child_num, candidate_neighbor_side))</div>
<div class="line"><span class="lineno">   68</span>        {</div>
<div class="line"><span class="lineno">   69</span>          <span class="keyword">const</span> Elem * <span class="keyword">const</span> child = candidate_neighbor-&gt;child_ptr(child_num);</div>
<div class="line"><span class="lineno">   70</span>          mooseAssert(child-&gt;level() - elem.level() == 1, <span class="stringliteral">&quot;The math doesn&#39;t work out here.&quot;</span>);</div>
<div class="line"><span class="lineno">   71</span>          mooseAssert(child-&gt;has_neighbor(&amp;elem), <span class="stringliteral">&quot;Elem should be a neighbor of this child.&quot;</span>);</div>
<div class="line"><span class="lineno">   72</span>          mooseAssert(child-&gt;active(),</div>
<div class="line"><span class="lineno">   73</span>                      <span class="stringliteral">&quot;We shouldn&#39;t have greater than a face mismatch level of one&quot;</span>);</div>
<div class="line"><span class="lineno">   74</span>          neighbors.insert(child);</div>
<div class="line"><span class="lineno">   75</span>        }</div>
<div class="line"><span class="lineno">   76</span>    }</div>
<div class="line"><span class="lineno">   77</span>    <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">   78</span>      neighbors.insert(candidate_neighbor);</div>
<div class="line"><span class="lineno">   79</span> </div>
<div class="line"><span class="lineno">   80</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> Elem * <span class="keyword">const</span> neighbor : neighbors)</div>
<div class="line"><span class="lineno">   81</span>    {</div>
<div class="line"><span class="lineno">   82</span>      <span class="keyword">const</span> <a class="code hl_class" href="classFaceInfo.html">FaceInfo</a> * <span class="keyword">const</span> fi =</div>
<div class="line"><span class="lineno">   83</span>          elem_has_info ? mesh.<a class="code hl_function" href="classMooseMesh.html#a742892149c745fa78fb7007e278720e8">faceInfo</a>(&amp;elem, side)</div>
<div class="line"><span class="lineno">   84</span>                        : mesh.<a class="code hl_function" href="classMooseMesh.html#a742892149c745fa78fb7007e278720e8">faceInfo</a>(neighbor, neighbor-&gt;which_neighbor_am_i(&amp;elem));</div>
<div class="line"><span class="lineno">   85</span> </div>
<div class="line"><span class="lineno">   86</span>      mooseAssert(fi, <span class="stringliteral">&quot;We should have found a FaceInfo&quot;</span>);</div>
<div class="line"><span class="lineno">   87</span>      mooseAssert(elem_has_info ? &amp;elem == &amp;fi-&gt;<a class="code hl_function" href="classFaceInfo.html#a788618599b20801c4ffa18a6280c9eaa">elem</a>() : &amp;elem == fi-&gt;<a class="code hl_function" href="classFaceInfo.html#a7dd2001b1afc2d5c9069924ff6889990">neighborPtr</a>(),</div>
<div class="line"><span class="lineno">   88</span>                  <span class="stringliteral">&quot;Doesn&#39;t seem like we understand how this FaceInfo thing is working&quot;</span>);</div>
<div class="line"><span class="lineno">   89</span>      <span class="keywordflow">if</span> (neighbor)</div>
<div class="line"><span class="lineno">   90</span>      {</div>
<div class="line"><span class="lineno">   91</span>        mooseAssert(neighbor != libMesh::remote_elem,</div>
<div class="line"><span class="lineno">   92</span>                    <span class="stringliteral">&quot;Remote element detected. This indicates that you have insufficient geometric &quot;</span></div>
<div class="line"><span class="lineno">   93</span>                    <span class="stringliteral">&quot;ghosting. Please contact your application developers.&quot;</span>);</div>
<div class="line"><span class="lineno">   94</span>        mooseAssert(elem_has_info ? neighbor == fi-&gt;<a class="code hl_function" href="classFaceInfo.html#a7dd2001b1afc2d5c9069924ff6889990">neighborPtr</a>() : neighbor == &amp;fi-&gt;<a class="code hl_function" href="classFaceInfo.html#a788618599b20801c4ffa18a6280c9eaa">elem</a>(),</div>
<div class="line"><span class="lineno">   95</span>                    <span class="stringliteral">&quot;Doesn&#39;t seem like we understand how this FaceInfo thing is working&quot;</span>);</div>
<div class="line"><span class="lineno">   96</span>      }</div>
<div class="line"><span class="lineno">   97</span> </div>
<div class="line"><span class="lineno">   98</span>      <span class="keyword">const</span> Point elem_normal = elem_has_info ? fi-&gt;<a class="code hl_function" href="classFaceInfo.html#a207d78600df922cedd8b08421f87f655">normal</a>() : Point(-fi-&gt;<a class="code hl_function" href="classFaceInfo.html#a207d78600df922cedd8b08421f87f655">normal</a>());</div>
<div class="line"><span class="lineno">   99</span> </div>
<div class="line"><span class="lineno">  100</span>      Real coord;</div>
<div class="line"><span class="lineno">  101</span>      <a class="code hl_function" href="namespaceMooseMeshUtils.html#ac86ee3e4df0290ff749248d993eb354e">MooseMeshUtils::coordTransformFactor</a>(fi-&gt;<a class="code hl_function" href="classFaceInfo.html#af083ffba39d92e5b802fff5dd9bb5e14">faceCentroid</a>(), coord, coord_type, rz_radial_coord);</div>
<div class="line"><span class="lineno">  102</span> </div>
<div class="line"><span class="lineno">  103</span>      <span class="keyword">const</span> Point surface_vector = elem_normal * fi-&gt;<a class="code hl_function" href="classFaceInfo.html#a96e690fcace90c68527e5109b86369cd">faceArea</a>() * coord;</div>
<div class="line"><span class="lineno">  104</span> </div>
<div class="line"><span class="lineno">  105</span>      act(elem, neighbor, fi, surface_vector, coord, elem_has_info);</div>
<div class="line"><span class="lineno">  106</span>    }</div>
<div class="line"><span class="lineno">  107</span>  }</div>
<div class="line"><span class="lineno">  108</span>}</div>
<div class="ttc" id="aclassFaceInfo_html_a96e690fcace90c68527e5109b86369cd"><div class="ttname"><a href="classFaceInfo.html#a96e690fcace90c68527e5109b86369cd">FaceInfo::faceArea</a></div><div class="ttdeci">Real faceArea() const</div><div class="ttdoc">Returns the face area of face id.</div><div class="ttdef"><b>Definition:</b> <a href="FaceInfo_8h_source.html#l00059">FaceInfo.h:59</a></div></div>
<div class="ttc" id="aclassFaceInfo_html_af083ffba39d92e5b802fff5dd9bb5e14"><div class="ttname"><a href="classFaceInfo.html#af083ffba39d92e5b802fff5dd9bb5e14">FaceInfo::faceCentroid</a></div><div class="ttdeci">const Point &amp; faceCentroid() const</div><div class="ttdoc">Returns the coordinates of the face centroid.</div><div class="ttdef"><b>Definition:</b> <a href="FaceInfo_8h_source.html#l00070">FaceInfo.h:70</a></div></div>
<div class="ttc" id="aclassMooseMesh_html_a742892149c745fa78fb7007e278720e8"><div class="ttname"><a href="classMooseMesh.html#a742892149c745fa78fb7007e278720e8">MooseMesh::faceInfo</a></div><div class="ttdeci">const std::vector&lt; const FaceInfo * &gt; &amp; faceInfo() const</div><div class="ttdoc">Accessor for local FaceInfo objects.</div><div class="ttdef"><b>Definition:</b> <a href="MooseMesh_8h_source.html#l02072">MooseMesh.h:2072</a></div></div>
<div class="ttc" id="anamespaceMoose_1_1FV_html_a31abd59f95d9b6db2c0306c2480af237"><div class="ttname"><a href="namespaceMoose_1_1FV.html#a31abd59f95d9b6db2c0306c2480af237">Moose::FV::elemHasFaceInfo</a></div><div class="ttdeci">bool elemHasFaceInfo(const Elem &amp;elem, const Elem *const neighbor)</div><div class="ttdoc">This function infers based on elements if the faceinfo between them belongs to the element or not.</div><div class="ttdef"><b>Definition:</b> <a href="FVUtils_8C_source.html#l00020">FVUtils.C:20</a></div></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="GreenGaussGradient_8h_source.html#l00040">greenGaussGradient()</a>.</p>

</div>
</div>
<a id="a4b51d0f8c53c8cbde7a51ce35f034da4" name="a4b51d0f8c53c8cbde7a51ce35f034da4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b51d0f8c53c8cbde7a51ce35f034da4">&#9670;&#160;</a></span>onBoundary() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Moose::FV::onBoundary </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; <a class="el" href="AutomaticMortarGeneration_8h.html#afb1ef82fea6170b578d48ad9cd793486">SubdomainID</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>subs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFaceInfo.html">FaceInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>fi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine whether the passed-in face is on the boundary of an object that lives on the provided subdomains. </p>
<p >Note that if the subdomain set is empty we consider that to mean that the object has no block restriction and lives on the entire mesh </p>

<p class="definition">Definition at line <a class="el" href="MathFVUtils_8C_source.html#l00028">28</a> of file <a class="el" href="MathFVUtils_8C_source.html">MathFVUtils.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   29</span>{</div>
<div class="line"><span class="lineno">   30</span>  <span class="keywordflow">if</span> (!fi.<a class="code hl_function" href="classFaceInfo.html#a7dd2001b1afc2d5c9069924ff6889990">neighborPtr</a>())</div>
<div class="line"><span class="lineno">   31</span>    <span class="comment">// We&#39;re on the exterior boundary</span></div>
<div class="line"><span class="lineno">   32</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">   33</span> </div>
<div class="line"><span class="lineno">   34</span>  <span class="keywordflow">if</span> (subs.empty())</div>
<div class="line"><span class="lineno">   35</span>    <span class="comment">// The face is internal and our functor lives on all subdomains</span></div>
<div class="line"><span class="lineno">   36</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">   37</span> </div>
<div class="line"><span class="lineno">   38</span>  <span class="keyword">const</span> <span class="keyword">auto</span> sub_count =</div>
<div class="line"><span class="lineno">   39</span>      subs.count(fi.<a class="code hl_function" href="classFaceInfo.html#a788618599b20801c4ffa18a6280c9eaa">elem</a>().subdomain_id()) + subs.count(fi.<a class="code hl_function" href="classFaceInfo.html#af3f8e4b7bb146a7b842bc1ac9373fa25">neighbor</a>().subdomain_id());</div>
<div class="line"><span class="lineno">   40</span> </div>
<div class="line"><span class="lineno">   41</span>  <span class="keywordflow">switch</span> (sub_count)</div>
<div class="line"><span class="lineno">   42</span>  {</div>
<div class="line"><span class="lineno">   43</span>    <span class="keywordflow">case</span> 0:</div>
<div class="line"><span class="lineno">   44</span>      <a class="code hl_function" href="MooseError_8h.html#aa959168eed29caa7aaa85ffc1319a9ad">mooseError</a>(<span class="stringliteral">&quot;We should not be calling isExtrapolatedBoundaryFace on a functor that doesn&#39;t &quot;</span></div>
<div class="line"><span class="lineno">   45</span>                 <span class="stringliteral">&quot;live on either of the face information&#39;s neighboring elements&quot;</span>);</div>
<div class="line"><span class="lineno">   46</span> </div>
<div class="line"><span class="lineno">   47</span>    <span class="keywordflow">case</span> 1:</div>
<div class="line"><span class="lineno">   48</span>      <span class="comment">// We only live on one of the subs</span></div>
<div class="line"><span class="lineno">   49</span>      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">   50</span> </div>
<div class="line"><span class="lineno">   51</span>    <span class="keywordflow">case</span> 2:</div>
<div class="line"><span class="lineno">   52</span>      <span class="comment">// We live on both of the subs</span></div>
<div class="line"><span class="lineno">   53</span>      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">   54</span> </div>
<div class="line"><span class="lineno">   55</span>    <span class="keywordflow">default</span>:</div>
<div class="line"><span class="lineno">   56</span>      <a class="code hl_function" href="MooseError_8h.html#aa959168eed29caa7aaa85ffc1319a9ad">mooseError</a>(<span class="stringliteral">&quot;There should be no other sub_count options&quot;</span>);</div>
<div class="line"><span class="lineno">   57</span>  }</div>
<div class="line"><span class="lineno">   58</span>}</div>
<div class="ttc" id="aclassFaceInfo_html_af3f8e4b7bb146a7b842bc1ac9373fa25"><div class="ttname"><a href="classFaceInfo.html#af3f8e4b7bb146a7b842bc1ac9373fa25">FaceInfo::neighbor</a></div><div class="ttdeci">const Elem &amp; neighbor() const</div><div class="ttdef"><b>Definition:</b> <a href="FaceInfo_8h_source.html#l00205">FaceInfo.h:205</a></div></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="FVFluxKernel_8C_source.html#l00080">FVFluxKernel::onBoundary()</a>.</p>

</div>
</div>
<a id="abd8c3161f161cdaafa3cff4bdafd464e" name="abd8c3161f161cdaafa3cff4bdafd464e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd8c3161f161cdaafa3cff4bdafd464e">&#9670;&#160;</a></span>onBoundary() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SubdomainRestrictable &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Moose::FV::onBoundary </td>
          <td>(</td>
          <td class="paramtype">const SubdomainRestrictable &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFaceInfo.html">FaceInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>fi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return whether the supplied face is on a boundary of the <code>object's</code> execution. </p>

<p class="definition">Definition at line <a class="el" href="MathFVUtils_8h_source.html#l00705">705</a> of file <a class="el" href="MathFVUtils_8h_source.html">MathFVUtils.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  706</span>{</div>
<div class="line"><span class="lineno">  707</span>  <span class="keyword">const</span> <span class="keywordtype">bool</span> internal = fi.<a class="code hl_function" href="classFaceInfo.html#a7dd2001b1afc2d5c9069924ff6889990">neighborPtr</a>() &amp;&amp; obj.hasBlocks(fi.<a class="code hl_function" href="classFaceInfo.html#aa5849145fa23156c853dd07b63546451">elemSubdomainID</a>()) &amp;&amp;</div>
<div class="line"><span class="lineno">  708</span>                        obj.hasBlocks(fi.<a class="code hl_function" href="classFaceInfo.html#a0aa1e4426346825671649388c1575dc3">neighborSubdomainID</a>());</div>
<div class="line"><span class="lineno">  709</span>  <span class="keywordflow">return</span> !internal;</div>
<div class="line"><span class="lineno">  710</span>}</div>
<div class="ttc" id="aclassFaceInfo_html_a0aa1e4426346825671649388c1575dc3"><div class="ttname"><a href="classFaceInfo.html#a0aa1e4426346825671649388c1575dc3">FaceInfo::neighborSubdomainID</a></div><div class="ttdeci">SubdomainID neighborSubdomainID() const</div><div class="ttdef"><b>Definition:</b> <a href="FaceInfo_8h_source.html#l00242">FaceInfo.h:242</a></div></div>
<div class="ttc" id="aclassFaceInfo_html_aa5849145fa23156c853dd07b63546451"><div class="ttname"><a href="classFaceInfo.html#aa5849145fa23156c853dd07b63546451">FaceInfo::elemSubdomainID</a></div><div class="ttdeci">SubdomainID elemSubdomainID() const</div><div class="ttdef"><b>Definition:</b> <a href="FaceInfo_8h_source.html#l00099">FaceInfo.h:99</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a2ce769173061499d2c553818b2e643b8" name="a2ce769173061499d2c553818b2e643b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ce769173061499d2c553818b2e643b8">&#9670;&#160;</a></span>rF()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , typename Vector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Scalar Moose::FV::rF </td>
          <td>(</td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>phiC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>phiD</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector &amp;&#160;</td>
          <td class="paramname"><em>gradC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealVectorValue &amp;&#160;</td>
          <td class="paramname"><em>dCD</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>From Moukalled 12.30. </p>
<p >r_f = (phiC - phiU) / (phiD - phiC)</p>
<p >However, this formula is only clear on grids where upwind locations can be readily determined, which is not the case for unstructured meshes. So we leverage a virtual upwind location and Moukalled 12.65</p>
<p >phiD - phiU = 2 * grad(phi)_C * dCD -&gt; phiU = phiD - 2 * grad(phi)_C * dCD</p>
<p >Combining the two equations and performing some algebraic manipulation yields this equation for r_f:</p>
<p >r_f = 2 * grad(phi)_C * dCD / (phiD - phiC) - 1</p>
<p >This equation is clearly asymmetric considering the face between C and D because of the subscript on grad(phi). Hence this method can be thought of as constructing an r associated with the C side of the face </p>

<p class="definition">Definition at line <a class="el" href="MathFVUtils_8h_source.html#l00429">429</a> of file <a class="el" href="MathFVUtils_8h_source.html">MathFVUtils.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  430</span>{</div>
<div class="line"><span class="lineno">  431</span>  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">auto</span> zero_vec = RealVectorValue(0);</div>
<div class="line"><span class="lineno">  432</span>  <span class="keywordflow">if</span> ((phiD - phiC) == 0)</div>
<div class="line"><span class="lineno">  433</span>    <span class="comment">// Handle zero denominator case. Note that MathUtils::sign returns 1 for sign(0) so we can omit</span></div>
<div class="line"><span class="lineno">  434</span>    <span class="comment">// that operation here (e.g. sign(phiD - phiC) = sign(0) = 1). The second term preserves the</span></div>
<div class="line"><span class="lineno">  435</span>    <span class="comment">// same sparsity pattern as the else branch; we want to add this so that we don&#39;t risk PETSc</span></div>
<div class="line"><span class="lineno">  436</span>    <span class="comment">// shrinking the matrix now and then potentially reallocating nonzeros later (which is very</span></div>
<div class="line"><span class="lineno">  437</span>    <span class="comment">// slow)</span></div>
<div class="line"><span class="lineno">  438</span>    <span class="keywordflow">return</span> 1e6 * <a class="code hl_function" href="namespaceMathUtils.html#a53a9ea1c5518918a6de8689ccff698b0">MathUtils::sign</a>(gradC * dCD) + zero_vec * gradC;</div>
<div class="line"><span class="lineno">  439</span> </div>
<div class="line"><span class="lineno">  440</span>  <span class="keywordflow">return</span> 2. * gradC * dCD / (phiD - phiC) - 1.;</div>
<div class="line"><span class="lineno">  441</span>}</div>
<div class="ttc" id="anamespaceMathUtils_html_a53a9ea1c5518918a6de8689ccff698b0"><div class="ttname"><a href="namespaceMathUtils.html#a53a9ea1c5518918a6de8689ccff698b0">MathUtils::sign</a></div><div class="ttdeci">T sign(T x)</div><div class="ttdef"><b>Definition:</b> <a href="MathUtils_8h_source.html#l00083">MathUtils.h:83</a></div></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="MinModLimiter_8h_source.html#l00027">Moose::FV::MinModLimiter&lt; T &gt;::limit()</a>, <a class="el" href="QUICKLimiter_8h_source.html#l00027">Moose::FV::QUICKLimiter&lt; T &gt;::limit()</a>, <a class="el" href="SOULimiter_8h_source.html#l00027">Moose::FV::SOULimiter&lt; T &gt;::limit()</a>, and <a class="el" href="VanLeerLimiter_8h_source.html#l00027">Moose::FV::VanLeerLimiter&lt; T &gt;::limit()</a>.</p>

</div>
</div>
<a id="ae730f76e979904d97c348419a6a7a796" name="ae730f76e979904d97c348419a6a7a796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae730f76e979904d97c348419a6a7a796">&#9670;&#160;</a></span>selectInterpolationMethod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceMoose_1_1FV.html#a5941595b238d0963e4fe80718ab7dd50">InterpMethod</a> Moose::FV::selectInterpolationMethod </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>interp_method</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MathFVUtils_8C_source.html#l00080">80</a> of file <a class="el" href="MathFVUtils_8C_source.html">MathFVUtils.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   81</span>{</div>
<div class="line"><span class="lineno">   82</span>  <span class="keywordflow">if</span> (interp_method == <span class="stringliteral">&quot;average&quot;</span>)</div>
<div class="line"><span class="lineno">   83</span>    <span class="keywordflow">return</span> InterpMethod::Average;</div>
<div class="line"><span class="lineno">   84</span>  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (interp_method == <span class="stringliteral">&quot;harmonic&quot;</span>)</div>
<div class="line"><span class="lineno">   85</span>    <span class="keywordflow">return</span> InterpMethod::HarmonicAverage;</div>
<div class="line"><span class="lineno">   86</span>  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (interp_method == <span class="stringliteral">&quot;skewness-corrected&quot;</span>)</div>
<div class="line"><span class="lineno">   87</span>    <span class="keywordflow">return</span> InterpMethod::SkewCorrectedAverage;</div>
<div class="line"><span class="lineno">   88</span>  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (interp_method == <span class="stringliteral">&quot;upwind&quot;</span>)</div>
<div class="line"><span class="lineno">   89</span>    <span class="keywordflow">return</span> InterpMethod::Upwind;</div>
<div class="line"><span class="lineno">   90</span>  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (interp_method == <span class="stringliteral">&quot;rc&quot;</span>)</div>
<div class="line"><span class="lineno">   91</span>    <span class="keywordflow">return</span> InterpMethod::RhieChow;</div>
<div class="line"><span class="lineno">   92</span>  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (interp_method == <span class="stringliteral">&quot;vanLeer&quot;</span>)</div>
<div class="line"><span class="lineno">   93</span>    <span class="keywordflow">return</span> InterpMethod::VanLeer;</div>
<div class="line"><span class="lineno">   94</span>  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (interp_method == <span class="stringliteral">&quot;min_mod&quot;</span>)</div>
<div class="line"><span class="lineno">   95</span>    <span class="keywordflow">return</span> InterpMethod::MinMod;</div>
<div class="line"><span class="lineno">   96</span>  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (interp_method == <span class="stringliteral">&quot;sou&quot;</span>)</div>
<div class="line"><span class="lineno">   97</span>    <span class="keywordflow">return</span> InterpMethod::SOU;</div>
<div class="line"><span class="lineno">   98</span>  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (interp_method == <span class="stringliteral">&quot;quick&quot;</span>)</div>
<div class="line"><span class="lineno">   99</span>    <span class="keywordflow">return</span> InterpMethod::QUICK;</div>
<div class="line"><span class="lineno">  100</span>  <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  101</span>    <a class="code hl_function" href="MooseError_8h.html#aa959168eed29caa7aaa85ffc1319a9ad">mooseError</a>(<span class="stringliteral">&quot;Interpolation method &quot;</span>,</div>
<div class="line"><span class="lineno">  102</span>               interp_method,</div>
<div class="line"><span class="lineno">  103</span>               <span class="stringliteral">&quot; is not currently an option in Moose::FV::selectInterpolationMethod&quot;</span>);</div>
<div class="line"><span class="lineno">  104</span>}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="MathFVUtils_8C_source.html#l00107">setInterpolationMethod()</a>.</p>

</div>
</div>
<a id="a3a2fcf2007027e2518504e33619e663c" name="a3a2fcf2007027e2518504e33619e663c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a2fcf2007027e2518504e33619e663c">&#9670;&#160;</a></span>setInterpolationMethod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Moose::FV::setInterpolationMethod </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMooseObject.html">MooseObject</a> &amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceMoose_1_1FV.html#a5941595b238d0963e4fe80718ab7dd50">Moose::FV::InterpMethod</a> &amp;&#160;</td>
          <td class="paramname"><em>interp_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>param_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets one interpolation method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>The <code><a class="el" href="classMooseObject.html" title="Every object that can be built by the factory should be derived from this class.">MooseObject</a></code> with input parameters to query </td></tr>
    <tr><td class="paramname">interp_method</td><td>The interpolation method we will set </td></tr>
    <tr><td class="paramname">param_name</td><td>The name of the parameter setting this interpolation method </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the interpolation method has indicated that we will need more than the default level of ghosting </dd></dl>

<p class="definition">Definition at line <a class="el" href="MathFVUtils_8C_source.html#l00107">107</a> of file <a class="el" href="MathFVUtils_8C_source.html">MathFVUtils.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  110</span>{</div>
<div class="line"><span class="lineno">  111</span>  <span class="keywordtype">bool</span> need_more_ghosting = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  112</span> </div>
<div class="line"><span class="lineno">  113</span>  <span class="keyword">const</span> <span class="keyword">auto</span> &amp; interp_method_in = obj.<a class="code hl_function" href="classMooseBaseParameterInterface.html#ad0b9ef8440f1b3a22c050d8f735341b2">getParam</a>&lt;<a class="code hl_class" href="classMooseEnum.html">MooseEnum</a>&gt;(param_name);</div>
<div class="line"><span class="lineno">  114</span>  interp_method = <a class="code hl_function" href="namespaceMoose_1_1FV.html#ae730f76e979904d97c348419a6a7a796">selectInterpolationMethod</a>(interp_method_in);</div>
<div class="line"><span class="lineno">  115</span> </div>
<div class="line"><span class="lineno">  116</span>  <span class="keywordflow">if</span> (interp_method == InterpMethod::SOU || interp_method == InterpMethod::MinMod ||</div>
<div class="line"><span class="lineno">  117</span>      interp_method == InterpMethod::VanLeer || interp_method == InterpMethod::QUICK)</div>
<div class="line"><span class="lineno">  118</span>    need_more_ghosting = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  119</span> </div>
<div class="line"><span class="lineno">  120</span>  <span class="keywordflow">return</span> need_more_ghosting;</div>
<div class="line"><span class="lineno">  121</span>}</div>
<div class="ttc" id="aclassMooseBaseParameterInterface_html_ad0b9ef8440f1b3a22c050d8f735341b2"><div class="ttname"><a href="classMooseBaseParameterInterface.html#ad0b9ef8440f1b3a22c050d8f735341b2">MooseBaseParameterInterface::getParam</a></div><div class="ttdeci">const T &amp; getParam(const std::string &amp;name) const</div><div class="ttdoc">Retrieve a parameter for the object.</div><div class="ttdef"><b>Definition:</b> <a href="MooseBaseParameterInterface_8h_source.html#l00200">MooseBaseParameterInterface.h:200</a></div></div>
<div class="ttc" id="anamespaceMoose_1_1FV_html_ae730f76e979904d97c348419a6a7a796"><div class="ttname"><a href="namespaceMoose_1_1FV.html#ae730f76e979904d97c348419a6a7a796">Moose::FV::selectInterpolationMethod</a></div><div class="ttdeci">InterpMethod selectInterpolationMethod(const std::string &amp;interp_method)</div><div class="ttdef"><b>Definition:</b> <a href="MathFVUtils_8C_source.html#l00080">MathFVUtils.C:80</a></div></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="FVAdvection_8C_source.html#l00025">FVAdvection::FVAdvection()</a>.</p>

</div>
</div>
<a id="a200d96276412a952b11a92c2e1f564e9" name="a200d96276412a952b11a92c2e1f564e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a200d96276412a952b11a92c2e1f564e9">&#9670;&#160;</a></span>skewCorrectedLinearInterpolation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename T2 , typename T3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">libMesh::CompareTypes&lt; T, T2 &gt;::supertype Moose::FV::skewCorrectedLinearInterpolation </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T2 &amp;&#160;</td>
          <td class="paramname"><em>value2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T3 &amp;&#160;</td>
          <td class="paramname"><em>face_gradient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFaceInfo.html">FaceInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>fi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>one_is_elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Linear interpolation with skewness correction using the face gradient. </p>
<p >See more info in Moukalled Chapter 9. The correction involves a first order Taylor expansion around the intersection of the cell face and the line connecting the two cell centers. </p>

<p class="definition">Definition at line <a class="el" href="MathFVUtils_8h_source.html#l00251">251</a> of file <a class="el" href="MathFVUtils_8h_source.html">MathFVUtils.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  256</span>{</div>
<div class="line"><span class="lineno">  257</span>  <span class="keyword">const</span> <span class="keyword">auto</span> coeffs = <a class="code hl_function" href="namespaceMoose_1_1FV.html#aa8e347c5804ee209112eea6eab0a466f">interpCoeffs</a>(InterpMethod::SkewCorrectedAverage, fi, one_is_elem);</div>
<div class="line"><span class="lineno">  258</span> </div>
<div class="line"><span class="lineno">  259</span>  <span class="keyword">auto</span> value = (coeffs.first * value1 + coeffs.second * value2) +</div>
<div class="line"><span class="lineno">  260</span>               face_gradient * fi.<a class="code hl_function" href="classFaceInfo.html#a1fa6ca74a9627e2446e412136d6e2518">skewnessCorrectionVector</a>();</div>
<div class="line"><span class="lineno">  261</span>  <span class="keywordflow">return</span> value;</div>
<div class="line"><span class="lineno">  262</span>}</div>
<div class="ttc" id="aclassFaceInfo_html_a1fa6ca74a9627e2446e412136d6e2518"><div class="ttname"><a href="classFaceInfo.html#a1fa6ca74a9627e2446e412136d6e2518">FaceInfo::skewnessCorrectionVector</a></div><div class="ttdeci">Point skewnessCorrectionVector() const</div><div class="ttdoc">Returns the skewness-correction vector (vector between the approximate and real face centroids).</div><div class="ttdef"><b>Definition:</b> <a href="FaceInfo_8C_source.html#l00079">FaceInfo.C:79</a></div></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="MathFVUtils_8h_source.html#l00299">linearInterpolation()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a3893e598130913ace9d549861d9c4035" name="a3893e598130913ace9d549861d9c4035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3893e598130913ace9d549861d9c4035">&#9670;&#160;</a></span>moose_limiter_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMooseEnum.html">MooseEnum</a> Moose::FV::moose_limiter_type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Dec 24 2023 00:33:21 for Zapdos by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>

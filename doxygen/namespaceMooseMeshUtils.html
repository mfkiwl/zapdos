<!-- HTML header for doxygen 1.9.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Zapdos: MooseMeshUtils Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
    <a href="https://shannon-lab.github.io/zapdos" style="text-decoration:none"><div id="projectname">Zapdos</div></a><div id="projectname">
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">MooseMeshUtils Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a750aabd8258a955bd86d363f20a146f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMooseMeshUtils.html#a750aabd8258a955bd86d363f20a146f8">changeBoundaryId</a> (MeshBase &amp;mesh, const boundary_id_type old_id, const boundary_id_type new_id, bool delete_prev)</td></tr>
<tr class="separator:a750aabd8258a955bd86d363f20a146f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc6e7e0cbd4177f3c47ff018afb1e048"><td class="memItemLeft" align="right" valign="top">std::vector&lt; boundary_id_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMooseMeshUtils.html#adc6e7e0cbd4177f3c47ff018afb1e048">getBoundaryIDs</a> (const MeshBase &amp;mesh, const std::vector&lt; BoundaryName &gt; &amp;boundary_name, bool generate_unknown)</td></tr>
<tr class="separator:adc6e7e0cbd4177f3c47ff018afb1e048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a822ecae2630f4bdec433e1ac95115386"><td class="memItemLeft" align="right" valign="top">std::vector&lt; boundary_id_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMooseMeshUtils.html#a822ecae2630f4bdec433e1ac95115386">getBoundaryIDs</a> (const MeshBase &amp;mesh, const std::vector&lt; BoundaryName &gt; &amp;boundary_name, bool generate_unknown, const std::set&lt; <a class="el" href="AutomaticMortarGeneration_8h.html#acdf40e62836d2c708e17f9e204b0f877">BoundaryID</a> &gt; &amp;mesh_boundary_ids)</td></tr>
<tr class="separator:a822ecae2630f4bdec433e1ac95115386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9020fca2054f1e8c5367563be93e853f"><td class="memItemLeft" align="right" valign="top">std::set&lt; <a class="el" href="AutomaticMortarGeneration_8h.html#acdf40e62836d2c708e17f9e204b0f877">BoundaryID</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMooseMeshUtils.html#a9020fca2054f1e8c5367563be93e853f">getBoundaryIDSet</a> (const MeshBase &amp;mesh, const std::vector&lt; BoundaryName &gt; &amp;boundary_name, bool generate_unknown)</td></tr>
<tr class="separator:a9020fca2054f1e8c5367563be93e853f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da1a8fa52efacfec0fac9c350cb76f8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; subdomain_id_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMooseMeshUtils.html#a9da1a8fa52efacfec0fac9c350cb76f8">getSubdomainIDs</a> (const MeshBase &amp;mesh, const std::vector&lt; SubdomainName &gt; &amp;subdomain_name)</td></tr>
<tr class="separator:a9da1a8fa52efacfec0fac9c350cb76f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab494196fbfc861511c2875d70e90f364"><td class="memItemLeft" align="right" valign="top"><a class="el" href="AutomaticMortarGeneration_8h.html#acdf40e62836d2c708e17f9e204b0f877">BoundaryID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMooseMeshUtils.html#ab494196fbfc861511c2875d70e90f364">getBoundaryID</a> (const BoundaryName &amp;boundary_name, const MeshBase &amp;mesh)</td></tr>
<tr class="memdesc:ab494196fbfc861511c2875d70e90f364"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the boundary ID associated with the given BoundaryName.  <a href="namespaceMooseMeshUtils.html#ab494196fbfc861511c2875d70e90f364">More...</a><br /></td></tr>
<tr class="separator:ab494196fbfc861511c2875d70e90f364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4231d4834a0d55a379e69118f2e5c64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="AutomaticMortarGeneration_8h.html#afb1ef82fea6170b578d48ad9cd793486">SubdomainID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMooseMeshUtils.html#ae4231d4834a0d55a379e69118f2e5c64">getSubdomainID</a> (const SubdomainName &amp;subdomain_name, const MeshBase &amp;mesh)</td></tr>
<tr class="memdesc:ae4231d4834a0d55a379e69118f2e5c64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the subdomain ID associated with the given SubdomainName.  <a href="namespaceMooseMeshUtils.html#ae4231d4834a0d55a379e69118f2e5c64">More...</a><br /></td></tr>
<tr class="separator:ae4231d4834a0d55a379e69118f2e5c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772bf0932c1d16298d21aa6ddbc22659"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMooseMeshUtils.html#a772bf0932c1d16298d21aa6ddbc22659">changeSubdomainId</a> (MeshBase &amp;mesh, const subdomain_id_type old_id, const subdomain_id_type new_id)</td></tr>
<tr class="memdesc:a772bf0932c1d16298d21aa6ddbc22659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the old subdomain ID to a new ID in the mesh.  <a href="namespaceMooseMeshUtils.html#a772bf0932c1d16298d21aa6ddbc22659">More...</a><br /></td></tr>
<tr class="separator:a772bf0932c1d16298d21aa6ddbc22659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae492a0c56aef2fa920dd78fcd95e0c34"><td class="memItemLeft" align="right" valign="top">Point&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMooseMeshUtils.html#ae492a0c56aef2fa920dd78fcd95e0c34">meshCentroidCalculator</a> (const MeshBase &amp;mesh)</td></tr>
<tr class="memdesc:ae492a0c56aef2fa920dd78fcd95e0c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the centroid of a MeshBase.  <a href="namespaceMooseMeshUtils.html#ae492a0c56aef2fa920dd78fcd95e0c34">More...</a><br /></td></tr>
<tr class="separator:ae492a0c56aef2fa920dd78fcd95e0c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa652f9db98fc5c533a3da54814b0b85a"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; dof_id_type, dof_id_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMooseMeshUtils.html#aa652f9db98fc5c533a3da54814b0b85a">getExtraIDUniqueCombinationMap</a> (const MeshBase &amp;mesh, const std::set&lt; <a class="el" href="AutomaticMortarGeneration_8h.html#afb1ef82fea6170b578d48ad9cd793486">SubdomainID</a> &gt; &amp;block_ids, std::vector&lt; ExtraElementIDName &gt; extra_ids)</td></tr>
<tr class="memdesc:aa652f9db98fc5c533a3da54814b0b85a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Crate a new set of element-wise IDs by finding unique combinations of existing extra ID values.  <a href="namespaceMooseMeshUtils.html#aa652f9db98fc5c533a3da54814b0b85a">More...</a><br /></td></tr>
<tr class="separator:aa652f9db98fc5c533a3da54814b0b85a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ecd3cfc33c7333f9873e1598d89619e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMooseMeshUtils.html#a0ecd3cfc33c7333f9873e1598d89619e">isCoPlanar</a> (const std::vector&lt; Point &gt; vec_pts, const Point plane_nvec, const Point fixed_pt)</td></tr>
<tr class="memdesc:a0ecd3cfc33c7333f9873e1598d89619e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decides whether all the Points of a vector of Points are in a plane that is defined by a normal vector and an inplane Point.  <a href="namespaceMooseMeshUtils.html#a0ecd3cfc33c7333f9873e1598d89619e">More...</a><br /></td></tr>
<tr class="separator:a0ecd3cfc33c7333f9873e1598d89619e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f882e76448d8f233ff9521a79815a2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMooseMeshUtils.html#a54f882e76448d8f233ff9521a79815a2">isCoPlanar</a> (const std::vector&lt; Point &gt; vec_pts, const Point plane_nvec)</td></tr>
<tr class="memdesc:a54f882e76448d8f233ff9521a79815a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decides whether all the Points of a vector of Points are in a plane with a given normal vector.  <a href="namespaceMooseMeshUtils.html#a54f882e76448d8f233ff9521a79815a2">More...</a><br /></td></tr>
<tr class="separator:a54f882e76448d8f233ff9521a79815a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4ff1413857bed978d7c1028d748014"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMooseMeshUtils.html#aaa4ff1413857bed978d7c1028d748014">isCoPlanar</a> (const std::vector&lt; Point &gt; vec_pts)</td></tr>
<tr class="memdesc:aaa4ff1413857bed978d7c1028d748014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decides whether all the Points of a vector of Points are coplanar.  <a href="namespaceMooseMeshUtils.html#aaa4ff1413857bed978d7c1028d748014">More...</a><br /></td></tr>
<tr class="separator:aaa4ff1413857bed978d7c1028d748014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab44ba06540484b25a111f25d38979334"><td class="memItemLeft" align="right" valign="top"><a class="el" href="AutomaticMortarGeneration_8h.html#afb1ef82fea6170b578d48ad9cd793486">SubdomainID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMooseMeshUtils.html#ab44ba06540484b25a111f25d38979334">getNextFreeSubdomainID</a> (MeshBase &amp;input_mesh)</td></tr>
<tr class="memdesc:ab44ba06540484b25a111f25d38979334"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks input mesh and returns max(block ID) + 1, which represents a block ID that is not currently in use in the mesh.  <a href="namespaceMooseMeshUtils.html#ab44ba06540484b25a111f25d38979334">More...</a><br /></td></tr>
<tr class="separator:ab44ba06540484b25a111f25d38979334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e12ed6e796b504d768a68aa71de4996"><td class="memItemLeft" align="right" valign="top"><a class="el" href="AutomaticMortarGeneration_8h.html#acdf40e62836d2c708e17f9e204b0f877">BoundaryID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMooseMeshUtils.html#a8e12ed6e796b504d768a68aa71de4996">getNextFreeBoundaryID</a> (MeshBase &amp;input_mesh)</td></tr>
<tr class="memdesc:a8e12ed6e796b504d768a68aa71de4996"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks input mesh and returns the largest boundary ID in the mesh plus one, which is a boundary ID in the mesh that is not currently in use.  <a href="namespaceMooseMeshUtils.html#a8e12ed6e796b504d768a68aa71de4996">More...</a><br /></td></tr>
<tr class="separator:a8e12ed6e796b504d768a68aa71de4996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b5ee66b2a8eac65a3fb52abf4df5ce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMooseMeshUtils.html#ab6b5ee66b2a8eac65a3fb52abf4df5ce">hasSubdomainID</a> (MeshBase &amp;input_mesh, const <a class="el" href="AutomaticMortarGeneration_8h.html#afb1ef82fea6170b578d48ad9cd793486">SubdomainID</a> &amp;id)</td></tr>
<tr class="memdesc:ab6b5ee66b2a8eac65a3fb52abf4df5ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether a particular subdomain ID exists in the mesh.  <a href="namespaceMooseMeshUtils.html#ab6b5ee66b2a8eac65a3fb52abf4df5ce">More...</a><br /></td></tr>
<tr class="separator:ab6b5ee66b2a8eac65a3fb52abf4df5ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb5bf7080647764b0dc0340742cd51cb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMooseMeshUtils.html#aeb5bf7080647764b0dc0340742cd51cb">hasSubdomainName</a> (MeshBase &amp;input_mesh, const SubdomainName &amp;name)</td></tr>
<tr class="memdesc:aeb5bf7080647764b0dc0340742cd51cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether a particular subdomain name exists in the mesh.  <a href="namespaceMooseMeshUtils.html#aeb5bf7080647764b0dc0340742cd51cb">More...</a><br /></td></tr>
<tr class="separator:aeb5bf7080647764b0dc0340742cd51cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b589a0ebc9fde03d51d042b0cdedde"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMooseMeshUtils.html#a19b589a0ebc9fde03d51d042b0cdedde">hasBoundaryID</a> (MeshBase &amp;input_mesh, const <a class="el" href="AutomaticMortarGeneration_8h.html#acdf40e62836d2c708e17f9e204b0f877">BoundaryID</a> &amp;id)</td></tr>
<tr class="memdesc:a19b589a0ebc9fde03d51d042b0cdedde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether a particular boundary ID exists in the mesh.  <a href="namespaceMooseMeshUtils.html#a19b589a0ebc9fde03d51d042b0cdedde">More...</a><br /></td></tr>
<tr class="separator:a19b589a0ebc9fde03d51d042b0cdedde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c2f8b02fc4f8bffda053ed4b95ec90"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMooseMeshUtils.html#aa3c2f8b02fc4f8bffda053ed4b95ec90">hasBoundaryName</a> (MeshBase &amp;input_mesh, const BoundaryName &amp;name)</td></tr>
<tr class="memdesc:aa3c2f8b02fc4f8bffda053ed4b95ec90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether a particular boundary name exists in the mesh.  <a href="namespaceMooseMeshUtils.html#aa3c2f8b02fc4f8bffda053ed4b95ec90">More...</a><br /></td></tr>
<tr class="separator:aa3c2f8b02fc4f8bffda053ed4b95ec90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae808cb56f81c238b696752e2e3b8be5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMooseMeshUtils.html#ae808cb56f81c238b696752e2e3b8be5e">makeOrderedNodeList</a> (std::vector&lt; std::pair&lt; dof_id_type, dof_id_type &gt; &gt; &amp;node_assm, std::vector&lt; dof_id_type &gt; &amp;elem_id_list, std::vector&lt; dof_id_type &gt; &amp;ordered_node_list, std::vector&lt; dof_id_type &gt; &amp;ordered_elem_id_list)</td></tr>
<tr class="memdesc:ae808cb56f81c238b696752e2e3b8be5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a list of sides in the form of a vector of pairs of node ids into a list of ordered nodes based on connectivity.  <a href="namespaceMooseMeshUtils.html#ae808cb56f81c238b696752e2e3b8be5e">More...</a><br /></td></tr>
<tr class="separator:ae808cb56f81c238b696752e2e3b8be5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bb2fb50922a789a83c0ad2b5e4388b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMooseMeshUtils.html#a5bb2fb50922a789a83c0ad2b5e4388b0">changeBoundaryId</a> (MeshBase &amp;mesh, const libMesh::boundary_id_type old_id, const libMesh::boundary_id_type new_id, bool delete_prev)</td></tr>
<tr class="memdesc:a5bb2fb50922a789a83c0ad2b5e4388b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the old boundary ID to a new ID in the mesh.  <a href="namespaceMooseMeshUtils.html#a5bb2fb50922a789a83c0ad2b5e4388b0">More...</a><br /></td></tr>
<tr class="separator:a5bb2fb50922a789a83c0ad2b5e4388b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eddde4cec8c3b8e75fbe81a7eb63377"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="AutomaticMortarGeneration_8h.html#acdf40e62836d2c708e17f9e204b0f877">BoundaryID</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMooseMeshUtils.html#a6eddde4cec8c3b8e75fbe81a7eb63377">getBoundaryIDs</a> (const libMesh::MeshBase &amp;mesh, const std::vector&lt; BoundaryName &gt; &amp;boundary_name, bool generate_unknown, const std::set&lt; <a class="el" href="AutomaticMortarGeneration_8h.html#acdf40e62836d2c708e17f9e204b0f877">BoundaryID</a> &gt; &amp;mesh_boundary_ids)</td></tr>
<tr class="memdesc:a6eddde4cec8c3b8e75fbe81a7eb63377"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the boundary IDs with their names.  <a href="namespaceMooseMeshUtils.html#a6eddde4cec8c3b8e75fbe81a7eb63377">More...</a><br /></td></tr>
<tr class="separator:a6eddde4cec8c3b8e75fbe81a7eb63377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d9f2eb5fcb9208872d3a2a9fcf209c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="AutomaticMortarGeneration_8h.html#acdf40e62836d2c708e17f9e204b0f877">BoundaryID</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMooseMeshUtils.html#a28d9f2eb5fcb9208872d3a2a9fcf209c">getBoundaryIDs</a> (const libMesh::MeshBase &amp;mesh, const std::vector&lt; BoundaryName &gt; &amp;boundary_name, bool generate_unknown)</td></tr>
<tr class="memdesc:a28d9f2eb5fcb9208872d3a2a9fcf209c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the boundary IDs with their names.  <a href="namespaceMooseMeshUtils.html#a28d9f2eb5fcb9208872d3a2a9fcf209c">More...</a><br /></td></tr>
<tr class="separator:a28d9f2eb5fcb9208872d3a2a9fcf209c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f9a12af93c02110808bad51c2f9e09d"><td class="memItemLeft" align="right" valign="top">std::set&lt; <a class="el" href="AutomaticMortarGeneration_8h.html#acdf40e62836d2c708e17f9e204b0f877">BoundaryID</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMooseMeshUtils.html#a9f9a12af93c02110808bad51c2f9e09d">getBoundaryIDSet</a> (const libMesh::MeshBase &amp;mesh, const std::vector&lt; BoundaryName &gt; &amp;boundary_name, bool generate_unknown)</td></tr>
<tr class="memdesc:a9f9a12af93c02110808bad51c2f9e09d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the boundary IDs into a set with their names.  <a href="namespaceMooseMeshUtils.html#a9f9a12af93c02110808bad51c2f9e09d">More...</a><br /></td></tr>
<tr class="separator:a9f9a12af93c02110808bad51c2f9e09d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a661d22b0668c7c946119292b5e1b5166"><td class="memItemLeft" align="right" valign="top">std::vector&lt; subdomain_id_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMooseMeshUtils.html#a661d22b0668c7c946119292b5e1b5166">getSubdomainIDs</a> (const libMesh::MeshBase &amp;mesh, const std::vector&lt; SubdomainName &gt; &amp;subdomain_name)</td></tr>
<tr class="memdesc:a661d22b0668c7c946119292b5e1b5166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the associated subdomainIDs for the subdomain names that are passed in.  <a href="namespaceMooseMeshUtils.html#a661d22b0668c7c946119292b5e1b5166">More...</a><br /></td></tr>
<tr class="separator:a661d22b0668c7c946119292b5e1b5166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac86ee3e4df0290ff749248d993eb354e"><td class="memTemplParams" colspan="2">template&lt;typename P , typename C &gt; </td></tr>
<tr class="memitem:ac86ee3e4df0290ff749248d993eb354e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMooseMeshUtils.html#ac86ee3e4df0290ff749248d993eb354e">coordTransformFactor</a> (const P &amp;point, C &amp;factor, const <a class="el" href="namespaceMoose.html#aa11333273856693d4c2762d764789509">Moose::CoordinateSystemType</a> coord_type, const unsigned int rz_radial_coord=libMesh::invalid_uint)</td></tr>
<tr class="memdesc:ac86ee3e4df0290ff749248d993eb354e"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute a coordinate transformation factor  <a href="namespaceMooseMeshUtils.html#ac86ee3e4df0290ff749248d993eb354e">More...</a><br /></td></tr>
<tr class="separator:ac86ee3e4df0290ff749248d993eb354e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab32db7339cea61db3b08b1b5291e3257"><td class="memTemplParams" colspan="2">template&lt;typename P , typename C &gt; </td></tr>
<tr class="memitem:ab32db7339cea61db3b08b1b5291e3257"><td class="memTemplItemLeft" align="right" valign="top">C&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMooseMeshUtils.html#ab32db7339cea61db3b08b1b5291e3257">computeDistanceToAxis</a> (const P &amp;point, const Point &amp;origin, const RealVectorValue &amp;direction)</td></tr>
<tr class="memdesc:ab32db7339cea61db3b08b1b5291e3257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the distance to a general axis.  <a href="namespaceMooseMeshUtils.html#ab32db7339cea61db3b08b1b5291e3257">More...</a><br /></td></tr>
<tr class="separator:ab32db7339cea61db3b08b1b5291e3257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8361c388122a02684c43228a0f0218"><td class="memTemplParams" colspan="2">template&lt;typename P , typename C &gt; </td></tr>
<tr class="memitem:a2c8361c388122a02684c43228a0f0218"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMooseMeshUtils.html#a2c8361c388122a02684c43228a0f0218">coordTransformFactorRZGeneral</a> (const P &amp;point, const std::pair&lt; Point, RealVectorValue &gt; &amp;axis, C &amp;factor)</td></tr>
<tr class="memdesc:a2c8361c388122a02684c43228a0f0218"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a coordinate transformation factor for a general axisymmetric axis.  <a href="namespaceMooseMeshUtils.html#a2c8361c388122a02684c43228a0f0218">More...</a><br /></td></tr>
<tr class="separator:a2c8361c388122a02684c43228a0f0218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f996cfafd0768f3d71f0e43cf921fe9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMooseMeshUtils.html#a1f996cfafd0768f3d71f0e43cf921fe9">computeFaceInfoFaceCoord</a> (<a class="el" href="classFaceInfo.html">FaceInfo</a> &amp;fi, const <a class="el" href="namespaceMoose.html#aa11333273856693d4c2762d764789509">Moose::CoordinateSystemType</a> coord_type, const unsigned int rz_radial_coord=libMesh::invalid_uint)</td></tr>
<tr class="separator:a1f996cfafd0768f3d71f0e43cf921fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a750aabd8258a955bd86d363f20a146f8" name="a750aabd8258a955bd86d363f20a146f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a750aabd8258a955bd86d363f20a146f8">&#9670;&#160;</a></span>changeBoundaryId() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MooseMeshUtils::changeBoundaryId </td>
          <td>(</td>
          <td class="paramtype">MeshBase &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boundary_id_type&#160;</td>
          <td class="paramname"><em>old_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const boundary_id_type&#160;</td>
          <td class="paramname"><em>new_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>delete_prev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MooseMeshUtils_8C_source.html#l00026">26</a> of file <a class="el" href="MooseMeshUtils_8C_source.html">MooseMeshUtils.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   30</span>{</div>
<div class="line"><span class="lineno">   31</span>  <span class="comment">// Get a reference to our BoundaryInfo object, we will use it several times below...</span></div>
<div class="line"><span class="lineno">   32</span>  BoundaryInfo &amp; boundary_info = mesh.get_boundary_info();</div>
<div class="line"><span class="lineno">   33</span> </div>
<div class="line"><span class="lineno">   34</span>  <span class="comment">// Container to catch ids passed back from BoundaryInfo</span></div>
<div class="line"><span class="lineno">   35</span>  std::vector&lt;boundary_id_type&gt; old_ids;</div>
<div class="line"><span class="lineno">   36</span> </div>
<div class="line"><span class="lineno">   37</span>  <span class="comment">// Only level-0 elements store BCs.  Loop over them.</span></div>
<div class="line"><span class="lineno">   38</span>  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; elem : as_range(mesh.level_elements_begin(0), mesh.level_elements_end(0)))</div>
<div class="line"><span class="lineno">   39</span>  {</div>
<div class="line"><span class="lineno">   40</span>    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_sides = elem-&gt;n_sides();</div>
<div class="line"><span class="lineno">   41</span>    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> s = 0; s != n_sides; ++s)</div>
<div class="line"><span class="lineno">   42</span>    {</div>
<div class="line"><span class="lineno">   43</span>      boundary_info.boundary_ids(elem, s, old_ids);</div>
<div class="line"><span class="lineno">   44</span>      <span class="keywordflow">if</span> (std::find(old_ids.begin(), old_ids.end(), old_id) != old_ids.end())</div>
<div class="line"><span class="lineno">   45</span>      {</div>
<div class="line"><span class="lineno">   46</span>        std::vector&lt;boundary_id_type&gt; new_ids(old_ids);</div>
<div class="line"><span class="lineno">   47</span>        std::replace(new_ids.begin(), new_ids.end(), old_id, new_id);</div>
<div class="line"><span class="lineno">   48</span>        <span class="keywordflow">if</span> (delete_prev)</div>
<div class="line"><span class="lineno">   49</span>        {</div>
<div class="line"><span class="lineno">   50</span>          boundary_info.remove_side(elem, s);</div>
<div class="line"><span class="lineno">   51</span>          boundary_info.add_side(elem, s, new_ids);</div>
<div class="line"><span class="lineno">   52</span>        }</div>
<div class="line"><span class="lineno">   53</span>        <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">   54</span>          boundary_info.add_side(elem, s, new_ids);</div>
<div class="line"><span class="lineno">   55</span>      }</div>
<div class="line"><span class="lineno">   56</span>    }</div>
<div class="line"><span class="lineno">   57</span>  }</div>
<div class="line"><span class="lineno">   58</span> </div>
<div class="line"><span class="lineno">   59</span>  <span class="comment">// Remove any remaining references to the old ID from the</span></div>
<div class="line"><span class="lineno">   60</span>  <span class="comment">// BoundaryInfo object.  This prevents things like empty sidesets</span></div>
<div class="line"><span class="lineno">   61</span>  <span class="comment">// from showing up when printing information, etc.</span></div>
<div class="line"><span class="lineno">   62</span>  <span class="keywordflow">if</span> (delete_prev)</div>
<div class="line"><span class="lineno">   63</span>    boundary_info.remove_id(old_id);</div>
<div class="line"><span class="lineno">   64</span> </div>
<div class="line"><span class="lineno">   65</span>  <span class="comment">// global information may now be out of sync</span></div>
<div class="line"><span class="lineno">   66</span>  mesh.set_isnt_prepared();</div>
<div class="line"><span class="lineno">   67</span>}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="MeshExtruderGenerator_8C_source.html#l00118">MeshExtruderGenerator::changeID()</a>, and <a class="el" href="FillBetweenSidesetsGenerator_8C_source.html#l00107">FillBetweenSidesetsGenerator::generate()</a>.</p>

</div>
</div>
<a id="a5bb2fb50922a789a83c0ad2b5e4388b0" name="a5bb2fb50922a789a83c0ad2b5e4388b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bb2fb50922a789a83c0ad2b5e4388b0">&#9670;&#160;</a></span>changeBoundaryId() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MooseMeshUtils::changeBoundaryId </td>
          <td>(</td>
          <td class="paramtype">MeshBase &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const libMesh::boundary_id_type&#160;</td>
          <td class="paramname"><em>old_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const libMesh::boundary_id_type&#160;</td>
          <td class="paramname"><em>new_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>delete_prev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the old boundary ID to a new ID in the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>the mesh </td></tr>
    <tr><td class="paramname">old_id</td><td>the old boundary id </td></tr>
    <tr><td class="paramname">new_id</td><td>the new boundary id </td></tr>
    <tr><td class="paramname">delete_prev</td><td>whether to delete the previous boundary id from the mesh </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a772bf0932c1d16298d21aa6ddbc22659" name="a772bf0932c1d16298d21aa6ddbc22659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a772bf0932c1d16298d21aa6ddbc22659">&#9670;&#160;</a></span>changeSubdomainId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MooseMeshUtils::changeSubdomainId </td>
          <td>(</td>
          <td class="paramtype">MeshBase &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const subdomain_id_type&#160;</td>
          <td class="paramname"><em>old_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const subdomain_id_type&#160;</td>
          <td class="paramname"><em>new_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes the old subdomain ID to a new ID in the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>the mesh </td></tr>
    <tr><td class="paramname">old_id</td><td>the old subdomain id </td></tr>
    <tr><td class="paramname">new_id</td><td>the new subdomain id </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="MooseMeshUtils_8C_source.html#l00219">219</a> of file <a class="el" href="MooseMeshUtils_8C_source.html">MooseMeshUtils.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  220</span>{</div>
<div class="line"><span class="lineno">  221</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; elem : mesh.element_ptr_range())</div>
<div class="line"><span class="lineno">  222</span>    <span class="keywordflow">if</span> (elem-&gt;subdomain_id() == old_id)</div>
<div class="line"><span class="lineno">  223</span>      elem-&gt;subdomain_id() = new_id;</div>
<div class="line"><span class="lineno">  224</span> </div>
<div class="line"><span class="lineno">  225</span>  <span class="comment">// global cached information may now be out of sync</span></div>
<div class="line"><span class="lineno">  226</span>  mesh.set_isnt_prepared();</div>
<div class="line"><span class="lineno">  227</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab32db7339cea61db3b08b1b5291e3257" name="ab32db7339cea61db3b08b1b5291e3257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab32db7339cea61db3b08b1b5291e3257">&#9670;&#160;</a></span>computeDistanceToAxis()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">C MooseMeshUtils::computeDistanceToAxis </td>
          <td>(</td>
          <td class="paramtype">const P &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealVectorValue &amp;&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the distance to a general axis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>Point for which to compute distance from axis </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">origin</td><td>Axis starting point </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">direction</td><td>Axis direction </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="MooseMeshUtils_8h_source.html#l00164">164</a> of file <a class="el" href="MooseMeshUtils_8h_source.html">MooseMeshUtils.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  165</span>{</div>
<div class="line"><span class="lineno">  166</span>  <span class="keywordflow">return</span> (point - origin).cross(direction).norm();</div>
<div class="line"><span class="lineno">  167</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1f996cfafd0768f3d71f0e43cf921fe9" name="a1f996cfafd0768f3d71f0e43cf921fe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f996cfafd0768f3d71f0e43cf921fe9">&#9670;&#160;</a></span>computeFaceInfoFaceCoord()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MooseMeshUtils::computeFaceInfoFaceCoord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFaceInfo.html">FaceInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>fi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMoose.html#aa11333273856693d4c2762d764789509">Moose::CoordinateSystemType</a>&#160;</td>
          <td class="paramname"><em>coord_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>rz_radial_coord</em> = <code>libMesh::invalid_uint</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MooseMeshUtils_8h_source.html#l00187">187</a> of file <a class="el" href="MooseMeshUtils_8h_source.html">MooseMeshUtils.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  190</span>{</div>
<div class="line"><span class="lineno">  191</span>  <a class="code hl_function" href="Assembly_8C.html#ad7f3efa1d10ea6c8a49af46b686e68f5">coordTransformFactor</a>(fi.<a class="code hl_function" href="classFaceInfo.html#af083ffba39d92e5b802fff5dd9bb5e14">faceCentroid</a>(), fi.<a class="code hl_function" href="classFaceInfo.html#abcbd15e68ed39a94095369d193816244">faceCoord</a>(), coord_type, rz_radial_coord);</div>
<div class="line"><span class="lineno">  192</span>}</div>
<div class="ttc" id="aAssembly_8C_html_ad7f3efa1d10ea6c8a49af46b686e68f5"><div class="ttname"><a href="Assembly_8C.html#ad7f3efa1d10ea6c8a49af46b686e68f5">coordTransformFactor</a></div><div class="ttdeci">void coordTransformFactor(const SubProblem &amp;s, const SubdomainID sub_id, const P &amp;point, C &amp;factor, const SubdomainID neighbor_sub_id)</div><div class="ttdoc">Computes a conversion multiplier for use when computing integraals for the current coordinate system ...</div><div class="ttdef"><b>Definition:</b> <a href="Assembly_8C_source.html#l00039">Assembly.C:39</a></div></div>
<div class="ttc" id="aclassFaceInfo_html_abcbd15e68ed39a94095369d193816244"><div class="ttname"><a href="classFaceInfo.html#abcbd15e68ed39a94095369d193816244">FaceInfo::faceCoord</a></div><div class="ttdeci">Real &amp; faceCoord()</div><div class="ttdoc">Sets/gets the coordinate transformation factor (for e.g.</div><div class="ttdef"><b>Definition:</b> <a href="FaceInfo_8h_source.html#l00063">FaceInfo.h:63</a></div></div>
<div class="ttc" id="aclassFaceInfo_html_af083ffba39d92e5b802fff5dd9bb5e14"><div class="ttname"><a href="classFaceInfo.html#af083ffba39d92e5b802fff5dd9bb5e14">FaceInfo::faceCentroid</a></div><div class="ttdeci">const Point &amp; faceCentroid() const</div><div class="ttdoc">Returns the coordinates of the face centroid.</div><div class="ttdef"><b>Definition:</b> <a href="FaceInfo_8h_source.html#l00070">FaceInfo.h:70</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ac86ee3e4df0290ff749248d993eb354e" name="ac86ee3e4df0290ff749248d993eb354e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac86ee3e4df0290ff749248d993eb354e">&#9670;&#160;</a></span>coordTransformFactor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MooseMeshUtils::coordTransformFactor </td>
          <td>(</td>
          <td class="paramtype">const P &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMoose.html#aa11333273856693d4c2762d764789509">Moose::CoordinateSystemType</a>&#160;</td>
          <td class="paramname"><em>coord_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>rz_radial_coord</em> = <code>libMesh::invalid_uint</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute a coordinate transformation factor </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>The <a class="el" href="namespacelibMesh.html" title="The following methods are specializations for using the libMesh::Parallel::packed_range_* routines fo...">libMesh</a> <code>Point</code> in space where we are evaluating the factor </td></tr>
    <tr><td class="paramname">factor</td><td>The output of this function. Would be 1 for cartesian coordinate systems, 2*pi*r for cylindrical coordinate systems, and 4*pi*r^2 for spherical coordinate systems </td></tr>
    <tr><td class="paramname">coord_type</td><td>The coordinate system type, e.g. cartesian (COORD_XYZ), cylindrical (COORD_RZ), or spherical (COORD_RSPHERICAL) </td></tr>
    <tr><td class="paramname">rz_radial_coord</td><td>The index at which to index <code>point</code> for the radial coordinate when in a cylindrical coordinate system </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="MooseMeshUtils_8h_source.html#l00130">130</a> of file <a class="el" href="MooseMeshUtils_8h_source.html">MooseMeshUtils.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  134</span>{</div>
<div class="line"><span class="lineno">  135</span>  <span class="keywordflow">switch</span> (coord_type)</div>
<div class="line"><span class="lineno">  136</span>  {</div>
<div class="line"><span class="lineno">  137</span>    <span class="keywordflow">case</span> <a class="code hl_enumvalue" href="namespaceMoose.html#aa11333273856693d4c2762d764789509aebf91f32aa0ff31bf816e6f7f4ad5a93">Moose::COORD_XYZ</a>:</div>
<div class="line"><span class="lineno">  138</span>      factor = 1.0;</div>
<div class="line"><span class="lineno">  139</span>      <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  140</span>    <span class="keywordflow">case</span> <a class="code hl_enumvalue" href="namespaceMoose.html#aa11333273856693d4c2762d764789509a64fcffb37e2cc00c84e2cba948f12cfd">Moose::COORD_RZ</a>:</div>
<div class="line"><span class="lineno">  141</span>    {</div>
<div class="line"><span class="lineno">  142</span>      mooseAssert(rz_radial_coord != libMesh::invalid_uint,</div>
<div class="line"><span class="lineno">  143</span>                  <span class="stringliteral">&quot;Must pass in a valid rz radial coordinate&quot;</span>);</div>
<div class="line"><span class="lineno">  144</span>      factor = 2 * M_PI * point(rz_radial_coord);</div>
<div class="line"><span class="lineno">  145</span>      <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  146</span>    }</div>
<div class="line"><span class="lineno">  147</span>    <span class="keywordflow">case</span> <a class="code hl_enumvalue" href="namespaceMoose.html#aa11333273856693d4c2762d764789509adeb047c3d71bcc5b8d9bb45490dfc3cb">Moose::COORD_RSPHERICAL</a>:</div>
<div class="line"><span class="lineno">  148</span>      factor = 4 * M_PI * point(0) * point(0);</div>
<div class="line"><span class="lineno">  149</span>      <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  150</span>    <span class="keywordflow">default</span>:</div>
<div class="line"><span class="lineno">  151</span>      <a class="code hl_function" href="MooseError_8h.html#aa959168eed29caa7aaa85ffc1319a9ad">mooseError</a>(<span class="stringliteral">&quot;Unknown coordinate system&quot;</span>);</div>
<div class="line"><span class="lineno">  152</span>  }</div>
<div class="line"><span class="lineno">  153</span>}</div>
<div class="ttc" id="aMooseError_8h_html_aa959168eed29caa7aaa85ffc1319a9ad"><div class="ttname"><a href="MooseError_8h.html#aa959168eed29caa7aaa85ffc1319a9ad">mooseError</a></div><div class="ttdeci">void mooseError(Args &amp;&amp;... args)</div><div class="ttdoc">Emit an error message with the given stringified, concatenated args and terminate the application.</div><div class="ttdef"><b>Definition:</b> <a href="MooseError_8h_source.html#l00284">MooseError.h:284</a></div></div>
<div class="ttc" id="anamespaceMoose_html_aa11333273856693d4c2762d764789509a64fcffb37e2cc00c84e2cba948f12cfd"><div class="ttname"><a href="namespaceMoose.html#aa11333273856693d4c2762d764789509a64fcffb37e2cc00c84e2cba948f12cfd">Moose::COORD_RZ</a></div><div class="ttdeci">@ COORD_RZ</div><div class="ttdef"><b>Definition:</b> <a href="MooseTypes_8h_source.html#l00723">MooseTypes.h:723</a></div></div>
<div class="ttc" id="anamespaceMoose_html_aa11333273856693d4c2762d764789509adeb047c3d71bcc5b8d9bb45490dfc3cb"><div class="ttname"><a href="namespaceMoose.html#aa11333273856693d4c2762d764789509adeb047c3d71bcc5b8d9bb45490dfc3cb">Moose::COORD_RSPHERICAL</a></div><div class="ttdeci">@ COORD_RSPHERICAL</div><div class="ttdef"><b>Definition:</b> <a href="MooseTypes_8h_source.html#l00725">MooseTypes.h:724</a></div></div>
<div class="ttc" id="anamespaceMoose_html_aa11333273856693d4c2762d764789509aebf91f32aa0ff31bf816e6f7f4ad5a93"><div class="ttname"><a href="namespaceMoose.html#aa11333273856693d4c2762d764789509aebf91f32aa0ff31bf816e6f7f4ad5a93">Moose::COORD_XYZ</a></div><div class="ttdeci">@ COORD_XYZ</div><div class="ttdef"><b>Definition:</b> <a href="MooseTypes_8h_source.html#l00722">MooseTypes.h:722</a></div></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="MooseMeshUtils_8h_source.html#l00187">computeFaceInfoFaceCoord()</a>, <a class="el" href="Assembly_8C_source.html#l00050">coordTransformFactor()</a>, <a class="el" href="GreenGaussGradient_8h_source.html#l00040">Moose::FV::greenGaussGradient()</a>, and <a class="el" href="FVUtils_8h_source.html#l00039">Moose::FV::loopOverElemFaceInfo()</a>.</p>

</div>
</div>
<a id="a2c8361c388122a02684c43228a0f0218" name="a2c8361c388122a02684c43228a0f0218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c8361c388122a02684c43228a0f0218">&#9670;&#160;</a></span>coordTransformFactorRZGeneral()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P , typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MooseMeshUtils::coordTransformFactorRZGeneral </td>
          <td>(</td>
          <td class="paramtype">const P &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; Point, RealVectorValue &gt; &amp;&#160;</td>
          <td class="paramname"><em>axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a coordinate transformation factor for a general axisymmetric axis. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>The <a class="el" href="namespacelibMesh.html" title="The following methods are specializations for using the libMesh::Parallel::packed_range_* routines fo...">libMesh</a> <code>Point</code> in space where we are evaluating the factor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">axis</td><td>The pair of values defining the general axisymmetric axis. Respectively, the values are the axis starting point and direction. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">factor</td><td>The coordinate transformation factor </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="MooseMeshUtils_8h_source.html#l00179">179</a> of file <a class="el" href="MooseMeshUtils_8h_source.html">MooseMeshUtils.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  182</span>{</div>
<div class="line"><span class="lineno">  183</span>  factor = 2 * M_PI * computeDistanceToAxis&lt;P, C&gt;(point, axis.first, axis.second);</div>
<div class="line"><span class="lineno">  184</span>}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="Assembly_8C_source.html#l00050">coordTransformFactor()</a>.</p>

</div>
</div>
<a id="ab494196fbfc861511c2875d70e90f364" name="ab494196fbfc861511c2875d70e90f364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab494196fbfc861511c2875d70e90f364">&#9670;&#160;</a></span>getBoundaryID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AutomaticMortarGeneration_8h.html#acdf40e62836d2c708e17f9e204b0f877">BoundaryID</a> MooseMeshUtils::getBoundaryID </td>
          <td>(</td>
          <td class="paramtype">const BoundaryName &amp;&#160;</td>
          <td class="paramname"><em>boundary_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MeshBase &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the boundary ID associated with the given BoundaryName. </p>
<p >This is needed because the BoundaryName can be either an ID or a name. If it is a name, the mesh is queried for the ID associated with said name. </p>

<p class="definition">Definition at line <a class="el" href="MooseMeshUtils_8C_source.html#l00180">180</a> of file <a class="el" href="MooseMeshUtils_8C_source.html">MooseMeshUtils.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  181</span>{</div>
<div class="line"><span class="lineno">  182</span>  <a class="code hl_typedef" href="AutomaticMortarGeneration_8h.html#acdf40e62836d2c708e17f9e204b0f877">BoundaryID</a> <span class="keywordtype">id</span> = <a class="code hl_variable" href="namespaceMoose.html#aa6fe7d1799b6da4dfd3611a6263d6f06">Moose::INVALID_BOUNDARY_ID</a>;</div>
<div class="line"><span class="lineno">  183</span>  <span class="keywordflow">if</span> (boundary_name.empty())</div>
<div class="line"><span class="lineno">  184</span>    <span class="keywordflow">return</span> id;</div>
<div class="line"><span class="lineno">  185</span> </div>
<div class="line"><span class="lineno">  186</span>  <span class="keywordflow">if</span> (!<a class="code hl_function" href="namespaceMooseUtils.html#a38be3a13200c9c9b1dfdace5d66185a8">MooseUtils::isDigits</a>(boundary_name))</div>
<div class="line"><span class="lineno">  187</span>    <span class="keywordtype">id</span> = mesh.get_boundary_info().get_id_by_name(boundary_name);</div>
<div class="line"><span class="lineno">  188</span>  <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  189</span>  {</div>
<div class="line"><span class="lineno">  190</span>    std::istringstream ss(boundary_name);</div>
<div class="line"><span class="lineno">  191</span>    ss &gt;&gt; id;</div>
<div class="line"><span class="lineno">  192</span>  }</div>
<div class="line"><span class="lineno">  193</span> </div>
<div class="line"><span class="lineno">  194</span>  <span class="keywordflow">return</span> id;</div>
<div class="line"><span class="lineno">  195</span>}</div>
<div class="ttc" id="aAutomaticMortarGeneration_8h_html_acdf40e62836d2c708e17f9e204b0f877"><div class="ttname"><a href="AutomaticMortarGeneration_8h.html#acdf40e62836d2c708e17f9e204b0f877">BoundaryID</a></div><div class="ttdeci">boundary_id_type BoundaryID</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00049">AutomaticMortarGeneration.h:49</a></div></div>
<div class="ttc" id="anamespaceMooseUtils_html_a38be3a13200c9c9b1dfdace5d66185a8"><div class="ttname"><a href="namespaceMooseUtils.html#a38be3a13200c9c9b1dfdace5d66185a8">MooseUtils::isDigits</a></div><div class="ttdeci">bool isDigits(const std::string &amp;str)</div><div class="ttdoc">Courtesy https://stackoverflow.com/a/8889045 and https://en.cppreference.com/w/cpp/string/byte/isdigi...</div><div class="ttdef"><b>Definition:</b> <a href="MooseUtils_8h_source.html#l01196">MooseUtils.h:1196</a></div></div>
<div class="ttc" id="anamespaceMoose_html_aa6fe7d1799b6da4dfd3611a6263d6f06"><div class="ttname"><a href="namespaceMoose.html#aa6fe7d1799b6da4dfd3611a6263d6f06">Moose::INVALID_BOUNDARY_ID</a></div><div class="ttdeci">const BoundaryID INVALID_BOUNDARY_ID</div><div class="ttdef"><b>Definition:</b> <a href="MooseTypes_8C_source.html#l00024">MooseTypes.C:24</a></div></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="BoundaryDeletionGenerator_8C_source.html#l00040">BoundaryDeletionGenerator::generate()</a>, <a class="el" href="RenameBoundaryGenerator_8C_source.html#l00128">RenameBoundaryGenerator::generate()</a>, <a class="el" href="SideSetsFromBoundingBoxGenerator_8C_source.html#l00090">SideSetsFromBoundingBoxGenerator::generate()</a>, <a class="el" href="XYDelaunayGenerator_8C_source.html#l00116">XYDelaunayGenerator::generate()</a>, <a class="el" href="MooseMesh_8C_source.html#l01464">MooseMesh::getBoundaryID()</a>, and <a class="el" href="MooseMeshUtils_8C_source.html#l00433">hasBoundaryName()</a>.</p>

</div>
</div>
<a id="a28d9f2eb5fcb9208872d3a2a9fcf209c" name="a28d9f2eb5fcb9208872d3a2a9fcf209c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28d9f2eb5fcb9208872d3a2a9fcf209c">&#9670;&#160;</a></span>getBoundaryIDs() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="AutomaticMortarGeneration_8h.html#acdf40e62836d2c708e17f9e204b0f877">BoundaryID</a> &gt; MooseMeshUtils::getBoundaryIDs </td>
          <td>(</td>
          <td class="paramtype">const libMesh::MeshBase &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; BoundaryName &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>generate_unknown</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the boundary IDs with their names. </p>
<p >The ordering of the returned boundary ID vector matches the vector of the boundary names in <code>boundary_name</code>. When a boundary name is not available in the mesh, if <code>generate_unknown</code> is true a non-existant boundary ID will be returned, otherwise a BoundaryInfo::invalid_id will be returned. </p>

</div>
</div>
<a id="a6eddde4cec8c3b8e75fbe81a7eb63377" name="a6eddde4cec8c3b8e75fbe81a7eb63377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eddde4cec8c3b8e75fbe81a7eb63377">&#9670;&#160;</a></span>getBoundaryIDs() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="AutomaticMortarGeneration_8h.html#acdf40e62836d2c708e17f9e204b0f877">BoundaryID</a> &gt; MooseMeshUtils::getBoundaryIDs </td>
          <td>(</td>
          <td class="paramtype">const libMesh::MeshBase &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; BoundaryName &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>generate_unknown</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="AutomaticMortarGeneration_8h.html#acdf40e62836d2c708e17f9e204b0f877">BoundaryID</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh_boundary_ids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the boundary IDs with their names. </p>
<p >The ordering of the returned boundary ID vector matches the vector of the boundary names in <code>boundary_name</code>. When a boundary name is not available in the mesh, if <code>generate_unknown</code> is true a non-existant boundary ID will be returned, otherwise a BoundaryInfo::invalid_id will be returned. </p>

</div>
</div>
<a id="adc6e7e0cbd4177f3c47ff018afb1e048" name="adc6e7e0cbd4177f3c47ff018afb1e048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc6e7e0cbd4177f3c47ff018afb1e048">&#9670;&#160;</a></span>getBoundaryIDs() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; boundary_id_type &gt; MooseMeshUtils::getBoundaryIDs </td>
          <td>(</td>
          <td class="paramtype">const MeshBase &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; BoundaryName &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>generate_unknown</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MooseMeshUtils_8C_source.html#l00070">70</a> of file <a class="el" href="MooseMeshUtils_8C_source.html">MooseMeshUtils.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   73</span>{</div>
<div class="line"><span class="lineno">   74</span>  <span class="keywordflow">return</span> <a class="code hl_function" href="namespaceMooseMeshUtils.html#adc6e7e0cbd4177f3c47ff018afb1e048">getBoundaryIDs</a>(</div>
<div class="line"><span class="lineno">   75</span>      mesh, boundary_name, generate_unknown, mesh.get_boundary_info().get_boundary_ids());</div>
<div class="line"><span class="lineno">   76</span>}</div>
<div class="ttc" id="anamespaceMooseMeshUtils_html_adc6e7e0cbd4177f3c47ff018afb1e048"><div class="ttname"><a href="namespaceMooseMeshUtils.html#adc6e7e0cbd4177f3c47ff018afb1e048">MooseMeshUtils::getBoundaryIDs</a></div><div class="ttdeci">std::vector&lt; boundary_id_type &gt; getBoundaryIDs(const MeshBase &amp;mesh, const std::vector&lt; BoundaryName &gt; &amp;boundary_name, bool generate_unknown)</div><div class="ttdef"><b>Definition:</b> <a href="MooseMeshUtils_8C_source.html#l00070">MooseMeshUtils.C:70</a></div></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="BoundaryPreservedMarker_8C_source.html#l00031">BoundaryPreservedMarker::BoundaryPreservedMarker()</a>, <a class="el" href="MeshExtruderGenerator_8C_source.html#l00118">MeshExtruderGenerator::changeID()</a>, <a class="el" href="BoundingBoxNodeSetGenerator_8C_source.html#l00051">BoundingBoxNodeSetGenerator::generate()</a>, <a class="el" href="BreakBoundaryOnSubdomainGenerator_8C_source.html#l00042">BreakBoundaryOnSubdomainGenerator::generate()</a>, <a class="el" href="CircularBoundaryCorrectionGenerator_8C_source.html#l00085">CircularBoundaryCorrectionGenerator::generate()</a>, <a class="el" href="ElementDeletionGeneratorBase_8C_source.html#l00041">ElementDeletionGeneratorBase::generate()</a>, <a class="el" href="ExtraNodesetGenerator_8C_source.html#l00053">ExtraNodesetGenerator::generate()</a>, <a class="el" href="FillBetweenSidesetsGenerator_8C_source.html#l00107">FillBetweenSidesetsGenerator::generate()</a>, <a class="el" href="LowerDBlockFromSidesetGenerator_8C_source.html#l00065">LowerDBlockFromSidesetGenerator::generate()</a>, <a class="el" href="ParsedGenerateSideset_8C_source.html#l00143">ParsedGenerateSideset::generate()</a>, <a class="el" href="PatternedMeshGenerator_8C_source.html#l00074">PatternedMeshGenerator::generate()</a>, <a class="el" href="PolyLineMeshGenerator_8C_source.html#l00061">PolyLineMeshGenerator::generate()</a>, <a class="el" href="RefineSidesetGenerator_8C_source.html#l00058">RefineSidesetGenerator::generate()</a>, <a class="el" href="SideSetsAroundSubdomainGenerator_8C_source.html#l00070">SideSetsAroundSubdomainGenerator::generate()</a>, <a class="el" href="SideSetsBetweenSubdomainsGenerator_8C_source.html#l00050">SideSetsBetweenSubdomainsGenerator::generate()</a>, <a class="el" href="SideSetsFromBoundingBoxGenerator_8C_source.html#l00090">SideSetsFromBoundingBoxGenerator::generate()</a>, <a class="el" href="SideSetsFromNormalsGenerator_8C_source.html#l00072">SideSetsFromNormalsGenerator::generate()</a>, <a class="el" href="SideSetsFromPointsGenerator_8C_source.html#l00059">SideSetsFromPointsGenerator::generate()</a>, <a class="el" href="StackGenerator_8C_source.html#l00062">StackGenerator::generate()</a>, <a class="el" href="XYDelaunayGenerator_8C_source.html#l00116">XYDelaunayGenerator::generate()</a>, <a class="el" href="MooseMeshUtils_8C_source.html#l00070">getBoundaryIDs()</a>, <a class="el" href="MooseMesh_8C_source.html#l01495">MooseMesh::getBoundaryIDs()</a>, and <a class="el" href="MooseMeshUtils_8C_source.html#l00160">getBoundaryIDSet()</a>.</p>

</div>
</div>
<a id="a822ecae2630f4bdec433e1ac95115386" name="a822ecae2630f4bdec433e1ac95115386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a822ecae2630f4bdec433e1ac95115386">&#9670;&#160;</a></span>getBoundaryIDs() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; boundary_id_type &gt; MooseMeshUtils::getBoundaryIDs </td>
          <td>(</td>
          <td class="paramtype">const MeshBase &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; BoundaryName &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>generate_unknown</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="AutomaticMortarGeneration_8h.html#acdf40e62836d2c708e17f9e204b0f877">BoundaryID</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh_boundary_ids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >If the conversion from a name to a number fails, that means that this must be a named boundary. We will look in the complete map for this sideset and create a new name/ID pair if requested.</p>

<p class="definition">Definition at line <a class="el" href="MooseMeshUtils_8C_source.html#l00079">79</a> of file <a class="el" href="MooseMeshUtils_8C_source.html">MooseMeshUtils.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   83</span>{</div>
<div class="line"><span class="lineno">   84</span>  <span class="keyword">const</span> BoundaryInfo &amp; boundary_info = mesh.get_boundary_info();</div>
<div class="line"><span class="lineno">   85</span>  <span class="keyword">const</span> std::map&lt;BoundaryID, std::string&gt; &amp; sideset_map = boundary_info.get_sideset_name_map();</div>
<div class="line"><span class="lineno">   86</span>  <span class="keyword">const</span> std::map&lt;BoundaryID, std::string&gt; &amp; nodeset_map = boundary_info.get_nodeset_name_map();</div>
<div class="line"><span class="lineno">   87</span> </div>
<div class="line"><span class="lineno">   88</span>  <a class="code hl_typedef" href="AutomaticMortarGeneration_8h.html#acdf40e62836d2c708e17f9e204b0f877">BoundaryID</a> max_boundary_local_id = 0;</div>
<div class="line"><span class="lineno">   89</span>  <span class="comment">/* It is required to generate a new ID for a given name. It is used often in mesh modifiers such</span></div>
<div class="line"><span class="lineno">   90</span><span class="comment">   * as SideSetsBetweenSubdomains. Then we need to check the current boundary ids since they are</span></div>
<div class="line"><span class="lineno">   91</span><span class="comment">   * changing during &quot;mesh modify()&quot;, and figure out the right max boundary ID. Most of mesh</span></div>
<div class="line"><span class="lineno">   92</span><span class="comment">   * modifiers are running in serial, and we won&#39;t involve a global communication.</span></div>
<div class="line"><span class="lineno">   93</span><span class="comment">   */</span></div>
<div class="line"><span class="lineno">   94</span>  <span class="keywordflow">if</span> (generate_unknown)</div>
<div class="line"><span class="lineno">   95</span>  {</div>
<div class="line"><span class="lineno">   96</span>    <span class="keyword">const</span> <span class="keyword">auto</span> &amp; bids = mesh.is_prepared() ? mesh.get_boundary_info().get_global_boundary_ids()</div>
<div class="line"><span class="lineno">   97</span>                                           : mesh.get_boundary_info().get_boundary_ids();</div>
<div class="line"><span class="lineno">   98</span>    max_boundary_local_id = bids.empty() ? 0 : *(bids.rbegin());</div>
<div class="line"><span class="lineno">   99</span>    <span class="comment">/* We should not hit this often */</span></div>
<div class="line"><span class="lineno">  100</span>    <span class="keywordflow">if</span> (!mesh.is_prepared() &amp;&amp; !mesh.is_serial())</div>
<div class="line"><span class="lineno">  101</span>      mesh.comm().max(max_boundary_local_id);</div>
<div class="line"><span class="lineno">  102</span>  }</div>
<div class="line"><span class="lineno">  103</span> </div>
<div class="line"><span class="lineno">  104</span>  <a class="code hl_typedef" href="AutomaticMortarGeneration_8h.html#acdf40e62836d2c708e17f9e204b0f877">BoundaryID</a> max_boundary_id = mesh_boundary_ids.empty() ? 0 : *(mesh_boundary_ids.rbegin());</div>
<div class="line"><span class="lineno">  105</span> </div>
<div class="line"><span class="lineno">  106</span>  max_boundary_id =</div>
<div class="line"><span class="lineno">  107</span>      max_boundary_id &gt; max_boundary_local_id ? max_boundary_id : max_boundary_local_id;</div>
<div class="line"><span class="lineno">  108</span> </div>
<div class="line"><span class="lineno">  109</span>  std::vector&lt;BoundaryID&gt; ids(boundary_name.size());</div>
<div class="line"><span class="lineno">  110</span>  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; boundary_name.size(); i++)</div>
<div class="line"><span class="lineno">  111</span>  {</div>
<div class="line"><span class="lineno">  112</span>    <span class="keywordflow">if</span> (boundary_name[i] == <span class="stringliteral">&quot;ANY_BOUNDARY_ID&quot;</span>)</div>
<div class="line"><span class="lineno">  113</span>    {</div>
<div class="line"><span class="lineno">  114</span>      ids.assign(mesh_boundary_ids.begin(), mesh_boundary_ids.end());</div>
<div class="line"><span class="lineno">  115</span>      <span class="keywordflow">if</span> (i)</div>
<div class="line"><span class="lineno">  116</span>        <a class="code hl_function" href="MooseError_8h.html#a3d351254665674621ecbd38f57bb28ae">mooseWarning</a>(<span class="stringliteral">&quot;You passed \&quot;ANY_BOUNDARY_ID\&quot; in addition to other boundary_names.  This &quot;</span></div>
<div class="line"><span class="lineno">  117</span>                     <span class="stringliteral">&quot;may be a logic error.&quot;</span>);</div>
<div class="line"><span class="lineno">  118</span>      <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  119</span>    }</div>
<div class="line"><span class="lineno">  120</span> </div>
<div class="line"><span class="lineno">  121</span>    <span class="keywordflow">if</span> (boundary_name[i].empty() &amp;&amp; !generate_unknown)</div>
<div class="line"><span class="lineno">  122</span>      <a class="code hl_function" href="MooseError_8h.html#aa959168eed29caa7aaa85ffc1319a9ad">mooseError</a>(<span class="stringliteral">&quot;Incoming boundary name is empty and we are not generating unknown boundary IDs. &quot;</span></div>
<div class="line"><span class="lineno">  123</span>                 <span class="stringliteral">&quot;This is invalid.&quot;</span>);</div>
<div class="line"><span class="lineno">  124</span> </div>
<div class="line"><span class="lineno">  125</span>    <a class="code hl_typedef" href="AutomaticMortarGeneration_8h.html#acdf40e62836d2c708e17f9e204b0f877">BoundaryID</a> id;</div>
<div class="line"><span class="lineno">  126</span> </div>
<div class="line"><span class="lineno">  127</span>    <span class="keywordflow">if</span> (boundary_name[i].empty() || !<a class="code hl_function" href="namespaceMooseUtils.html#a38be3a13200c9c9b1dfdace5d66185a8">MooseUtils::isDigits</a>(boundary_name[i]))</div>
<div class="line"><span class="lineno">  128</span>    {</div>
<div class="line"><span class="lineno">  134</span>      <span class="keywordflow">if</span> (generate_unknown &amp;&amp;</div>
<div class="line"><span class="lineno">  135</span>          !<a class="code hl_function" href="namespaceMooseUtils.html#a08212e2657cdef3d61fe63db9e90412d">MooseUtils::doesMapContainValue</a>(sideset_map, std::string(boundary_name[i])) &amp;&amp;</div>
<div class="line"><span class="lineno">  136</span>          !<a class="code hl_function" href="namespaceMooseUtils.html#a08212e2657cdef3d61fe63db9e90412d">MooseUtils::doesMapContainValue</a>(nodeset_map, std::string(boundary_name[i])))</div>
<div class="line"><span class="lineno">  137</span>        <span class="keywordtype">id</span> = ++max_boundary_id;</div>
<div class="line"><span class="lineno">  138</span>      <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  139</span>        <span class="keywordtype">id</span> = boundary_info.get_id_by_name(boundary_name[i]);</div>
<div class="line"><span class="lineno">  140</span>    }</div>
<div class="line"><span class="lineno">  141</span>    <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  142</span>    {</div>
<div class="line"><span class="lineno">  143</span>      std::istringstream ss(boundary_name[i]);</div>
<div class="line"><span class="lineno">  144</span>      ss &gt;&gt; id;</div>
<div class="line"><span class="lineno">  145</span>      <span class="keywordflow">if</span> (ss.fail())</div>
<div class="line"><span class="lineno">  146</span>        <a class="code hl_function" href="MooseError_8h.html#aa959168eed29caa7aaa85ffc1319a9ad">mooseError</a>(<span class="stringliteral">&quot;Failed to convert integer &quot;</span>,</div>
<div class="line"><span class="lineno">  147</span>                   boundary_name[i],</div>
<div class="line"><span class="lineno">  148</span>                   <span class="stringliteral">&quot; to a boundary id.  Got &quot;</span>,</div>
<div class="line"><span class="lineno">  149</span>                   <span class="keywordtype">id</span>,</div>
<div class="line"><span class="lineno">  150</span>                   <span class="stringliteral">&quot; instead.  Is the integer too large for boundary_id_type?&quot;</span>);</div>
<div class="line"><span class="lineno">  151</span>    }</div>
<div class="line"><span class="lineno">  152</span> </div>
<div class="line"><span class="lineno">  153</span>    ids[i] = id;</div>
<div class="line"><span class="lineno">  154</span>  }</div>
<div class="line"><span class="lineno">  155</span> </div>
<div class="line"><span class="lineno">  156</span>  <span class="keywordflow">return</span> ids;</div>
<div class="line"><span class="lineno">  157</span>}</div>
<div class="ttc" id="aMooseError_8h_html_a3d351254665674621ecbd38f57bb28ae"><div class="ttname"><a href="MooseError_8h.html#a3d351254665674621ecbd38f57bb28ae">mooseWarning</a></div><div class="ttdeci">void mooseWarning(Args &amp;&amp;... args)</div><div class="ttdoc">Emit a warning message with the given stringified, concatenated args.</div><div class="ttdef"><b>Definition:</b> <a href="MooseError_8h_source.html#l00296">MooseError.h:296</a></div></div>
<div class="ttc" id="anamespaceMooseUtils_html_a08212e2657cdef3d61fe63db9e90412d"><div class="ttname"><a href="namespaceMooseUtils.html#a08212e2657cdef3d61fe63db9e90412d">MooseUtils::doesMapContainValue</a></div><div class="ttdeci">bool doesMapContainValue(const std::map&lt; T1, T2 &gt; &amp;the_map, const T2 &amp;value)</div><div class="ttdoc">This routine is a simple helper function for searching a map by values instead of keys.</div><div class="ttdef"><b>Definition:</b> <a href="MooseUtils_8h_source.html#l00314">MooseUtils.h:314</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a9f9a12af93c02110808bad51c2f9e09d" name="a9f9a12af93c02110808bad51c2f9e09d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f9a12af93c02110808bad51c2f9e09d">&#9670;&#160;</a></span>getBoundaryIDSet() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; <a class="el" href="AutomaticMortarGeneration_8h.html#acdf40e62836d2c708e17f9e204b0f877">BoundaryID</a> &gt; MooseMeshUtils::getBoundaryIDSet </td>
          <td>(</td>
          <td class="paramtype">const libMesh::MeshBase &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; BoundaryName &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>generate_unknown</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the boundary IDs into a set with their names. </p>
<p >Because <a class="el" href="namespacelibMesh.html" title="The following methods are specializations for using the libMesh::Parallel::packed_range_* routines fo...">libMesh</a> allows the same boundary to have multiple different boundary names, the size of the returned boundary ID set may be smaller than the size of the bounndary name vector. When a boundary name is not available in the mesh, if <code>generate_unknown</code> is true a non-existant boundary ID will be returned, otherwise a BoundaryInfo::invalid_id will be returned. </p>

</div>
</div>
<a id="a9020fca2054f1e8c5367563be93e853f" name="a9020fca2054f1e8c5367563be93e853f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9020fca2054f1e8c5367563be93e853f">&#9670;&#160;</a></span>getBoundaryIDSet() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt; <a class="el" href="AutomaticMortarGeneration_8h.html#acdf40e62836d2c708e17f9e204b0f877">BoundaryID</a> &gt; MooseMeshUtils::getBoundaryIDSet </td>
          <td>(</td>
          <td class="paramtype">const MeshBase &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; BoundaryName &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>generate_unknown</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MooseMeshUtils_8C_source.html#l00160">160</a> of file <a class="el" href="MooseMeshUtils_8C_source.html">MooseMeshUtils.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  163</span>{</div>
<div class="line"><span class="lineno">  164</span>  <span class="keyword">auto</span> boundaries = <a class="code hl_function" href="namespaceMooseMeshUtils.html#adc6e7e0cbd4177f3c47ff018afb1e048">getBoundaryIDs</a>(mesh, boundary_name, generate_unknown);</div>
<div class="line"><span class="lineno">  165</span>  <span class="keywordflow">return</span> std::set&lt;BoundaryID&gt;(boundaries.begin(), boundaries.end());</div>
<div class="line"><span class="lineno">  166</span>}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="DomainUserObject_8C_source.html#l00032">DomainUserObject::DomainUserObject()</a>.</p>

</div>
</div>
<a id="aa652f9db98fc5c533a3da54814b0b85a" name="aa652f9db98fc5c533a3da54814b0b85a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa652f9db98fc5c533a3da54814b0b85a">&#9670;&#160;</a></span>getExtraIDUniqueCombinationMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt; dof_id_type, dof_id_type &gt; MooseMeshUtils::getExtraIDUniqueCombinationMap </td>
          <td>(</td>
          <td class="paramtype">const MeshBase &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="AutomaticMortarGeneration_8h.html#afb1ef82fea6170b578d48ad9cd793486">SubdomainID</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>block_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; ExtraElementIDName &gt;&#160;</td>
          <td class="paramname"><em>extra_ids</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Crate a new set of element-wise IDs by finding unique combinations of existing extra ID values. </p>
<p >This function finds the unique combinations by recursively calling itself for extra ID inputs. In the recursive calling, the new unique combitnations is determined by combining the extra ID value of current level and the unique combination determined in the previous level in recursion. In the lowest level of recursion, the base combination is set by the unqiue ID values of the corresponding extra ID.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>input mesh </td></tr>
    <tr><td class="paramname">block_ids</td><td>block ids </td></tr>
    <tr><td class="paramname">extra_ids</td><td>extra ids </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>map of element id to new extra id </dd></dl>

<p class="definition">Definition at line <a class="el" href="MooseMeshUtils_8C_source.html#l00248">248</a> of file <a class="el" href="MooseMeshUtils_8C_source.html">MooseMeshUtils.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  251</span>{</div>
<div class="line"><span class="lineno">  252</span>  <span class="comment">// check block restriction</span></div>
<div class="line"><span class="lineno">  253</span>  <span class="keyword">const</span> <span class="keywordtype">bool</span> block_restricted = !block_ids.empty();</div>
<div class="line"><span class="lineno">  254</span>  <span class="comment">// get element id name of interest in recursive parsing algorithm</span></div>
<div class="line"><span class="lineno">  255</span>  ExtraElementIDName id_name = extra_ids.back();</div>
<div class="line"><span class="lineno">  256</span>  extra_ids.pop_back();</div>
<div class="line"><span class="lineno">  257</span>  <span class="keyword">const</span> <span class="keyword">auto</span> id_index = mesh.get_elem_integer_index(id_name);</div>
<div class="line"><span class="lineno">  258</span> </div>
<div class="line"><span class="lineno">  259</span>  <span class="comment">// create base parsed id set</span></div>
<div class="line"><span class="lineno">  260</span>  <span class="keywordflow">if</span> (extra_ids.empty())</div>
<div class="line"><span class="lineno">  261</span>  {</div>
<div class="line"><span class="lineno">  262</span>    <span class="comment">// get set of extra id values;</span></div>
<div class="line"><span class="lineno">  263</span>    std::vector&lt;dof_id_type&gt; ids;</div>
<div class="line"><span class="lineno">  264</span>    {</div>
<div class="line"><span class="lineno">  265</span>      std::set&lt;dof_id_type&gt; ids_set;</div>
<div class="line"><span class="lineno">  266</span>      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; elem : mesh.active_element_ptr_range())</div>
<div class="line"><span class="lineno">  267</span>      {</div>
<div class="line"><span class="lineno">  268</span>        <span class="keywordflow">if</span> (block_restricted &amp;&amp; block_ids.find(elem-&gt;subdomain_id()) == block_ids.end())</div>
<div class="line"><span class="lineno">  269</span>          <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno">  270</span>        <span class="keyword">const</span> <span class="keyword">auto</span> <span class="keywordtype">id</span> = elem-&gt;get_extra_integer(id_index);</div>
<div class="line"><span class="lineno">  271</span>        ids_set.insert(<span class="keywordtype">id</span>);</div>
<div class="line"><span class="lineno">  272</span>      }</div>
<div class="line"><span class="lineno">  273</span>      mesh.comm().set_union(ids_set);</div>
<div class="line"><span class="lineno">  274</span>      ids.assign(ids_set.begin(), ids_set.end());</div>
<div class="line"><span class="lineno">  275</span>    }</div>
<div class="line"><span class="lineno">  276</span> </div>
<div class="line"><span class="lineno">  277</span>    <span class="comment">// determine new extra id values;</span></div>
<div class="line"><span class="lineno">  278</span>    std::unordered_map&lt;dof_id_type, dof_id_type&gt; parsed_ids;</div>
<div class="line"><span class="lineno">  279</span>    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; elem : mesh.active_element_ptr_range())</div>
<div class="line"><span class="lineno">  280</span>    {</div>
<div class="line"><span class="lineno">  281</span>      <span class="keywordflow">if</span> (block_restricted &amp;&amp; block_ids.find(elem-&gt;subdomain_id()) == block_ids.end())</div>
<div class="line"><span class="lineno">  282</span>        <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno">  283</span>      parsed_ids[elem-&gt;id()] = std::distance(</div>
<div class="line"><span class="lineno">  284</span>          ids.begin(), std::lower_bound(ids.begin(), ids.end(), elem-&gt;get_extra_integer(id_index)));</div>
<div class="line"><span class="lineno">  285</span>    }</div>
<div class="line"><span class="lineno">  286</span>    <span class="keywordflow">return</span> parsed_ids;</div>
<div class="line"><span class="lineno">  287</span>  }</div>
<div class="line"><span class="lineno">  288</span> </div>
<div class="line"><span class="lineno">  289</span>  <span class="comment">// if extra_ids is not empty, recursively call getExtraIDUniqueCombinationMap</span></div>
<div class="line"><span class="lineno">  290</span>  <span class="keyword">const</span> <span class="keyword">auto</span> base_parsed_ids =</div>
<div class="line"><span class="lineno">  291</span>      <a class="code hl_function" href="namespaceMooseMeshUtils.html#aa652f9db98fc5c533a3da54814b0b85a">MooseMeshUtils::getExtraIDUniqueCombinationMap</a>(mesh, block_ids, extra_ids);</div>
<div class="line"><span class="lineno">  292</span>  <span class="comment">// parsing extra ids based on ref_parsed_ids</span></div>
<div class="line"><span class="lineno">  293</span>  std::vector&lt;std::pair&lt;dof_id_type, dof_id_type&gt;&gt; unique_ids;</div>
<div class="line"><span class="lineno">  294</span>  {</div>
<div class="line"><span class="lineno">  295</span>    std::set&lt;std::pair&lt;dof_id_type, dof_id_type&gt;&gt; unique_ids_set;</div>
<div class="line"><span class="lineno">  296</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; elem : mesh.active_element_ptr_range())</div>
<div class="line"><span class="lineno">  297</span>    {</div>
<div class="line"><span class="lineno">  298</span>      <span class="keywordflow">if</span> (block_restricted &amp;&amp; block_ids.find(elem-&gt;subdomain_id()) == block_ids.end())</div>
<div class="line"><span class="lineno">  299</span>        <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno">  300</span>      <span class="keyword">const</span> dof_id_type id1 = libmesh_map_find(base_parsed_ids, elem-&gt;id());</div>
<div class="line"><span class="lineno">  301</span>      <span class="keyword">const</span> dof_id_type id2 = elem-&gt;get_extra_integer(id_index);</div>
<div class="line"><span class="lineno">  302</span>      <span class="keyword">const</span> std::pair&lt;dof_id_type, dof_id_type&gt; ids = std::make_pair(id1, id2);</div>
<div class="line"><span class="lineno">  303</span>      unique_ids_set.insert(ids);</div>
<div class="line"><span class="lineno">  304</span>    }</div>
<div class="line"><span class="lineno">  305</span>    mesh.comm().set_union(unique_ids_set);</div>
<div class="line"><span class="lineno">  306</span>    unique_ids.assign(unique_ids_set.begin(), unique_ids_set.end());</div>
<div class="line"><span class="lineno">  307</span>  }</div>
<div class="line"><span class="lineno">  308</span> </div>
<div class="line"><span class="lineno">  309</span>  std::unordered_map&lt;dof_id_type, dof_id_type&gt; parsed_ids;</div>
<div class="line"><span class="lineno">  310</span> </div>
<div class="line"><span class="lineno">  311</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; elem : mesh.active_element_ptr_range())</div>
<div class="line"><span class="lineno">  312</span>  {</div>
<div class="line"><span class="lineno">  313</span>    <span class="keywordflow">if</span> (block_restricted &amp;&amp; block_ids.find(elem-&gt;subdomain_id()) == block_ids.end())</div>
<div class="line"><span class="lineno">  314</span>      <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno">  315</span>    <span class="keyword">const</span> dof_id_type id1 = libmesh_map_find(base_parsed_ids, elem-&gt;id());</div>
<div class="line"><span class="lineno">  316</span>    <span class="keyword">const</span> dof_id_type id2 = elem-&gt;get_extra_integer(id_index);</div>
<div class="line"><span class="lineno">  317</span>    <span class="keyword">const</span> dof_id_type new_id = std::distance(</div>
<div class="line"><span class="lineno">  318</span>        unique_ids.begin(),</div>
<div class="line"><span class="lineno">  319</span>        std::lower_bound(unique_ids.begin(), unique_ids.end(), std::make_pair(id1, id2)));</div>
<div class="line"><span class="lineno">  320</span>    parsed_ids[elem-&gt;id()] = new_id;</div>
<div class="line"><span class="lineno">  321</span>  }</div>
<div class="line"><span class="lineno">  322</span> </div>
<div class="line"><span class="lineno">  323</span>  <span class="keywordflow">return</span> parsed_ids;</div>
<div class="line"><span class="lineno">  324</span>}</div>
<div class="ttc" id="anamespaceMooseMeshUtils_html_aa652f9db98fc5c533a3da54814b0b85a"><div class="ttname"><a href="namespaceMooseMeshUtils.html#aa652f9db98fc5c533a3da54814b0b85a">MooseMeshUtils::getExtraIDUniqueCombinationMap</a></div><div class="ttdeci">std::unordered_map&lt; dof_id_type, dof_id_type &gt; getExtraIDUniqueCombinationMap(const MeshBase &amp;mesh, const std::set&lt; SubdomainID &gt; &amp;block_ids, std::vector&lt; ExtraElementIDName &gt; extra_ids)</div><div class="ttdoc">Crate a new set of element-wise IDs by finding unique combinations of existing extra ID values.</div><div class="ttdef"><b>Definition:</b> <a href="MooseMeshUtils_8C_source.html#l00248">MooseMeshUtils.C:248</a></div></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="ExtraIDIntegralVectorPostprocessor_8C_source.html#l00029">ExtraIDIntegralVectorPostprocessor::ExtraIDIntegralVectorPostprocessor()</a>, <a class="el" href="UniqueExtraIDMeshGenerator_8C_source.html#l00049">UniqueExtraIDMeshGenerator::generate()</a>, and <a class="el" href="MooseMeshUtils_8C_source.html#l00248">getExtraIDUniqueCombinationMap()</a>.</p>

</div>
</div>
<a id="a8e12ed6e796b504d768a68aa71de4996" name="a8e12ed6e796b504d768a68aa71de4996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e12ed6e796b504d768a68aa71de4996">&#9670;&#160;</a></span>getNextFreeBoundaryID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AutomaticMortarGeneration_8h.html#acdf40e62836d2c708e17f9e204b0f877">BoundaryID</a> MooseMeshUtils::getNextFreeBoundaryID </td>
          <td>(</td>
          <td class="paramtype">MeshBase &amp;&#160;</td>
          <td class="paramname"><em>input_mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks input mesh and returns the largest boundary ID in the mesh plus one, which is a boundary ID in the mesh that is not currently in use. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>mesh over which to compute the next free boundary ID </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="MooseMeshUtils_8C_source.html#l00389">389</a> of file <a class="el" href="MooseMeshUtils_8C_source.html">MooseMeshUtils.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  390</span>{</div>
<div class="line"><span class="lineno">  391</span>  <span class="keyword">auto</span> boundary_ids = input_mesh.get_boundary_info().get_boundary_ids();</div>
<div class="line"><span class="lineno">  392</span>  <span class="keywordflow">if</span> (boundary_ids.empty())</div>
<div class="line"><span class="lineno">  393</span>    <span class="keywordflow">return</span> 0;</div>
<div class="line"><span class="lineno">  394</span>  <span class="keywordflow">return</span> (*boundary_ids.rbegin() + 1);</div>
<div class="line"><span class="lineno">  395</span>}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="SideSetsFromBoundingBoxGenerator_8C_source.html#l00090">SideSetsFromBoundingBoxGenerator::generate()</a>, and <a class="el" href="XYMeshLineCutter_8C_source.html#l00104">XYMeshLineCutter::generate()</a>.</p>

</div>
</div>
<a id="ab44ba06540484b25a111f25d38979334" name="ab44ba06540484b25a111f25d38979334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab44ba06540484b25a111f25d38979334">&#9670;&#160;</a></span>getNextFreeSubdomainID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AutomaticMortarGeneration_8h.html#afb1ef82fea6170b578d48ad9cd793486">SubdomainID</a> MooseMeshUtils::getNextFreeSubdomainID </td>
          <td>(</td>
          <td class="paramtype">MeshBase &amp;&#160;</td>
          <td class="paramname"><em>input_mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks input mesh and returns max(block ID) + 1, which represents a block ID that is not currently in use in the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>mesh over which to compute the next free block id </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="MooseMeshUtils_8C_source.html#l00369">369</a> of file <a class="el" href="MooseMeshUtils_8C_source.html">MooseMeshUtils.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  370</span>{</div>
<div class="line"><span class="lineno">  371</span>  <span class="comment">// Call this to get most up to date block id information</span></div>
<div class="line"><span class="lineno">  372</span>  input_mesh.cache_elem_data();</div>
<div class="line"><span class="lineno">  373</span> </div>
<div class="line"><span class="lineno">  374</span>  std::set&lt;SubdomainID&gt; preexisting_subdomain_ids;</div>
<div class="line"><span class="lineno">  375</span>  input_mesh.subdomain_ids(preexisting_subdomain_ids);</div>
<div class="line"><span class="lineno">  376</span>  <span class="keywordflow">if</span> (preexisting_subdomain_ids.empty())</div>
<div class="line"><span class="lineno">  377</span>    <span class="keywordflow">return</span> 0;</div>
<div class="line"><span class="lineno">  378</span>  <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  379</span>  {</div>
<div class="line"><span class="lineno">  380</span>    <span class="keyword">const</span> <span class="keyword">auto</span> highest_subdomain_id =</div>
<div class="line"><span class="lineno">  381</span>        *std::max_element(preexisting_subdomain_ids.begin(), preexisting_subdomain_ids.end());</div>
<div class="line"><span class="lineno">  382</span>    mooseAssert(highest_subdomain_id &lt; std::numeric_limits&lt;SubdomainID&gt;::max(),</div>
<div class="line"><span class="lineno">  383</span>                <span class="stringliteral">&quot;A SubdomainID with max possible value was found&quot;</span>);</div>
<div class="line"><span class="lineno">  384</span>    <span class="keywordflow">return</span> highest_subdomain_id + 1;</div>
<div class="line"><span class="lineno">  385</span>  }</div>
<div class="line"><span class="lineno">  386</span>}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="LowerDBlockFromSidesetGenerator_8C_source.html#l00065">LowerDBlockFromSidesetGenerator::generate()</a>, <a class="el" href="XYDelaunayGenerator_8C_source.html#l00116">XYDelaunayGenerator::generate()</a>, and <a class="el" href="MeshRepairGenerator_8C_source.html#l00164">MeshRepairGenerator::separateSubdomainsByElementType()</a>.</p>

</div>
</div>
<a id="ae4231d4834a0d55a379e69118f2e5c64" name="ae4231d4834a0d55a379e69118f2e5c64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4231d4834a0d55a379e69118f2e5c64">&#9670;&#160;</a></span>getSubdomainID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="AutomaticMortarGeneration_8h.html#afb1ef82fea6170b578d48ad9cd793486">SubdomainID</a> MooseMeshUtils::getSubdomainID </td>
          <td>(</td>
          <td class="paramtype">const SubdomainName &amp;&#160;</td>
          <td class="paramname"><em>subdomain_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MeshBase &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the subdomain ID associated with the given SubdomainName. </p>
<p >This is needed because the SubdomainName can be either an ID or a name. If it is a name, the mesh is queried for the ID associated with said name. </p>

<p class="definition">Definition at line <a class="el" href="MooseMeshUtils_8C_source.html#l00198">198</a> of file <a class="el" href="MooseMeshUtils_8C_source.html">MooseMeshUtils.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  199</span>{</div>
<div class="line"><span class="lineno">  200</span>  <span class="keywordflow">if</span> (subdomain_name == <span class="stringliteral">&quot;ANY_BLOCK_ID&quot;</span>)</div>
<div class="line"><span class="lineno">  201</span>    <a class="code hl_function" href="MooseError_8h.html#aa959168eed29caa7aaa85ffc1319a9ad">mooseError</a>(<span class="stringliteral">&quot;getSubdomainID() does not work with \&quot;ANY_BLOCK_ID\&quot;&quot;</span>);</div>
<div class="line"><span class="lineno">  202</span> </div>
<div class="line"><span class="lineno">  203</span>  <a class="code hl_typedef" href="AutomaticMortarGeneration_8h.html#afb1ef82fea6170b578d48ad9cd793486">SubdomainID</a> <span class="keywordtype">id</span> = <a class="code hl_variable" href="namespaceMoose.html#aaf4d8910f17c1134498f8d15e2605482">Moose::INVALID_BLOCK_ID</a>;</div>
<div class="line"><span class="lineno">  204</span>  <span class="keywordflow">if</span> (subdomain_name.empty())</div>
<div class="line"><span class="lineno">  205</span>    <span class="keywordflow">return</span> id;</div>
<div class="line"><span class="lineno">  206</span> </div>
<div class="line"><span class="lineno">  207</span>  <span class="keywordflow">if</span> (!<a class="code hl_function" href="namespaceMooseUtils.html#a38be3a13200c9c9b1dfdace5d66185a8">MooseUtils::isDigits</a>(subdomain_name))</div>
<div class="line"><span class="lineno">  208</span>    <span class="keywordtype">id</span> = mesh.get_id_by_name(subdomain_name);</div>
<div class="line"><span class="lineno">  209</span>  <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  210</span>  {</div>
<div class="line"><span class="lineno">  211</span>    std::istringstream ss(subdomain_name);</div>
<div class="line"><span class="lineno">  212</span>    ss &gt;&gt; id;</div>
<div class="line"><span class="lineno">  213</span>  }</div>
<div class="line"><span class="lineno">  214</span> </div>
<div class="line"><span class="lineno">  215</span>  <span class="keywordflow">return</span> id;</div>
<div class="line"><span class="lineno">  216</span>}</div>
<div class="ttc" id="aAutomaticMortarGeneration_8h_html_afb1ef82fea6170b578d48ad9cd793486"><div class="ttname"><a href="AutomaticMortarGeneration_8h.html#afb1ef82fea6170b578d48ad9cd793486">SubdomainID</a></div><div class="ttdeci">subdomain_id_type SubdomainID</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00050">AutomaticMortarGeneration.h:50</a></div></div>
<div class="ttc" id="anamespaceMoose_html_aaf4d8910f17c1134498f8d15e2605482"><div class="ttname"><a href="namespaceMoose.html#aaf4d8910f17c1134498f8d15e2605482">Moose::INVALID_BLOCK_ID</a></div><div class="ttdeci">const SubdomainID INVALID_BLOCK_ID</div><div class="ttdef"><b>Definition:</b> <a href="MooseTypes_8C_source.html#l00022">MooseTypes.C:22</a></div></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="RenameBlockGenerator_8C_source.html#l00141">RenameBlockGenerator::generate()</a>, <a class="el" href="SubdomainBoundingBoxGenerator_8C_source.html#l00061">SubdomainBoundingBoxGenerator::generate()</a>, <a class="el" href="XYDelaunayGenerator_8C_source.html#l00116">XYDelaunayGenerator::generate()</a>, <a class="el" href="MooseMesh_8C_source.html#l01503">MooseMesh::getSubdomainID()</a>, <a class="el" href="MooseMeshUtils_8C_source.html#l00169">getSubdomainIDs()</a>, <a class="el" href="MooseMeshUtils_8C_source.html#l00412">hasSubdomainName()</a>, <a class="el" href="MooseMeshXYCuttingUtils_8C_source.html#l00702">MooseMeshXYCuttingUtils::quadToTriOnLine()</a>, and <a class="el" href="MooseMeshXYCuttingUtils_8C_source.html#l00304">MooseMeshXYCuttingUtils::quasiTriElementsFixer()</a>.</p>

</div>
</div>
<a id="a661d22b0668c7c946119292b5e1b5166" name="a661d22b0668c7c946119292b5e1b5166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a661d22b0668c7c946119292b5e1b5166">&#9670;&#160;</a></span>getSubdomainIDs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; subdomain_id_type &gt; MooseMeshUtils::getSubdomainIDs </td>
          <td>(</td>
          <td class="paramtype">const libMesh::MeshBase &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; SubdomainName &gt; &amp;&#160;</td>
          <td class="paramname"><em>subdomain_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the associated subdomainIDs for the subdomain names that are passed in. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The mesh </td></tr>
    <tr><td class="paramname">subdomain_name</td><td>The names of the subdomains </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The subdomain ids from the passed subdomain names. </dd></dl>

</div>
</div>
<a id="a9da1a8fa52efacfec0fac9c350cb76f8" name="a9da1a8fa52efacfec0fac9c350cb76f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9da1a8fa52efacfec0fac9c350cb76f8">&#9670;&#160;</a></span>getSubdomainIDs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; subdomain_id_type &gt; MooseMeshUtils::getSubdomainIDs </td>
          <td>(</td>
          <td class="paramtype">const MeshBase &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; SubdomainName &gt; &amp;&#160;</td>
          <td class="paramname"><em>subdomain_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="MooseMeshUtils_8C_source.html#l00169">169</a> of file <a class="el" href="MooseMeshUtils_8C_source.html">MooseMeshUtils.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  170</span>{</div>
<div class="line"><span class="lineno">  171</span>  std::vector&lt;SubdomainID&gt; ids(subdomain_name.size());</div>
<div class="line"><span class="lineno">  172</span> </div>
<div class="line"><span class="lineno">  173</span>  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; subdomain_name.size(); i++)</div>
<div class="line"><span class="lineno">  174</span>    ids[i] = <a class="code hl_function" href="namespaceMooseMeshUtils.html#ae4231d4834a0d55a379e69118f2e5c64">MooseMeshUtils::getSubdomainID</a>(subdomain_name[i], mesh);</div>
<div class="line"><span class="lineno">  175</span> </div>
<div class="line"><span class="lineno">  176</span>  <span class="keywordflow">return</span> ids;</div>
<div class="line"><span class="lineno">  177</span>}</div>
<div class="ttc" id="anamespaceMooseMeshUtils_html_ae4231d4834a0d55a379e69118f2e5c64"><div class="ttname"><a href="namespaceMooseMeshUtils.html#ae4231d4834a0d55a379e69118f2e5c64">MooseMeshUtils::getSubdomainID</a></div><div class="ttdeci">SubdomainID getSubdomainID(const SubdomainName &amp;subdomain_name, const MeshBase &amp;mesh)</div><div class="ttdoc">Gets the subdomain ID associated with the given SubdomainName.</div><div class="ttdef"><b>Definition:</b> <a href="MooseMeshUtils_8C_source.html#l00198">MooseMeshUtils.C:198</a></div></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="BlockDeletionGenerator_8C_source.html#l00043">BlockDeletionGenerator::generate()</a>, <a class="el" href="BlockToMeshConverterGenerator_8C_source.html#l00043">BlockToMeshConverterGenerator::generate()</a>, <a class="el" href="BreakMeshByBlockGenerator_8C_source.html#l00078">BreakMeshByBlockGenerator::generate()</a>, <a class="el" href="ParsedGenerateSideset_8C_source.html#l00143">ParsedGenerateSideset::generate()</a>, <a class="el" href="ParsedSubdomainMeshGenerator_8C_source.html#l00090">ParsedSubdomainMeshGenerator::generate()</a>, <a class="el" href="RefineBlockGenerator_8C_source.html#l00054">RefineBlockGenerator::generate()</a>, <a class="el" href="SideSetsAroundSubdomainGenerator_8C_source.html#l00070">SideSetsAroundSubdomainGenerator::generate()</a>, <a class="el" href="SideSetsBetweenSubdomainsGenerator_8C_source.html#l00050">SideSetsBetweenSubdomainsGenerator::generate()</a>, <a class="el" href="XYDelaunayGenerator_8C_source.html#l00116">XYDelaunayGenerator::generate()</a>, <a class="el" href="MooseMesh_8C_source.html#l01509">MooseMesh::getSubdomainIDs()</a>, <a class="el" href="BlockWeightedPartitioner_8C_source.html#l00055">BlockWeightedPartitioner::initialize()</a>, and <a class="el" href="LibmeshPartitioner_8C_source.html#l00141">LibmeshPartitioner::prepareBlocksForSubdomainPartitioner()</a>.</p>

</div>
</div>
<a id="a19b589a0ebc9fde03d51d042b0cdedde" name="a19b589a0ebc9fde03d51d042b0cdedde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19b589a0ebc9fde03d51d042b0cdedde">&#9670;&#160;</a></span>hasBoundaryID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MooseMeshUtils::hasBoundaryID </td>
          <td>(</td>
          <td class="paramtype">MeshBase &amp;&#160;</td>
          <td class="paramname"><em>input_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="AutomaticMortarGeneration_8h.html#acdf40e62836d2c708e17f9e204b0f877">BoundaryID</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether a particular boundary ID exists in the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>mesh over which to determine boundary IDs </td></tr>
    <tr><td class="paramname">boundary</td><td>ID </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="MooseMeshUtils_8C_source.html#l00419">419</a> of file <a class="el" href="MooseMeshUtils_8C_source.html">MooseMeshUtils.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  420</span>{</div>
<div class="line"><span class="lineno">  421</span>  <span class="keyword">const</span> BoundaryInfo &amp; boundary_info = input_mesh.get_boundary_info();</div>
<div class="line"><span class="lineno">  422</span>  std::set&lt;boundary_id_type&gt; boundary_ids = boundary_info.get_boundary_ids();</div>
<div class="line"><span class="lineno">  423</span> </div>
<div class="line"><span class="lineno">  424</span>  <span class="comment">// On a distributed mesh we may have boundary IDs that only exist on</span></div>
<div class="line"><span class="lineno">  425</span>  <span class="comment">// other processors</span></div>
<div class="line"><span class="lineno">  426</span>  <span class="keywordflow">if</span> (!input_mesh.is_replicated())</div>
<div class="line"><span class="lineno">  427</span>    input_mesh.comm().set_union(boundary_ids);</div>
<div class="line"><span class="lineno">  428</span> </div>
<div class="line"><span class="lineno">  429</span>  <span class="keywordflow">return</span> boundary_ids.count(<span class="keywordtype">id</span>) &amp;&amp; (<span class="keywordtype">id</span> != <a class="code hl_variable" href="namespaceMoose.html#aa6fe7d1799b6da4dfd3611a6263d6f06">Moose::INVALID_BOUNDARY_ID</a>);</div>
<div class="line"><span class="lineno">  430</span>}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="MooseMeshXYCuttingUtils_8C_source.html#l00971">MooseMeshXYCuttingUtils::boundaryTriElemImprover()</a>, and <a class="el" href="MooseMeshUtils_8C_source.html#l00433">hasBoundaryName()</a>.</p>

</div>
</div>
<a id="aa3c2f8b02fc4f8bffda053ed4b95ec90" name="aa3c2f8b02fc4f8bffda053ed4b95ec90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3c2f8b02fc4f8bffda053ed4b95ec90">&#9670;&#160;</a></span>hasBoundaryName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MooseMeshUtils::hasBoundaryName </td>
          <td>(</td>
          <td class="paramtype">MeshBase &amp;&#160;</td>
          <td class="paramname"><em>input_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BoundaryName &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether a particular boundary name exists in the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>mesh over which to determine boundary names </td></tr>
    <tr><td class="paramname">boundary</td><td>name </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="MooseMeshUtils_8C_source.html#l00433">433</a> of file <a class="el" href="MooseMeshUtils_8C_source.html">MooseMeshUtils.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  434</span>{</div>
<div class="line"><span class="lineno">  435</span>  <span class="keyword">const</span> <span class="keyword">auto</span> <span class="keywordtype">id</span> = <a class="code hl_function" href="namespaceMooseMeshUtils.html#ab494196fbfc861511c2875d70e90f364">getBoundaryID</a>(name, input_mesh);</div>
<div class="line"><span class="lineno">  436</span>  <span class="keywordflow">return</span> <a class="code hl_function" href="namespaceMooseMeshUtils.html#a19b589a0ebc9fde03d51d042b0cdedde">hasBoundaryID</a>(input_mesh, <span class="keywordtype">id</span>);</div>
<div class="line"><span class="lineno">  437</span>}</div>
<div class="ttc" id="anamespaceMooseMeshUtils_html_a19b589a0ebc9fde03d51d042b0cdedde"><div class="ttname"><a href="namespaceMooseMeshUtils.html#a19b589a0ebc9fde03d51d042b0cdedde">MooseMeshUtils::hasBoundaryID</a></div><div class="ttdeci">bool hasBoundaryID(MeshBase &amp;input_mesh, const BoundaryID &amp;id)</div><div class="ttdoc">Whether a particular boundary ID exists in the mesh.</div><div class="ttdef"><b>Definition:</b> <a href="MooseMeshUtils_8C_source.html#l00419">MooseMeshUtils.C:419</a></div></div>
<div class="ttc" id="anamespaceMooseMeshUtils_html_ab494196fbfc861511c2875d70e90f364"><div class="ttname"><a href="namespaceMooseMeshUtils.html#ab494196fbfc861511c2875d70e90f364">MooseMeshUtils::getBoundaryID</a></div><div class="ttdeci">BoundaryID getBoundaryID(const BoundaryName &amp;boundary_name, const MeshBase &amp;mesh)</div><div class="ttdoc">Gets the boundary ID associated with the given BoundaryName.</div><div class="ttdef"><b>Definition:</b> <a href="MooseMeshUtils_8C_source.html#l00180">MooseMeshUtils.C:180</a></div></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="MultiAppNearestNodeTransfer_8C_source.html#l00083">MultiAppNearestNodeTransfer::execute()</a>, <a class="el" href="MultiAppUserObjectTransfer_8C_source.html#l00114">MultiAppUserObjectTransfer::execute()</a>, <a class="el" href="BreakBoundaryOnSubdomainGenerator_8C_source.html#l00042">BreakBoundaryOnSubdomainGenerator::generate()</a>, <a class="el" href="CircularBoundaryCorrectionGenerator_8C_source.html#l00085">CircularBoundaryCorrectionGenerator::generate()</a>, <a class="el" href="MultiAppNearestNodeTransfer_8C_source.html#l00714">MultiAppNearestNodeTransfer::getLocalEntitiesAndComponents()</a>, and <a class="el" href="MultiAppNearestNodeTransfer_8C_source.html#l00813">MultiAppNearestNodeTransfer::getTargetLocalNodes()</a>.</p>

</div>
</div>
<a id="ab6b5ee66b2a8eac65a3fb52abf4df5ce" name="ab6b5ee66b2a8eac65a3fb52abf4df5ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6b5ee66b2a8eac65a3fb52abf4df5ce">&#9670;&#160;</a></span>hasSubdomainID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MooseMeshUtils::hasSubdomainID </td>
          <td>(</td>
          <td class="paramtype">MeshBase &amp;&#160;</td>
          <td class="paramname"><em>input_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="AutomaticMortarGeneration_8h.html#afb1ef82fea6170b578d48ad9cd793486">SubdomainID</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether a particular subdomain ID exists in the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>mesh over which to determine subdomain IDs </td></tr>
    <tr><td class="paramname">subdomain</td><td>ID </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="MooseMeshUtils_8C_source.html#l00398">398</a> of file <a class="el" href="MooseMeshUtils_8C_source.html">MooseMeshUtils.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  399</span>{</div>
<div class="line"><span class="lineno">  400</span>  std::set&lt;SubdomainID&gt; mesh_blocks;</div>
<div class="line"><span class="lineno">  401</span>  input_mesh.subdomain_ids(mesh_blocks);</div>
<div class="line"><span class="lineno">  402</span> </div>
<div class="line"><span class="lineno">  403</span>  <span class="comment">// On a distributed mesh we may have sideset IDs that only exist on</span></div>
<div class="line"><span class="lineno">  404</span>  <span class="comment">// other processors</span></div>
<div class="line"><span class="lineno">  405</span>  <span class="keywordflow">if</span> (!input_mesh.is_replicated())</div>
<div class="line"><span class="lineno">  406</span>    input_mesh.comm().set_union(mesh_blocks);</div>
<div class="line"><span class="lineno">  407</span> </div>
<div class="line"><span class="lineno">  408</span>  <span class="keywordflow">return</span> mesh_blocks.count(<span class="keywordtype">id</span>) &amp;&amp; (<span class="keywordtype">id</span> != <a class="code hl_variable" href="namespaceMoose.html#aaf4d8910f17c1134498f8d15e2605482">Moose::INVALID_BLOCK_ID</a>);</div>
<div class="line"><span class="lineno">  409</span>}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="BlockDeletionGenerator_8C_source.html#l00043">BlockDeletionGenerator::generate()</a>, <a class="el" href="ExplodeMeshGenerator_8C_source.html#l00039">ExplodeMeshGenerator::generate()</a>, <a class="el" href="MeshExtruderGenerator_8C_source.html#l00070">MeshExtruderGenerator::generate()</a>, <a class="el" href="RefineBlockGenerator_8C_source.html#l00054">RefineBlockGenerator::generate()</a>, and <a class="el" href="MooseMeshUtils_8C_source.html#l00412">hasSubdomainName()</a>.</p>

</div>
</div>
<a id="aeb5bf7080647764b0dc0340742cd51cb" name="aeb5bf7080647764b0dc0340742cd51cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb5bf7080647764b0dc0340742cd51cb">&#9670;&#160;</a></span>hasSubdomainName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MooseMeshUtils::hasSubdomainName </td>
          <td>(</td>
          <td class="paramtype">MeshBase &amp;&#160;</td>
          <td class="paramname"><em>input_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SubdomainName &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Whether a particular subdomain name exists in the mesh. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>mesh over which to determine subdomain names </td></tr>
    <tr><td class="paramname">subdomain</td><td>name </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="MooseMeshUtils_8C_source.html#l00412">412</a> of file <a class="el" href="MooseMeshUtils_8C_source.html">MooseMeshUtils.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  413</span>{</div>
<div class="line"><span class="lineno">  414</span>  <span class="keyword">const</span> <span class="keyword">auto</span> <span class="keywordtype">id</span> = <a class="code hl_function" href="namespaceMooseMeshUtils.html#ae4231d4834a0d55a379e69118f2e5c64">getSubdomainID</a>(name, input_mesh);</div>
<div class="line"><span class="lineno">  415</span>  <span class="keywordflow">return</span> <a class="code hl_function" href="namespaceMooseMeshUtils.html#ab6b5ee66b2a8eac65a3fb52abf4df5ce">hasSubdomainID</a>(input_mesh, <span class="keywordtype">id</span>);</div>
<div class="line"><span class="lineno">  416</span>}</div>
<div class="ttc" id="anamespaceMooseMeshUtils_html_ab6b5ee66b2a8eac65a3fb52abf4df5ce"><div class="ttname"><a href="namespaceMooseMeshUtils.html#ab6b5ee66b2a8eac65a3fb52abf4df5ce">MooseMeshUtils::hasSubdomainID</a></div><div class="ttdeci">bool hasSubdomainID(MeshBase &amp;input_mesh, const SubdomainID &amp;id)</div><div class="ttdoc">Whether a particular subdomain ID exists in the mesh.</div><div class="ttdef"><b>Definition:</b> <a href="MooseMeshUtils_8C_source.html#l00398">MooseMeshUtils.C:398</a></div></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="MultiAppUserObjectTransfer_8C_source.html#l00114">MultiAppUserObjectTransfer::execute()</a>, <a class="el" href="BreakMeshByBlockGenerator_8C_source.html#l00078">BreakMeshByBlockGenerator::generate()</a>, <a class="el" href="ParsedGenerateSideset_8C_source.html#l00143">ParsedGenerateSideset::generate()</a>, <a class="el" href="ParsedSubdomainMeshGenerator_8C_source.html#l00090">ParsedSubdomainMeshGenerator::generate()</a>, <a class="el" href="SideSetsAroundSubdomainGenerator_8C_source.html#l00070">SideSetsAroundSubdomainGenerator::generate()</a>, <a class="el" href="SideSetsBetweenSubdomainsGenerator_8C_source.html#l00050">SideSetsBetweenSubdomainsGenerator::generate()</a>, <a class="el" href="SubdomainBoundingBoxGenerator_8C_source.html#l00061">SubdomainBoundingBoxGenerator::generate()</a>, and <a class="el" href="MultiAppDofCopyTransfer_8C_source.html#l00055">MultiAppDofCopyTransfer::initialSetup()</a>.</p>

</div>
</div>
<a id="aaa4ff1413857bed978d7c1028d748014" name="aaa4ff1413857bed978d7c1028d748014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa4ff1413857bed978d7c1028d748014">&#9670;&#160;</a></span>isCoPlanar() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MooseMeshUtils::isCoPlanar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Point &gt;&#160;</td>
          <td class="paramname"><em>vec_pts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decides whether all the Points of a vector of Points are coplanar. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec_pts</td><td>vector of points to be examined </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether all the Points are in a same plane </dd></dl>

<p class="definition">Definition at line <a class="el" href="MooseMeshUtils_8C_source.html#l00342">342</a> of file <a class="el" href="MooseMeshUtils_8C_source.html">MooseMeshUtils.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  343</span>{</div>
<div class="line"><span class="lineno">  344</span>  <span class="comment">// Assuming that overlapped Points are allowed, the Points that are overlapped with vec_pts[0] are</span></div>
<div class="line"><span class="lineno">  345</span>  <span class="comment">// removed before further calculation.</span></div>
<div class="line"><span class="lineno">  346</span>  std::vector&lt;Point&gt; vec_pts_nonzero{vec_pts[0]};</div>
<div class="line"><span class="lineno">  347</span>  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1; i &lt; vec_pts.size(); i++)</div>
<div class="line"><span class="lineno">  348</span>    <span class="keywordflow">if</span> (!<a class="code hl_function" href="namespaceMooseUtils.html#ad9865895ce5bb2c18722efa26d5c7693">MooseUtils::absoluteFuzzyEqual</a>((vec_pts[i] - vec_pts[0]).norm(), 0.0))</div>
<div class="line"><span class="lineno">  349</span>      vec_pts_nonzero.push_back(vec_pts[i]);</div>
<div class="line"><span class="lineno">  350</span>  <span class="comment">// 3 or fewer points are always coplanar</span></div>
<div class="line"><span class="lineno">  351</span>  <span class="keywordflow">if</span> (vec_pts_nonzero.size() &lt;= 3)</div>
<div class="line"><span class="lineno">  352</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  353</span>  <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  354</span>  {</div>
<div class="line"><span class="lineno">  355</span>    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1; i &lt; vec_pts_nonzero.size() - 1; i++)</div>
<div class="line"><span class="lineno">  356</span>    {</div>
<div class="line"><span class="lineno">  357</span>      <span class="keyword">const</span> Point tmp_pt = (vec_pts_nonzero[i] - vec_pts_nonzero[0])</div>
<div class="line"><span class="lineno">  358</span>                               .cross(vec_pts_nonzero[i + 1] - vec_pts_nonzero[0]);</div>
<div class="line"><span class="lineno">  359</span>      <span class="comment">// if the three points are not collinear, use cross product as the normal vector of the plane</span></div>
<div class="line"><span class="lineno">  360</span>      <span class="keywordflow">if</span> (!<a class="code hl_function" href="namespaceMooseUtils.html#ad9865895ce5bb2c18722efa26d5c7693">MooseUtils::absoluteFuzzyEqual</a>(tmp_pt.norm(), 0.0))</div>
<div class="line"><span class="lineno">  361</span>        <span class="keywordflow">return</span> isCoPlanar(vec_pts_nonzero, tmp_pt.unit());</div>
<div class="line"><span class="lineno">  362</span>    }</div>
<div class="line"><span class="lineno">  363</span>  }</div>
<div class="line"><span class="lineno">  364</span>  <span class="comment">// If all the points are collinear, they are also coplanar</span></div>
<div class="line"><span class="lineno">  365</span>  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  366</span>}</div>
<div class="ttc" id="anamespaceMooseUtils_html_ad9865895ce5bb2c18722efa26d5c7693"><div class="ttname"><a href="namespaceMooseUtils.html#ad9865895ce5bb2c18722efa26d5c7693">MooseUtils::absoluteFuzzyEqual</a></div><div class="ttdeci">bool absoluteFuzzyEqual(const T &amp;var1, const T2 &amp;var2, const T3 &amp;tol=libMesh::TOLERANCE *libMesh::TOLERANCE)</div><div class="ttdoc">Function to check whether two variables are equal within an absolute tolerance.</div><div class="ttdef"><b>Definition:</b> <a href="MooseUtils_8h_source.html#l00337">MooseUtils.h:337</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a54f882e76448d8f233ff9521a79815a2" name="a54f882e76448d8f233ff9521a79815a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54f882e76448d8f233ff9521a79815a2">&#9670;&#160;</a></span>isCoPlanar() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MooseMeshUtils::isCoPlanar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Point &gt;&#160;</td>
          <td class="paramname"><em>vec_pts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point&#160;</td>
          <td class="paramname"><em>plane_nvec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decides whether all the Points of a vector of Points are in a plane with a given normal vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec_pts</td><td>vector of points to be examined </td></tr>
    <tr><td class="paramname">plane_nvec</td><td>normal vector of the plane </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether all the Points are in the same plane with the given normal vector </dd></dl>

<p class="definition">Definition at line <a class="el" href="MooseMeshUtils_8C_source.html#l00336">336</a> of file <a class="el" href="MooseMeshUtils_8C_source.html">MooseMeshUtils.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  337</span>{</div>
<div class="line"><span class="lineno">  338</span>  <span class="keywordflow">return</span> <a class="code hl_function" href="namespaceMooseMeshUtils.html#a0ecd3cfc33c7333f9873e1598d89619e">isCoPlanar</a>(vec_pts, plane_nvec, vec_pts.front());</div>
<div class="line"><span class="lineno">  339</span>}</div>
<div class="ttc" id="anamespaceMooseMeshUtils_html_a0ecd3cfc33c7333f9873e1598d89619e"><div class="ttname"><a href="namespaceMooseMeshUtils.html#a0ecd3cfc33c7333f9873e1598d89619e">MooseMeshUtils::isCoPlanar</a></div><div class="ttdeci">bool isCoPlanar(const std::vector&lt; Point &gt; vec_pts, const Point plane_nvec, const Point fixed_pt)</div><div class="ttdoc">Decides whether all the Points of a vector of Points are in a plane that is defined by a normal vecto...</div><div class="ttdef"><b>Definition:</b> <a href="MooseMeshUtils_8C_source.html#l00327">MooseMeshUtils.C:327</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a0ecd3cfc33c7333f9873e1598d89619e" name="a0ecd3cfc33c7333f9873e1598d89619e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ecd3cfc33c7333f9873e1598d89619e">&#9670;&#160;</a></span>isCoPlanar() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MooseMeshUtils::isCoPlanar </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Point &gt;&#160;</td>
          <td class="paramname"><em>vec_pts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point&#160;</td>
          <td class="paramname"><em>plane_nvec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Point&#160;</td>
          <td class="paramname"><em>fixed_pt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decides whether all the Points of a vector of Points are in a plane that is defined by a normal vector and an inplane Point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec_pts</td><td>vector of points to be examined </td></tr>
    <tr><td class="paramname">plane_nvec</td><td>normal vector of the plane </td></tr>
    <tr><td class="paramname">fixed_pt</td><td>a Point in the plane </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether all the Points are in the given plane </dd></dl>

<p class="definition">Definition at line <a class="el" href="MooseMeshUtils_8C_source.html#l00327">327</a> of file <a class="el" href="MooseMeshUtils_8C_source.html">MooseMeshUtils.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  328</span>{</div>
<div class="line"><span class="lineno">  329</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; pt : vec_pts)</div>
<div class="line"><span class="lineno">  330</span>    <span class="keywordflow">if</span> (!<a class="code hl_function" href="namespaceMooseUtils.html#ad9865895ce5bb2c18722efa26d5c7693">MooseUtils::absoluteFuzzyEqual</a>((pt - fixed_pt) * plane_nvec, 0.0))</div>
<div class="line"><span class="lineno">  331</span>      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  332</span>  <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  333</span>}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="Positions_8C_source.html#l00263">Positions::arePositionsCoplanar()</a>, <a class="el" href="FillBetweenPointVectorsTools_8C_source.html#l00029">FillBetweenPointVectorsTools::fillBetweenPointVectorsGenerator()</a>, and <a class="el" href="MooseMeshUtils_8C_source.html#l00336">isCoPlanar()</a>.</p>

</div>
</div>
<a id="ae808cb56f81c238b696752e2e3b8be5e" name="ae808cb56f81c238b696752e2e3b8be5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae808cb56f81c238b696752e2e3b8be5e">&#9670;&#160;</a></span>makeOrderedNodeList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MooseMeshUtils::makeOrderedNodeList </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; dof_id_type, dof_id_type &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>node_assm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; dof_id_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>elem_id_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; dof_id_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>ordered_node_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; dof_id_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>ordered_elem_id_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a list of sides in the form of a vector of pairs of node ids into a list of ordered nodes based on connectivity. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_assm</td><td>vector of pairs of node ids that represent the sides </td></tr>
    <tr><td class="paramname">elem_id_list</td><td>vector of element ids that represent the elements that contain the sides </td></tr>
    <tr><td class="paramname">ordered_node_list</td><td>vector of node ids that represent the ordered nodes </td></tr>
    <tr><td class="paramname">ordered_elem_id_list</td><td>vector of element corresponding to the ordered nodes </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="MooseMeshUtils_8C_source.html#l00440">440</a> of file <a class="el" href="MooseMeshUtils_8C_source.html">MooseMeshUtils.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  444</span>{</div>
<div class="line"><span class="lineno">  445</span>  <span class="comment">// a flag to indicate if the ordered_node_list has been reversed</span></div>
<div class="line"><span class="lineno">  446</span>  <span class="keywordtype">bool</span> isFlipped = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  447</span>  <span class="comment">// Start from the first element, try to find a chain of nodes</span></div>
<div class="line"><span class="lineno">  448</span>  mooseAssert(node_assm.size(), <span class="stringliteral">&quot;Node list must not be empty&quot;</span>);</div>
<div class="line"><span class="lineno">  449</span>  ordered_node_list.push_back(node_assm.front().first);</div>
<div class="line"><span class="lineno">  450</span>  ordered_node_list.push_back(node_assm.front().second);</div>
<div class="line"><span class="lineno">  451</span>  ordered_elem_id_list.push_back(elem_id_list.front());</div>
<div class="line"><span class="lineno">  452</span>  <span class="comment">// Remove the element that has just been added to ordered_node_list</span></div>
<div class="line"><span class="lineno">  453</span>  node_assm.erase(node_assm.begin());</div>
<div class="line"><span class="lineno">  454</span>  elem_id_list.erase(elem_id_list.begin());</div>
<div class="line"><span class="lineno">  455</span>  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> node_assm_size_0 = node_assm.size();</div>
<div class="line"><span class="lineno">  456</span>  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; node_assm_size_0; i++)</div>
<div class="line"><span class="lineno">  457</span>  {</div>
<div class="line"><span class="lineno">  458</span>    <span class="comment">// Find nodes to expand the chain</span></div>
<div class="line"><span class="lineno">  459</span>    dof_id_type end_node_id = ordered_node_list.back();</div>
<div class="line"><span class="lineno">  460</span>    <span class="keyword">auto</span> isMatch1 = [end_node_id](std::pair&lt;dof_id_type, dof_id_type&gt; old_id_pair)</div>
<div class="line"><span class="lineno">  461</span>    { <span class="keywordflow">return</span> old_id_pair.first == end_node_id; };</div>
<div class="line"><span class="lineno">  462</span>    <span class="keyword">auto</span> isMatch2 = [end_node_id](std::pair&lt;dof_id_type, dof_id_type&gt; old_id_pair)</div>
<div class="line"><span class="lineno">  463</span>    { <span class="keywordflow">return</span> old_id_pair.second == end_node_id; };</div>
<div class="line"><span class="lineno">  464</span>    <span class="keyword">auto</span> result = std::find_if(node_assm.begin(), node_assm.end(), isMatch1);</div>
<div class="line"><span class="lineno">  465</span>    <span class="keywordtype">bool</span> match_first;</div>
<div class="line"><span class="lineno">  466</span>    <span class="keywordflow">if</span> (result == node_assm.end())</div>
<div class="line"><span class="lineno">  467</span>    {</div>
<div class="line"><span class="lineno">  468</span>      match_first = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  469</span>      result = std::find_if(node_assm.begin(), node_assm.end(), isMatch2);</div>
<div class="line"><span class="lineno">  470</span>    }</div>
<div class="line"><span class="lineno">  471</span>    <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  472</span>    {</div>
<div class="line"><span class="lineno">  473</span>      match_first = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  474</span>    }</div>
<div class="line"><span class="lineno">  475</span>    <span class="comment">// If found, add the node to boundary_ordered_node_list</span></div>
<div class="line"><span class="lineno">  476</span>    <span class="keywordflow">if</span> (result != node_assm.end())</div>
<div class="line"><span class="lineno">  477</span>    {</div>
<div class="line"><span class="lineno">  478</span>      ordered_node_list.push_back(match_first ? (*result).second : (*result).first);</div>
<div class="line"><span class="lineno">  479</span>      node_assm.erase(result);</div>
<div class="line"><span class="lineno">  480</span>      <span class="keyword">const</span> <span class="keyword">auto</span> elem_index = std::distance(node_assm.begin(), result);</div>
<div class="line"><span class="lineno">  481</span>      ordered_elem_id_list.push_back(elem_id_list[elem_index]);</div>
<div class="line"><span class="lineno">  482</span>      elem_id_list.erase(elem_id_list.begin() + elem_index);</div>
<div class="line"><span class="lineno">  483</span>    }</div>
<div class="line"><span class="lineno">  484</span>    <span class="comment">// If there are still elements in node_assm and result ==</span></div>
<div class="line"><span class="lineno">  485</span>    <span class="comment">// node_assm.end(), this means the curve is not a loop, the</span></div>
<div class="line"><span class="lineno">  486</span>    <span class="comment">// ordered_node_list is flipped and try the other direction that has not</span></div>
<div class="line"><span class="lineno">  487</span>    <span class="comment">// been examined yet.</span></div>
<div class="line"><span class="lineno">  488</span>    <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  489</span>    {</div>
<div class="line"><span class="lineno">  490</span>      <span class="keywordflow">if</span> (isFlipped)</div>
<div class="line"><span class="lineno">  491</span>        <span class="comment">// Flipped twice; this means the node list has at least two segments.</span></div>
<div class="line"><span class="lineno">  492</span>        <span class="keywordflow">throw</span> <a class="code hl_class" href="classMooseException.html">MooseException</a>(<span class="stringliteral">&quot;The node list provided has more than one segments.&quot;</span>);</div>
<div class="line"><span class="lineno">  493</span> </div>
<div class="line"><span class="lineno">  494</span>      <span class="comment">// mark the first flip event.</span></div>
<div class="line"><span class="lineno">  495</span>      isFlipped = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  496</span>      std::reverse(ordered_node_list.begin(), ordered_node_list.end());</div>
<div class="line"><span class="lineno">  497</span>      std::reverse(ordered_elem_id_list.begin(), ordered_elem_id_list.end());</div>
<div class="line"><span class="lineno">  498</span>      <span class="comment">// As this iteration is wasted, set the iterator backward</span></div>
<div class="line"><span class="lineno">  499</span>      i--;</div>
<div class="line"><span class="lineno">  500</span>    }</div>
<div class="line"><span class="lineno">  501</span>  }</div>
<div class="line"><span class="lineno">  502</span>}</div>
<div class="ttc" id="aclassMooseException_html"><div class="ttname"><a href="classMooseException.html">MooseException</a></div><div class="ttdoc">Provides a way for users to bail out of the current solve.</div><div class="ttdef"><b>Definition:</b> <a href="MooseException_8h_source.html#l00020">MooseException.h:21</a></div></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="MooseMeshXYCuttingUtils_8C_source.html#l00971">MooseMeshXYCuttingUtils::boundaryTriElemImprover()</a>, and <a class="el" href="FillBetweenPointVectorsTools_8C_source.html#l00657">FillBetweenPointVectorsTools::isClosedLoop()</a>.</p>

</div>
</div>
<a id="ae492a0c56aef2fa920dd78fcd95e0c34" name="ae492a0c56aef2fa920dd78fcd95e0c34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae492a0c56aef2fa920dd78fcd95e0c34">&#9670;&#160;</a></span>meshCentroidCalculator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Point MooseMeshUtils::meshCentroidCalculator </td>
          <td>(</td>
          <td class="paramtype">const MeshBase &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the centroid of a MeshBase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>input mesh whose centroid needs to be calculated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a Point data containing the mesh centroid </dd></dl>

<p class="definition">Definition at line <a class="el" href="MooseMeshUtils_8C_source.html#l00230">230</a> of file <a class="el" href="MooseMeshUtils_8C_source.html">MooseMeshUtils.C</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  231</span>{</div>
<div class="line"><span class="lineno">  232</span>  Point centroid_pt = Point(0.0, 0.0, 0.0);</div>
<div class="line"><span class="lineno">  233</span>  Real vol_tmp = 0.0;</div>
<div class="line"><span class="lineno">  234</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; elem :</div>
<div class="line"><span class="lineno">  235</span>       as_range(mesh.active_local_elements_begin(), mesh.active_local_elements_end()))</div>
<div class="line"><span class="lineno">  236</span>  {</div>
<div class="line"><span class="lineno">  237</span>    Real elem_vol = elem-&gt;volume();</div>
<div class="line"><span class="lineno">  238</span>    centroid_pt += (elem-&gt;true_centroid()) * elem_vol;</div>
<div class="line"><span class="lineno">  239</span>    vol_tmp += elem_vol;</div>
<div class="line"><span class="lineno">  240</span>  }</div>
<div class="line"><span class="lineno">  241</span>  mesh.comm().sum(centroid_pt);</div>
<div class="line"><span class="lineno">  242</span>  mesh.comm().sum(vol_tmp);</div>
<div class="line"><span class="lineno">  243</span>  centroid_pt /= vol_tmp;</div>
<div class="line"><span class="lineno">  244</span>  <span class="keywordflow">return</span> centroid_pt;</div>
<div class="line"><span class="lineno">  245</span>}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="FillBetweenSidesetsGenerator_8C_source.html#l00107">FillBetweenSidesetsGenerator::generate()</a>, and <a class="el" href="MultiAppPositions_8C_source.html#l00049">MultiAppPositions::initialize()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Dec 24 2023 00:33:22 for Zapdos by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>

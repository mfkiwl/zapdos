<!-- HTML header for doxygen 1.9.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Zapdos: DependencyResolver&lt; T, Compare &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
    <a href="https://shannon-lab.github.io/zapdos" style="text-decoration:none"><div id="projectname">Zapdos</div></a><div id="projectname">
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classDependencyResolver-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">DependencyResolver&lt; T, Compare &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Class that represents the dependecy as a graph.  
 <a href="classDependencyResolver.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="DependencyResolver_8h_source.html">DependencyResolver.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a389e1fcbbeab37fb55990311b2a7597f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDependencyResolver.html#a389e1fcbbeab37fb55990311b2a7597f">DependencyResolver</a> ()=default</td></tr>
<tr class="separator:a389e1fcbbeab37fb55990311b2a7597f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a483fadc853b045354333e2c485e0373e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDependencyResolver.html#a483fadc853b045354333e2c485e0373e">~DependencyResolver</a> ()=default</td></tr>
<tr class="separator:a483fadc853b045354333e2c485e0373e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0539fec321d0f2f706ef1c594006b340"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDependencyResolver.html#a0539fec321d0f2f706ef1c594006b340">addNode</a> (const T &amp;a)</td></tr>
<tr class="memdesc:a0539fec321d0f2f706ef1c594006b340"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a node 'a' to the graph.  <a href="classDependencyResolver.html#a0539fec321d0f2f706ef1c594006b340">More...</a><br /></td></tr>
<tr class="separator:a0539fec321d0f2f706ef1c594006b340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56032fa917214375123913fed093b53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDependencyResolver.html#ae56032fa917214375123913fed093b53">addEdge</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="memdesc:ae56032fa917214375123913fed093b53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an edge between nodes 'a' and 'b'.  <a href="classDependencyResolver.html#ae56032fa917214375123913fed093b53">More...</a><br /></td></tr>
<tr class="separator:ae56032fa917214375123913fed093b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3745c7141b9638a42527c218b2bfff8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDependencyResolver.html#ad3745c7141b9638a42527c218b2bfff8">removeEdge</a> (const T &amp;a, const T &amp;b)</td></tr>
<tr class="memdesc:ad3745c7141b9638a42527c218b2bfff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove an edge between nodes 'a' and 'b'.  <a href="classDependencyResolver.html#ad3745c7141b9638a42527c218b2bfff8">More...</a><br /></td></tr>
<tr class="separator:ad3745c7141b9638a42527c218b2bfff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e01dd6ea07d95dcc65a2bec2ed1490"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDependencyResolver.html#ab7e01dd6ea07d95dcc65a2bec2ed1490">removeEdgesInvolving</a> (const T &amp;a)</td></tr>
<tr class="memdesc:ab7e01dd6ea07d95dcc65a2bec2ed1490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove edges drawn from 'a'.  <a href="classDependencyResolver.html#ab7e01dd6ea07d95dcc65a2bec2ed1490">More...</a><br /></td></tr>
<tr class="separator:ab7e01dd6ea07d95dcc65a2bec2ed1490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1285a55b39b9c36e595e495c0f7602b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDependencyResolver.html#ad1285a55b39b9c36e595e495c0f7602b">insertDependency</a> (const T &amp;key, const T &amp;value)</td></tr>
<tr class="memdesc:ad1285a55b39b9c36e595e495c0f7602b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a dependency pair - the first value or the "key" depends on the second value or the "value".  <a href="classDependencyResolver.html#ad1285a55b39b9c36e595e495c0f7602b">More...</a><br /></td></tr>
<tr class="separator:ad1285a55b39b9c36e595e495c0f7602b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55fc9b9962c838af52237e644e85a211"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDependencyResolver.html#a55fc9b9962c838af52237e644e85a211">deleteDependency</a> (const T &amp;key, const T &amp;value)</td></tr>
<tr class="memdesc:a55fc9b9962c838af52237e644e85a211"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a dependency (only the edge) between items in the resolver.  <a href="classDependencyResolver.html#a55fc9b9962c838af52237e644e85a211">More...</a><br /></td></tr>
<tr class="separator:a55fc9b9962c838af52237e644e85a211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae64f38dbc34eb461554df954ea08bf87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDependencyResolver.html#ae64f38dbc34eb461554df954ea08bf87">deleteDependenciesOfKey</a> (const T &amp;key)</td></tr>
<tr class="memdesc:ae64f38dbc34eb461554df954ea08bf87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes dependencies of the given key.  <a href="classDependencyResolver.html#ae64f38dbc34eb461554df954ea08bf87">More...</a><br /></td></tr>
<tr class="separator:ae64f38dbc34eb461554df954ea08bf87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a910eeedd2d33b7b7bf6e19ad724dc2aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDependencyResolver.html#a910eeedd2d33b7b7bf6e19ad724dc2aa">addItem</a> (const T &amp;value)</td></tr>
<tr class="memdesc:a910eeedd2d33b7b7bf6e19ad724dc2aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an independent item to the set.  <a href="classDependencyResolver.html#a910eeedd2d33b7b7bf6e19ad724dc2aa">More...</a><br /></td></tr>
<tr class="separator:a910eeedd2d33b7b7bf6e19ad724dc2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b52dc2f4ca8a1407e8e6a57b61fcf6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDependencyResolver.html#aa2b52dc2f4ca8a1407e8e6a57b61fcf6">clear</a> ()</td></tr>
<tr class="memdesc:aa2b52dc2f4ca8a1407e8e6a57b61fcf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear Items from the resolver.  <a href="classDependencyResolver.html#aa2b52dc2f4ca8a1407e8e6a57b61fcf6">More...</a><br /></td></tr>
<tr class="separator:aa2b52dc2f4ca8a1407e8e6a57b61fcf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a64ac168507292e64fb0a29d1e7c59e"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDependencyResolver.html#a6a64ac168507292e64fb0a29d1e7c59e">dfs</a> ()</td></tr>
<tr class="memdesc:a6a64ac168507292e64fb0a29d1e7c59e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do depth-first search from root nodes to obtain order in which graph nodes should be "executed".  <a href="classDependencyResolver.html#a6a64ac168507292e64fb0a29d1e7c59e">More...</a><br /></td></tr>
<tr class="separator:a6a64ac168507292e64fb0a29d1e7c59e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee9fccd7ae6e769c101435fa4125b04c"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::vector&lt; T &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDependencyResolver.html#aee9fccd7ae6e769c101435fa4125b04c">getSortedValuesSets</a> ()</td></tr>
<tr class="memdesc:aee9fccd7ae6e769c101435fa4125b04c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector of sets that represent dependency resolved values.  <a href="classDependencyResolver.html#aee9fccd7ae6e769c101435fa4125b04c">More...</a><br /></td></tr>
<tr class="separator:aee9fccd7ae6e769c101435fa4125b04c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafefd5021e10ad618f245f8b83bd6c10"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDependencyResolver.html#aafefd5021e10ad618f245f8b83bd6c10">getSortedValues</a> ()</td></tr>
<tr class="memdesc:aafefd5021e10ad618f245f8b83bd6c10"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function also returns dependency resolved values but with a simpler single vector interface.  <a href="classDependencyResolver.html#aafefd5021e10ad618f245f8b83bd6c10">More...</a><br /></td></tr>
<tr class="separator:aafefd5021e10ad618f245f8b83bd6c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b8a4729b546c503be157513f84b33f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDependencyResolver.html#a03b8a4729b546c503be157513f84b33f">dependsOn</a> (const T &amp;key, const T &amp;value)</td></tr>
<tr class="memdesc:a03b8a4729b546c503be157513f84b33f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if key depends on value.  <a href="classDependencyResolver.html#a03b8a4729b546c503be157513f84b33f">More...</a><br /></td></tr>
<tr class="separator:a03b8a4729b546c503be157513f84b33f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6276aba693f4048fa1a024c28d6577dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDependencyResolver.html#a6276aba693f4048fa1a024c28d6577dc">dependsOn</a> (const std::vector&lt; T &gt; &amp;keys, const T &amp;value)</td></tr>
<tr class="memdesc:a6276aba693f4048fa1a024c28d6577dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if any of elements of keys depends on value.  <a href="classDependencyResolver.html#a6276aba693f4048fa1a024c28d6577dc">More...</a><br /></td></tr>
<tr class="separator:a6276aba693f4048fa1a024c28d6577dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9aa87839b439b9a435bfd4978e031e"><td class="memItemLeft" align="right" valign="top">std::list&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDependencyResolver.html#a1f9aa87839b439b9a435bfd4978e031e">getAncestors</a> (const T &amp;key)</td></tr>
<tr class="memdesc:a1f9aa87839b439b9a435bfd4978e031e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a list of all values that a given key depends on.  <a href="classDependencyResolver.html#a1f9aa87839b439b9a435bfd4978e031e">More...</a><br /></td></tr>
<tr class="separator:a1f9aa87839b439b9a435bfd4978e031e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eaa182b142564fc994ef61cbf0c8a32"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDependencyResolver.html#a9eaa182b142564fc994ef61cbf0c8a32">size</a> () const</td></tr>
<tr class="memdesc:a9eaa182b142564fc994ef61cbf0c8a32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of unique items stored in the dependency resolver.  <a href="classDependencyResolver.html#a9eaa182b142564fc994ef61cbf0c8a32">More...</a><br /></td></tr>
<tr class="separator:a9eaa182b142564fc994ef61cbf0c8a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aeb6de43a95082902254f4c75801cae54"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDependencyResolver.html#aeb6de43a95082902254f4c75801cae54">dependsOnFromNode</a> (const T &amp;root, const T &amp;item)</td></tr>
<tr class="memdesc:aeb6de43a95082902254f4c75801cae54"><td class="mdescLeft">&#160;</td><td class="mdescRight">depth first search from a root node, searching for a specific item  <a href="classDependencyResolver.html#aeb6de43a95082902254f4c75801cae54">More...</a><br /></td></tr>
<tr class="separator:aeb6de43a95082902254f4c75801cae54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22af2a7eeacee6d116e595d68bbfc231"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDependencyResolver.html#a22af2a7eeacee6d116e595d68bbfc231">dfsFromNode</a> (const T &amp;root)</td></tr>
<tr class="memdesc:a22af2a7eeacee6d116e595d68bbfc231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a depth-first-search from the specified <code>root</code> node.  <a href="classDependencyResolver.html#a22af2a7eeacee6d116e595d68bbfc231">More...</a><br /></td></tr>
<tr class="separator:a22af2a7eeacee6d116e595d68bbfc231"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a414e3355d922317d800fe0322046fd9d"><td class="memItemLeft" align="right" valign="top">std::map&lt; T, std::list&lt; T &gt;, Compare &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDependencyResolver.html#a414e3355d922317d800fe0322046fd9d">_adj</a></td></tr>
<tr class="memdesc:a414e3355d922317d800fe0322046fd9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">adjacency lists (from leaves to roots)  <a href="classDependencyResolver.html#a414e3355d922317d800fe0322046fd9d">More...</a><br /></td></tr>
<tr class="separator:a414e3355d922317d800fe0322046fd9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cf5add89ae685ca108990401ac1b70d"><td class="memItemLeft" align="right" valign="top">std::map&lt; T, std::list&lt; T &gt;, Compare &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDependencyResolver.html#a6cf5add89ae685ca108990401ac1b70d">_inv_adj</a></td></tr>
<tr class="memdesc:a6cf5add89ae685ca108990401ac1b70d"><td class="mdescLeft">&#160;</td><td class="mdescRight">adjacency lists (from roots to leaves)  <a href="classDependencyResolver.html#a6cf5add89ae685ca108990401ac1b70d">More...</a><br /></td></tr>
<tr class="separator:a6cf5add89ae685ca108990401ac1b70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8b029ffb518b865a78ef0a959fbcaba"><td class="memItemLeft" align="right" valign="top">std::map&lt; T, bool, Compare &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDependencyResolver.html#af8b029ffb518b865a78ef0a959fbcaba">_visited</a></td></tr>
<tr class="memdesc:af8b029ffb518b865a78ef0a959fbcaba"><td class="mdescLeft">&#160;</td><td class="mdescRight">vector of visited nodes  <a href="classDependencyResolver.html#af8b029ffb518b865a78ef0a959fbcaba">More...</a><br /></td></tr>
<tr class="separator:af8b029ffb518b865a78ef0a959fbcaba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d5743037e1637fb68fd1dedfdbf8c93"><td class="memItemLeft" align="right" valign="top">std::map&lt; T, bool, Compare &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDependencyResolver.html#a1d5743037e1637fb68fd1dedfdbf8c93">_rec_stack</a></td></tr>
<tr class="memdesc:a1d5743037e1637fb68fd1dedfdbf8c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">recursive stack  <a href="classDependencyResolver.html#a1d5743037e1637fb68fd1dedfdbf8c93">More...</a><br /></td></tr>
<tr class="separator:a1d5743037e1637fb68fd1dedfdbf8c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ed8c367cd54a3478836cfc8e9694a5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDependencyResolver.html#a51ed8c367cd54a3478836cfc8e9694a5">_sorted_vector</a></td></tr>
<tr class="memdesc:a51ed8c367cd54a3478836cfc8e9694a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">"sorted" vector of nodes  <a href="classDependencyResolver.html#a51ed8c367cd54a3478836cfc8e9694a5">More...</a><br /></td></tr>
<tr class="separator:a51ed8c367cd54a3478836cfc8e9694a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed2148b0f29b6fd3a0e80a6ded6328b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDependencyResolver.html#a3ed2148b0f29b6fd3a0e80a6ded6328b">_ordered_items</a></td></tr>
<tr class="memdesc:a3ed2148b0f29b6fd3a0e80a6ded6328b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The sorted vector of sets.  <a href="classDependencyResolver.html#a3ed2148b0f29b6fd3a0e80a6ded6328b">More...</a><br /></td></tr>
<tr class="separator:a3ed2148b0f29b6fd3a0e80a6ded6328b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ddc7b6d88998dc78c3e4a2a59c87a9f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDependencyResolver.html#a8ddc7b6d88998dc78c3e4a2a59c87a9f">_insertion_order</a></td></tr>
<tr class="memdesc:a8ddc7b6d88998dc78c3e4a2a59c87a9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Container for keeping track of the insertion order.  <a href="classDependencyResolver.html#a8ddc7b6d88998dc78c3e4a2a59c87a9f">More...</a><br /></td></tr>
<tr class="separator:a8ddc7b6d88998dc78c3e4a2a59c87a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fcf207e6e4e40b8e452549e6c7d67a6"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDependencyResolver.html#a1fcf207e6e4e40b8e452549e6c7d67a6">_circular_node</a> = T{}</td></tr>
<tr class="memdesc:a1fcf207e6e4e40b8e452549e6c7d67a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data member for storing nodes that appear circularly in the graph.  <a href="classDependencyResolver.html#a1fcf207e6e4e40b8e452549e6c7d67a6">More...</a><br /></td></tr>
<tr class="separator:a1fcf207e6e4e40b8e452549e6c7d67a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a5bdd64f173a3ee76db6f8cfad4c6f9ec"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDependencyResolver.html#a5bdd64f173a3ee76db6f8cfad4c6f9ec">CyclicDependencyException&lt; T, Compare &gt;</a></td></tr>
<tr class="separator:a5bdd64f173a3ee76db6f8cfad4c6f9ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;class T, class Compare = std::less&lt;T&gt;&gt;<br />
class DependencyResolver&lt; T, Compare &gt;</div><p >Class that represents the dependecy as a graph. </p>

<p class="definition">Definition at line <a class="el" href="DependencyResolver_8h_source.html#l00035">35</a> of file <a class="el" href="DependencyResolver_8h_source.html">DependencyResolver.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a389e1fcbbeab37fb55990311b2a7597f" name="a389e1fcbbeab37fb55990311b2a7597f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a389e1fcbbeab37fb55990311b2a7597f">&#9670;&#160;</a></span>DependencyResolver()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Compare  = std::less&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDependencyResolver.html">DependencyResolver</a>&lt; T, Compare &gt;<a class="el" href="classDependencyResolver.html">::DependencyResolver</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a483fadc853b045354333e2c485e0373e" name="a483fadc853b045354333e2c485e0373e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a483fadc853b045354333e2c485e0373e">&#9670;&#160;</a></span>~DependencyResolver()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Compare  = std::less&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDependencyResolver.html">DependencyResolver</a>&lt; T, Compare &gt;::~<a class="el" href="classDependencyResolver.html">DependencyResolver</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae56032fa917214375123913fed093b53" name="ae56032fa917214375123913fed093b53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae56032fa917214375123913fed093b53">&#9670;&#160;</a></span>addEdge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDependencyResolver.html">DependencyResolver</a>&lt; T, Compare &gt;::addEdge </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an edge between nodes 'a' and 'b'. </p>

<p class="definition">Definition at line <a class="el" href="DependencyResolver_8h_source.html#l00207">207</a> of file <a class="el" href="DependencyResolver_8h_source.html">DependencyResolver.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  208</span>{</div>
<div class="line"><span class="lineno">  209</span>  <a class="code hl_function" href="classDependencyResolver.html#a0539fec321d0f2f706ef1c594006b340">addNode</a>(a);</div>
<div class="line"><span class="lineno">  210</span>  <a class="code hl_function" href="classDependencyResolver.html#a0539fec321d0f2f706ef1c594006b340">addNode</a>(b);</div>
<div class="line"><span class="lineno">  211</span> </div>
<div class="line"><span class="lineno">  212</span>  <a class="code hl_variable" href="classDependencyResolver.html#a414e3355d922317d800fe0322046fd9d">_adj</a>[a].push_back(b);</div>
<div class="line"><span class="lineno">  213</span>  <a class="code hl_variable" href="classDependencyResolver.html#a6cf5add89ae685ca108990401ac1b70d">_inv_adj</a>[b].push_back(a);</div>
<div class="line"><span class="lineno">  214</span>}</div>
<div class="ttc" id="aclassDependencyResolver_html_a0539fec321d0f2f706ef1c594006b340"><div class="ttname"><a href="classDependencyResolver.html#a0539fec321d0f2f706ef1c594006b340">DependencyResolver::addNode</a></div><div class="ttdeci">void addNode(const T &amp;a)</div><div class="ttdoc">Add a node 'a' to the graph.</div><div class="ttdef"><b>Definition:</b> <a href="DependencyResolver_8h_source.html#l00179">DependencyResolver.h:179</a></div></div>
<div class="ttc" id="aclassDependencyResolver_html_a414e3355d922317d800fe0322046fd9d"><div class="ttname"><a href="classDependencyResolver.html#a414e3355d922317d800fe0322046fd9d">DependencyResolver::_adj</a></div><div class="ttdeci">std::map&lt; T, std::list&lt; T &gt;, Compare &gt; _adj</div><div class="ttdoc">adjacency lists (from leaves to roots)</div><div class="ttdef"><b>Definition:</b> <a href="DependencyResolver_8h_source.html#l00154">DependencyResolver.h:154</a></div></div>
<div class="ttc" id="aclassDependencyResolver_html_a6cf5add89ae685ca108990401ac1b70d"><div class="ttname"><a href="classDependencyResolver.html#a6cf5add89ae685ca108990401ac1b70d">DependencyResolver::_inv_adj</a></div><div class="ttdeci">std::map&lt; T, std::list&lt; T &gt;, Compare &gt; _inv_adj</div><div class="ttdoc">adjacency lists (from roots to leaves)</div><div class="ttdef"><b>Definition:</b> <a href="DependencyResolver_8h_source.html#l00156">DependencyResolver.h:156</a></div></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="MeshGeneratorSystem_8C_source.html#l00123">MeshGeneratorSystem::createAddedMeshGenerators()</a>, <a class="el" href="MeshGeneratorSystem_8C_source.html#l00182">MeshGeneratorSystem::createMeshGeneratorOrder()</a>, <a class="el" href="FEProblemBase_8C_source.html#l04521">FEProblemBase::executeControls()</a>, <a class="el" href="DependencyResolver_8h_source.html#l00065">DependencyResolver&lt; T, Compare &gt;::insertDependency()</a>, and <a class="el" href="DependencyResolverInterface_8h_source.html#l00071">DependencyResolverInterface::sortDFS()</a>.</p>

</div>
</div>
<a id="a910eeedd2d33b7b7bf6e19ad724dc2aa" name="a910eeedd2d33b7b7bf6e19ad724dc2aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a910eeedd2d33b7b7bf6e19ad724dc2aa">&#9670;&#160;</a></span>addItem()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Compare  = std::less&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDependencyResolver.html">DependencyResolver</a>&lt; T, Compare &gt;::addItem </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add an independent item to the set. </p>

<p class="definition">Definition at line <a class="el" href="DependencyResolver_8h_source.html#l00080">80</a> of file <a class="el" href="DependencyResolver_8h_source.html">DependencyResolver.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   80</span>{ <a class="code hl_function" href="classDependencyResolver.html#a0539fec321d0f2f706ef1c594006b340">addNode</a>(value); }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="MeshGeneratorSystem_8C_source.html#l00123">MeshGeneratorSystem::createAddedMeshGenerators()</a>, <a class="el" href="MeshGeneratorSystem_8C_source.html#l00182">MeshGeneratorSystem::createMeshGeneratorOrder()</a>, <a class="el" href="FEProblemBase_8C_source.html#l04521">FEProblemBase::executeControls()</a>, and <a class="el" href="Syntax_8C_source.html#l00020">Syntax::registerTaskName()</a>.</p>

</div>
</div>
<a id="a0539fec321d0f2f706ef1c594006b340" name="a0539fec321d0f2f706ef1c594006b340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0539fec321d0f2f706ef1c594006b340">&#9670;&#160;</a></span>addNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDependencyResolver.html">DependencyResolver</a>&lt; T, Compare &gt;::addNode </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a node 'a' to the graph. </p>

<p class="definition">Definition at line <a class="el" href="DependencyResolver_8h_source.html#l00179">179</a> of file <a class="el" href="DependencyResolver_8h_source.html">DependencyResolver.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  180</span>{</div>
<div class="line"><span class="lineno">  181</span><span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line"><span class="lineno">  182</span>  <span class="keywordtype">bool</span> new_adj_insertion = <span class="keyword">false</span>, new_inv_insertion = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  183</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno">  184</span>  <span class="keywordflow">if</span> (<a class="code hl_variable" href="classDependencyResolver.html#a414e3355d922317d800fe0322046fd9d">_adj</a>.find(a) == <a class="code hl_variable" href="classDependencyResolver.html#a414e3355d922317d800fe0322046fd9d">_adj</a>.end())</div>
<div class="line"><span class="lineno">  185</span>  {</div>
<div class="line"><span class="lineno">  186</span><span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line"><span class="lineno">  187</span>    new_adj_insertion = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  188</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno">  189</span>    <a class="code hl_variable" href="classDependencyResolver.html#a414e3355d922317d800fe0322046fd9d">_adj</a>[a] = {};</div>
<div class="line"><span class="lineno">  190</span>    <a class="code hl_variable" href="classDependencyResolver.html#a8ddc7b6d88998dc78c3e4a2a59c87a9f">_insertion_order</a>.push_back(a);</div>
<div class="line"><span class="lineno">  191</span>  }</div>
<div class="line"><span class="lineno">  192</span> </div>
<div class="line"><span class="lineno">  193</span>  <span class="keywordflow">if</span> (<a class="code hl_variable" href="classDependencyResolver.html#a6cf5add89ae685ca108990401ac1b70d">_inv_adj</a>.find(a) == <a class="code hl_variable" href="classDependencyResolver.html#a6cf5add89ae685ca108990401ac1b70d">_inv_adj</a>.end())</div>
<div class="line"><span class="lineno">  194</span>  {</div>
<div class="line"><span class="lineno">  195</span><span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line"><span class="lineno">  196</span>    new_inv_insertion = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  197</span><span class="preprocessor">#endif</span></div>
<div class="line"><span class="lineno">  198</span>    <a class="code hl_variable" href="classDependencyResolver.html#a6cf5add89ae685ca108990401ac1b70d">_inv_adj</a>[a] = {};</div>
<div class="line"><span class="lineno">  199</span>  }</div>
<div class="line"><span class="lineno">  200</span>  mooseAssert(new_adj_insertion == new_inv_insertion,</div>
<div class="line"><span class="lineno">  201</span>              <span class="stringliteral">&quot;We should have symmetric behavior between adjacent and inverse-adjacent &quot;</span></div>
<div class="line"><span class="lineno">  202</span>              <span class="stringliteral">&quot;insertion/non-insertion.&quot;</span>);</div>
<div class="line"><span class="lineno">  203</span>}</div>
<div class="ttc" id="aclassDependencyResolver_html_a8ddc7b6d88998dc78c3e4a2a59c87a9f"><div class="ttname"><a href="classDependencyResolver.html#a8ddc7b6d88998dc78c3e4a2a59c87a9f">DependencyResolver::_insertion_order</a></div><div class="ttdeci">std::vector&lt; T &gt; _insertion_order</div><div class="ttdoc">Container for keeping track of the insertion order.</div><div class="ttdef"><b>Definition:</b> <a href="DependencyResolver_8h_source.html#l00170">DependencyResolver.h:170</a></div></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="DependencyResolver_8h_source.html#l00080">DependencyResolver&lt; T, Compare &gt;::addItem()</a>, and <a class="el" href="DependencyResolverInterface_8h_source.html#l00071">DependencyResolverInterface::sortDFS()</a>.</p>

</div>
</div>
<a id="aa2b52dc2f4ca8a1407e8e6a57b61fcf6" name="aa2b52dc2f4ca8a1407e8e6a57b61fcf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2b52dc2f4ca8a1407e8e6a57b61fcf6">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDependencyResolver.html">DependencyResolver</a>&lt; T, Compare &gt;::clear</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear Items from the resolver. </p>

<p class="definition">Definition at line <a class="el" href="DependencyResolver_8h_source.html#l00248">248</a> of file <a class="el" href="DependencyResolver_8h_source.html">DependencyResolver.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  249</span>{</div>
<div class="line"><span class="lineno">  250</span>  <a class="code hl_variable" href="classDependencyResolver.html#a414e3355d922317d800fe0322046fd9d">_adj</a>.clear();</div>
<div class="line"><span class="lineno">  251</span>  <a class="code hl_variable" href="classDependencyResolver.html#a6cf5add89ae685ca108990401ac1b70d">_inv_adj</a>.clear();</div>
<div class="line"><span class="lineno">  252</span>  <a class="code hl_variable" href="classDependencyResolver.html#a8ddc7b6d88998dc78c3e4a2a59c87a9f">_insertion_order</a>.clear();</div>
<div class="line"><span class="lineno">  253</span>}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="Syntax_8C_source.html#l00094">Syntax::clearTaskDependencies()</a>.</p>

</div>
</div>
<a id="ae64f38dbc34eb461554df954ea08bf87" name="ae64f38dbc34eb461554df954ea08bf87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae64f38dbc34eb461554df954ea08bf87">&#9670;&#160;</a></span>deleteDependenciesOfKey()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Compare  = std::less&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDependencyResolver.html">DependencyResolver</a>&lt; T, Compare &gt;::deleteDependenciesOfKey </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes dependencies of the given key. </p>

<p class="definition">Definition at line <a class="el" href="DependencyResolver_8h_source.html#l00075">75</a> of file <a class="el" href="DependencyResolver_8h_source.html">DependencyResolver.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   75</span>{ <a class="code hl_function" href="classDependencyResolver.html#ab7e01dd6ea07d95dcc65a2bec2ed1490">removeEdgesInvolving</a>(key); }</div>
<div class="ttc" id="aclassDependencyResolver_html_ab7e01dd6ea07d95dcc65a2bec2ed1490"><div class="ttname"><a href="classDependencyResolver.html#ab7e01dd6ea07d95dcc65a2bec2ed1490">DependencyResolver::removeEdgesInvolving</a></div><div class="ttdeci">void removeEdgesInvolving(const T &amp;a)</div><div class="ttdoc">Remove edges drawn from 'a'.</div><div class="ttdef"><b>Definition:</b> <a href="DependencyResolver_8h_source.html#l00232">DependencyResolver.h:232</a></div></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="Syntax_8C_source.html#l00085">Syntax::deleteTaskDependencies()</a>.</p>

</div>
</div>
<a id="a55fc9b9962c838af52237e644e85a211" name="a55fc9b9962c838af52237e644e85a211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55fc9b9962c838af52237e644e85a211">&#9670;&#160;</a></span>deleteDependency()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Compare  = std::less&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDependencyResolver.html">DependencyResolver</a>&lt; T, Compare &gt;::deleteDependency </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete a dependency (only the edge) between items in the resolver. </p>

<p class="definition">Definition at line <a class="el" href="DependencyResolver_8h_source.html#l00070">70</a> of file <a class="el" href="DependencyResolver_8h_source.html">DependencyResolver.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   70</span>{ <a class="code hl_function" href="classDependencyResolver.html#ad3745c7141b9638a42527c218b2bfff8">removeEdge</a>(value, key); }</div>
<div class="ttc" id="aclassDependencyResolver_html_ad3745c7141b9638a42527c218b2bfff8"><div class="ttname"><a href="classDependencyResolver.html#ad3745c7141b9638a42527c218b2bfff8">DependencyResolver::removeEdge</a></div><div class="ttdeci">void removeEdge(const T &amp;a, const T &amp;b)</div><div class="ttdoc">Remove an edge between nodes 'a' and 'b'.</div><div class="ttdef"><b>Definition:</b> <a href="DependencyResolver_8h_source.html#l00218">DependencyResolver.h:218</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a6276aba693f4048fa1a024c28d6577dc" name="a6276aba693f4048fa1a024c28d6577dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6276aba693f4048fa1a024c28d6577dc">&#9670;&#160;</a></span>dependsOn() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classDependencyResolver.html">DependencyResolver</a>&lt; T, Compare &gt;::dependsOn </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if any of elements of keys depends on value. </p>

<p class="definition">Definition at line <a class="el" href="DependencyResolver_8h_source.html#l00350">350</a> of file <a class="el" href="DependencyResolver_8h_source.html">DependencyResolver.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  351</span>{</div>
<div class="line"><span class="lineno">  352</span>  <span class="keywordflow">if</span> (<a class="code hl_variable" href="classDependencyResolver.html#a414e3355d922317d800fe0322046fd9d">_adj</a>.find(value) == <a class="code hl_variable" href="classDependencyResolver.html#a414e3355d922317d800fe0322046fd9d">_adj</a>.end())</div>
<div class="line"><span class="lineno">  353</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  354</span> </div>
<div class="line"><span class="lineno">  355</span>  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; n : <a class="code hl_variable" href="classDependencyResolver.html#a414e3355d922317d800fe0322046fd9d">_adj</a>)</div>
<div class="line"><span class="lineno">  356</span>    <a class="code hl_variable" href="classDependencyResolver.html#af8b029ffb518b865a78ef0a959fbcaba">_visited</a>[n.first] = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  357</span> </div>
<div class="line"><span class="lineno">  358</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; key : keys)</div>
<div class="line"><span class="lineno">  359</span>    <span class="keywordflow">if</span> (<a class="code hl_function" href="classDependencyResolver.html#aeb6de43a95082902254f4c75801cae54">dependsOnFromNode</a>(key, value))</div>
<div class="line"><span class="lineno">  360</span>      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  361</span> </div>
<div class="line"><span class="lineno">  362</span>  <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  363</span>}</div>
<div class="ttc" id="aclassDependencyResolver_html_aeb6de43a95082902254f4c75801cae54"><div class="ttname"><a href="classDependencyResolver.html#aeb6de43a95082902254f4c75801cae54">DependencyResolver::dependsOnFromNode</a></div><div class="ttdeci">bool dependsOnFromNode(const T &amp;root, const T &amp;item)</div><div class="ttdoc">depth first search from a root node, searching for a specific item</div><div class="ttdef"><b>Definition:</b> <a href="DependencyResolver_8h_source.html#l00387">DependencyResolver.h:387</a></div></div>
<div class="ttc" id="aclassDependencyResolver_html_af8b029ffb518b865a78ef0a959fbcaba"><div class="ttname"><a href="classDependencyResolver.html#af8b029ffb518b865a78ef0a959fbcaba">DependencyResolver::_visited</a></div><div class="ttdeci">std::map&lt; T, bool, Compare &gt; _visited</div><div class="ttdoc">vector of visited nodes</div><div class="ttdef"><b>Definition:</b> <a href="DependencyResolver_8h_source.html#l00158">DependencyResolver.h:158</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a03b8a4729b546c503be157513f84b33f" name="a03b8a4729b546c503be157513f84b33f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03b8a4729b546c503be157513f84b33f">&#9670;&#160;</a></span>dependsOn() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classDependencyResolver.html">DependencyResolver</a>&lt; T, Compare &gt;::dependsOn </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if key depends on value. </p>
<p >That is, return true, if a chain of calls of the form insertDependency(key, v0) insertDependency(v0, v1) insertDependency(v1, v2) ... insertDependency(vN, value) has been performed. dependsOn(x, x) always returns true </p>

<p class="definition">Definition at line <a class="el" href="DependencyResolver_8h_source.html#l00337">337</a> of file <a class="el" href="DependencyResolver_8h_source.html">DependencyResolver.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  338</span>{</div>
<div class="line"><span class="lineno">  339</span>  <span class="keywordflow">if</span> (<a class="code hl_variable" href="classDependencyResolver.html#a414e3355d922317d800fe0322046fd9d">_adj</a>.find(value) == <a class="code hl_variable" href="classDependencyResolver.html#a414e3355d922317d800fe0322046fd9d">_adj</a>.end())</div>
<div class="line"><span class="lineno">  340</span>    <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  341</span> </div>
<div class="line"><span class="lineno">  342</span>  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; n : <a class="code hl_variable" href="classDependencyResolver.html#a414e3355d922317d800fe0322046fd9d">_adj</a>)</div>
<div class="line"><span class="lineno">  343</span>    <a class="code hl_variable" href="classDependencyResolver.html#af8b029ffb518b865a78ef0a959fbcaba">_visited</a>[n.first] = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  344</span> </div>
<div class="line"><span class="lineno">  345</span>  <span class="keywordflow">return</span> <a class="code hl_function" href="classDependencyResolver.html#aeb6de43a95082902254f4c75801cae54">dependsOnFromNode</a>(key, value);</div>
<div class="line"><span class="lineno">  346</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aeb6de43a95082902254f4c75801cae54" name="aeb6de43a95082902254f4c75801cae54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb6de43a95082902254f4c75801cae54">&#9670;&#160;</a></span>dependsOnFromNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classDependencyResolver.html">DependencyResolver</a>&lt; T, Compare &gt;::dependsOnFromNode </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>depth first search from a root node, searching for a specific item </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">root</td><td>The node we start from </td></tr>
    <tr><td class="paramname">item</td><td>The node we are searching for </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="DependencyResolver_8h_source.html#l00387">387</a> of file <a class="el" href="DependencyResolver_8h_source.html">DependencyResolver.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  388</span>{</div>
<div class="line"><span class="lineno">  389</span>  <span class="keywordflow">if</span> (root == item)</div>
<div class="line"><span class="lineno">  390</span>    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  391</span> </div>
<div class="line"><span class="lineno">  392</span>  <a class="code hl_variable" href="classDependencyResolver.html#af8b029ffb518b865a78ef0a959fbcaba">_visited</a>[root] = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  393</span> </div>
<div class="line"><span class="lineno">  394</span>  <span class="keyword">auto</span> &amp; my_dependencies = <a class="code hl_variable" href="classDependencyResolver.html#a6cf5add89ae685ca108990401ac1b70d">_inv_adj</a>[root];</div>
<div class="line"><span class="lineno">  395</span> </div>
<div class="line"><span class="lineno">  396</span>  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; i : my_dependencies)</div>
<div class="line"><span class="lineno">  397</span>    <span class="keywordflow">if</span> (!<a class="code hl_variable" href="classDependencyResolver.html#af8b029ffb518b865a78ef0a959fbcaba">_visited</a>.at(i) &amp;&amp; <a class="code hl_function" href="classDependencyResolver.html#aeb6de43a95082902254f4c75801cae54">dependsOnFromNode</a>(i, item))</div>
<div class="line"><span class="lineno">  398</span>      <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  399</span> </div>
<div class="line"><span class="lineno">  400</span>  <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  401</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6a64ac168507292e64fb0a29d1e7c59e" name="a6a64ac168507292e64fb0a29d1e7c59e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a64ac168507292e64fb0a29d1e7c59e">&#9670;&#160;</a></span>dfs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; T &gt; &amp; <a class="el" href="classDependencyResolver.html">DependencyResolver</a>&lt; T, Compare &gt;::dfs</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do depth-first search from root nodes to obtain order in which graph nodes should be "executed". </p>

<p class="definition">Definition at line <a class="el" href="DependencyResolver_8h_source.html#l00257">257</a> of file <a class="el" href="DependencyResolver_8h_source.html">DependencyResolver.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  258</span>{</div>
<div class="line"><span class="lineno">  259</span>  <a class="code hl_variable" href="classDependencyResolver.html#a51ed8c367cd54a3478836cfc8e9694a5">_sorted_vector</a>.clear();</div>
<div class="line"><span class="lineno">  260</span>  <a class="code hl_variable" href="classDependencyResolver.html#af8b029ffb518b865a78ef0a959fbcaba">_visited</a>.clear();</div>
<div class="line"><span class="lineno">  261</span>  <a class="code hl_variable" href="classDependencyResolver.html#a1d5743037e1637fb68fd1dedfdbf8c93">_rec_stack</a>.clear();</div>
<div class="line"><span class="lineno">  262</span>  <a class="code hl_variable" href="classDependencyResolver.html#a1fcf207e6e4e40b8e452549e6c7d67a6">_circular_node</a> = T{};</div>
<div class="line"><span class="lineno">  263</span> </div>
<div class="line"><span class="lineno">  264</span>  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; n : <a class="code hl_variable" href="classDependencyResolver.html#a414e3355d922317d800fe0322046fd9d">_adj</a>)</div>
<div class="line"><span class="lineno">  265</span>  {</div>
<div class="line"><span class="lineno">  266</span>    <a class="code hl_variable" href="classDependencyResolver.html#af8b029ffb518b865a78ef0a959fbcaba">_visited</a>[n.first] = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  267</span>    <a class="code hl_variable" href="classDependencyResolver.html#a1d5743037e1637fb68fd1dedfdbf8c93">_rec_stack</a>[n.first] = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  268</span>  }</div>
<div class="line"><span class="lineno">  269</span> </div>
<div class="line"><span class="lineno">  270</span>  <span class="keywordtype">bool</span> is_cyclic = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  271</span>  <span class="comment">// If there are no adjacencies, then all nodes are both roots and leaves</span></div>
<div class="line"><span class="lineno">  272</span>  <span class="keywordtype">bool</span> roots_found = <a class="code hl_variable" href="classDependencyResolver.html#a414e3355d922317d800fe0322046fd9d">_adj</a>.empty();</div>
<div class="line"><span class="lineno">  273</span>  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; n : <a class="code hl_variable" href="classDependencyResolver.html#a8ddc7b6d88998dc78c3e4a2a59c87a9f">_insertion_order</a>)</div>
<div class="line"><span class="lineno">  274</span>    <span class="keywordflow">if</span> (<a class="code hl_variable" href="classDependencyResolver.html#a414e3355d922317d800fe0322046fd9d">_adj</a>[n].<a class="code hl_function" href="classDependencyResolver.html#a9eaa182b142564fc994ef61cbf0c8a32">size</a>() == 0)</div>
<div class="line"><span class="lineno">  275</span>    {</div>
<div class="line"><span class="lineno">  276</span>      roots_found = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  277</span>      is_cyclic = <a class="code hl_function" href="classDependencyResolver.html#a22af2a7eeacee6d116e595d68bbfc231">dfsFromNode</a>(n);</div>
<div class="line"><span class="lineno">  278</span>      <span class="keywordflow">if</span> (is_cyclic)</div>
<div class="line"><span class="lineno">  279</span>        <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  280</span>    }</div>
<div class="line"><span class="lineno">  281</span>  <span class="keywordflow">if</span> (!roots_found)</div>
<div class="line"><span class="lineno">  282</span>  {</div>
<div class="line"><span class="lineno">  283</span>    is_cyclic = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  284</span>    <span class="comment">// Create a cycle graph</span></div>
<div class="line"><span class="lineno">  285</span>    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; n : <a class="code hl_variable" href="classDependencyResolver.html#a8ddc7b6d88998dc78c3e4a2a59c87a9f">_insertion_order</a>)</div>
<div class="line"><span class="lineno">  286</span>      <span class="keywordflow">if</span> (<a class="code hl_function" href="classDependencyResolver.html#a22af2a7eeacee6d116e595d68bbfc231">dfsFromNode</a>(n))</div>
<div class="line"><span class="lineno">  287</span>        <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  288</span>  }</div>
<div class="line"><span class="lineno">  289</span> </div>
<div class="line"><span class="lineno">  290</span>  <span class="keywordflow">if</span> (is_cyclic)</div>
<div class="line"><span class="lineno">  291</span>    <span class="keywordflow">throw</span> <a class="code hl_friend" href="classDependencyResolver.html#a5bdd64f173a3ee76db6f8cfad4c6f9ec">CyclicDependencyException&lt;T, Compare&gt;</a>(<span class="stringliteral">&quot;cyclic graph detected&quot;</span>, *<span class="keyword">this</span>);</div>
<div class="line"><span class="lineno">  292</span> </div>
<div class="line"><span class="lineno">  293</span>  <span class="keywordflow">return</span> <a class="code hl_variable" href="classDependencyResolver.html#a51ed8c367cd54a3478836cfc8e9694a5">_sorted_vector</a>;</div>
<div class="line"><span class="lineno">  294</span>}</div>
<div class="ttc" id="aclassDependencyResolver_html_a1d5743037e1637fb68fd1dedfdbf8c93"><div class="ttname"><a href="classDependencyResolver.html#a1d5743037e1637fb68fd1dedfdbf8c93">DependencyResolver::_rec_stack</a></div><div class="ttdeci">std::map&lt; T, bool, Compare &gt; _rec_stack</div><div class="ttdoc">recursive stack</div><div class="ttdef"><b>Definition:</b> <a href="DependencyResolver_8h_source.html#l00160">DependencyResolver.h:160</a></div></div>
<div class="ttc" id="aclassDependencyResolver_html_a1fcf207e6e4e40b8e452549e6c7d67a6"><div class="ttname"><a href="classDependencyResolver.html#a1fcf207e6e4e40b8e452549e6c7d67a6">DependencyResolver::_circular_node</a></div><div class="ttdeci">T _circular_node</div><div class="ttdoc">Data member for storing nodes that appear circularly in the graph.</div><div class="ttdef"><b>Definition:</b> <a href="DependencyResolver_8h_source.html#l00172">DependencyResolver.h:172</a></div></div>
<div class="ttc" id="aclassDependencyResolver_html_a22af2a7eeacee6d116e595d68bbfc231"><div class="ttname"><a href="classDependencyResolver.html#a22af2a7eeacee6d116e595d68bbfc231">DependencyResolver::dfsFromNode</a></div><div class="ttdeci">bool dfsFromNode(const T &amp;root)</div><div class="ttdoc">Perform a depth-first-search from the specified root node.</div><div class="ttdef"><b>Definition:</b> <a href="DependencyResolver_8h_source.html#l00405">DependencyResolver.h:405</a></div></div>
<div class="ttc" id="aclassDependencyResolver_html_a51ed8c367cd54a3478836cfc8e9694a5"><div class="ttname"><a href="classDependencyResolver.html#a51ed8c367cd54a3478836cfc8e9694a5">DependencyResolver::_sorted_vector</a></div><div class="ttdeci">std::vector&lt; T &gt; _sorted_vector</div><div class="ttdoc">&quot;sorted&quot; vector of nodes</div><div class="ttdef"><b>Definition:</b> <a href="DependencyResolver_8h_source.html#l00162">DependencyResolver.h:162</a></div></div>
<div class="ttc" id="aclassDependencyResolver_html_a5bdd64f173a3ee76db6f8cfad4c6f9ec"><div class="ttname"><a href="classDependencyResolver.html#a5bdd64f173a3ee76db6f8cfad4c6f9ec">DependencyResolver::CyclicDependencyException&lt; T, Compare &gt;</a></div><div class="ttdeci">friend class CyclicDependencyException&lt; T, Compare &gt;</div><div class="ttdef"><b>Definition:</b> <a href="DependencyResolver_8h_source.html#l00172">DependencyResolver.h:174</a></div></div>
<div class="ttc" id="aclassDependencyResolver_html_a9eaa182b142564fc994ef61cbf0c8a32"><div class="ttname"><a href="classDependencyResolver.html#a9eaa182b142564fc994ef61cbf0c8a32">DependencyResolver::size</a></div><div class="ttdeci">std::size_t size() const</div><div class="ttdoc">Returns the number of unique items stored in the dependency resolver.</div><div class="ttdef"><b>Definition:</b> <a href="DependencyResolver_8h_source.html#l00135">DependencyResolver.h:135</a></div></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="DependencyResolver_8h_source.html#l00106">DependencyResolver&lt; T, Compare &gt;::getSortedValues()</a>, and <a class="el" href="DependencyResolverInterface_8h_source.html#l00071">DependencyResolverInterface::sortDFS()</a>.</p>

</div>
</div>
<a id="a22af2a7eeacee6d116e595d68bbfc231" name="a22af2a7eeacee6d116e595d68bbfc231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22af2a7eeacee6d116e595d68bbfc231">&#9670;&#160;</a></span>dfsFromNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classDependencyResolver.html">DependencyResolver</a>&lt; T, Compare &gt;::dfsFromNode </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a depth-first-search from the specified <code>root</code> node. </p>
<p >Populates _visited and _sorted_vector data members </p><dl class="section return"><dt>Returns</dt><dd>whether a cyclic graph was detected while performing the depth-first-search from the <code>root</code> node </dd></dl>

<p class="definition">Definition at line <a class="el" href="DependencyResolver_8h_source.html#l00405">405</a> of file <a class="el" href="DependencyResolver_8h_source.html">DependencyResolver.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  406</span>{</div>
<div class="line"><span class="lineno">  407</span>  <span class="keywordtype">bool</span> cyclic = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  408</span>  <a class="code hl_variable" href="classDependencyResolver.html#af8b029ffb518b865a78ef0a959fbcaba">_visited</a>[root] = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  409</span>  <a class="code hl_variable" href="classDependencyResolver.html#a1d5743037e1637fb68fd1dedfdbf8c93">_rec_stack</a>[root] = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  410</span> </div>
<div class="line"><span class="lineno">  411</span>  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; i : <a class="code hl_variable" href="classDependencyResolver.html#a6cf5add89ae685ca108990401ac1b70d">_inv_adj</a>[root])</div>
<div class="line"><span class="lineno">  412</span>  {</div>
<div class="line"><span class="lineno">  413</span>    <span class="keywordflow">if</span> (!<a class="code hl_variable" href="classDependencyResolver.html#af8b029ffb518b865a78ef0a959fbcaba">_visited</a>.at(i) &amp;&amp; <a class="code hl_function" href="classDependencyResolver.html#a22af2a7eeacee6d116e595d68bbfc231">dfsFromNode</a>(i))</div>
<div class="line"><span class="lineno">  414</span>    {</div>
<div class="line"><span class="lineno">  415</span>      cyclic = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  416</span>      <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  417</span>    }</div>
<div class="line"><span class="lineno">  418</span>    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code hl_variable" href="classDependencyResolver.html#a1d5743037e1637fb68fd1dedfdbf8c93">_rec_stack</a>.at(i))</div>
<div class="line"><span class="lineno">  419</span>    {</div>
<div class="line"><span class="lineno">  420</span>      <a class="code hl_variable" href="classDependencyResolver.html#a1fcf207e6e4e40b8e452549e6c7d67a6">_circular_node</a> = i;</div>
<div class="line"><span class="lineno">  421</span>      <a class="code hl_variable" href="classDependencyResolver.html#a51ed8c367cd54a3478836cfc8e9694a5">_sorted_vector</a>.push_back(i);</div>
<div class="line"><span class="lineno">  422</span>      cyclic = <span class="keyword">true</span>;</div>
<div class="line"><span class="lineno">  423</span>      <span class="keywordflow">break</span>;</div>
<div class="line"><span class="lineno">  424</span>    }</div>
<div class="line"><span class="lineno">  425</span>  }</div>
<div class="line"><span class="lineno">  426</span> </div>
<div class="line"><span class="lineno">  427</span>  <a class="code hl_variable" href="classDependencyResolver.html#a51ed8c367cd54a3478836cfc8e9694a5">_sorted_vector</a>.push_back(root);</div>
<div class="line"><span class="lineno">  428</span>  <a class="code hl_variable" href="classDependencyResolver.html#a1d5743037e1637fb68fd1dedfdbf8c93">_rec_stack</a>[root] = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  429</span>  <span class="keywordflow">return</span> cyclic;</div>
<div class="line"><span class="lineno">  430</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1f9aa87839b439b9a435bfd4978e031e" name="a1f9aa87839b439b9a435bfd4978e031e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f9aa87839b439b9a435bfd4978e031e">&#9670;&#160;</a></span>getAncestors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt; T &gt; <a class="el" href="classDependencyResolver.html">DependencyResolver</a>&lt; T, Compare &gt;::getAncestors </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a list of all values that a given key depends on. </p>

<p class="definition">Definition at line <a class="el" href="DependencyResolver_8h_source.html#l00367">367</a> of file <a class="el" href="DependencyResolver_8h_source.html">DependencyResolver.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  368</span>{</div>
<div class="line"><span class="lineno">  369</span>  std::vector&lt;T&gt; ret_vec;</div>
<div class="line"><span class="lineno">  370</span>  <span class="comment">// Our sorted vector is our work vector but we also return references to it. So we have to make</span></div>
<div class="line"><span class="lineno">  371</span>  <span class="comment">// sure at the end that we restore the original data we had in it</span></div>
<div class="line"><span class="lineno">  372</span>  ret_vec.swap(<a class="code hl_variable" href="classDependencyResolver.html#a51ed8c367cd54a3478836cfc8e9694a5">_sorted_vector</a>);</div>
<div class="line"><span class="lineno">  373</span> </div>
<div class="line"><span class="lineno">  374</span>  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; n : <a class="code hl_variable" href="classDependencyResolver.html#a414e3355d922317d800fe0322046fd9d">_adj</a>)</div>
<div class="line"><span class="lineno">  375</span>    <a class="code hl_variable" href="classDependencyResolver.html#af8b029ffb518b865a78ef0a959fbcaba">_visited</a>[n.first] = <span class="keyword">false</span>;</div>
<div class="line"><span class="lineno">  376</span> </div>
<div class="line"><span class="lineno">  377</span>  <a class="code hl_function" href="classDependencyResolver.html#a22af2a7eeacee6d116e595d68bbfc231">dfsFromNode</a>(key);</div>
<div class="line"><span class="lineno">  378</span> </div>
<div class="line"><span class="lineno">  379</span>  ret_vec.swap(<a class="code hl_variable" href="classDependencyResolver.html#a51ed8c367cd54a3478836cfc8e9694a5">_sorted_vector</a>);</div>
<div class="line"><span class="lineno">  380</span>  mooseAssert(ret_vec.back() == key, <span class="stringliteral">&quot;Our key should be the back of the vector&quot;</span>);</div>
<div class="line"><span class="lineno">  381</span> </div>
<div class="line"><span class="lineno">  382</span>  <span class="keywordflow">return</span> {ret_vec.begin(), ret_vec.end()};</div>
<div class="line"><span class="lineno">  383</span>}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="MeshGeneratorSystem_8C_source.html#l00182">MeshGeneratorSystem::createMeshGeneratorOrder()</a>.</p>

</div>
</div>
<a id="aafefd5021e10ad618f245f8b83bd6c10" name="aafefd5021e10ad618f245f8b83bd6c10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafefd5021e10ad618f245f8b83bd6c10">&#9670;&#160;</a></span>getSortedValues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Compare  = std::less&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; T &gt; &amp; <a class="el" href="classDependencyResolver.html">DependencyResolver</a>&lt; T, Compare &gt;::getSortedValues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function also returns dependency resolved values but with a simpler single vector interface. </p>
<p >Some information may be lost as values at the same level that don't depend on one and other can't be represented in a single vector. This isn't a problem in practice though. </p>

<p class="definition">Definition at line <a class="el" href="DependencyResolver_8h_source.html#l00106">106</a> of file <a class="el" href="DependencyResolver_8h_source.html">DependencyResolver.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  106</span>{ <span class="keywordflow">return</span> <a class="code hl_function" href="classDependencyResolver.html#a6a64ac168507292e64fb0a29d1e7c59e">dfs</a>(); }</div>
<div class="ttc" id="aclassDependencyResolver_html_a6a64ac168507292e64fb0a29d1e7c59e"><div class="ttname"><a href="classDependencyResolver.html#a6a64ac168507292e64fb0a29d1e7c59e">DependencyResolver::dfs</a></div><div class="ttdeci">const std::vector&lt; T &gt; &amp; dfs()</div><div class="ttdoc">Do depth-first search from root nodes to obtain order in which graph nodes should be &quot;executed&quot;.</div><div class="ttdef"><b>Definition:</b> <a href="DependencyResolver_8h_source.html#l00257">DependencyResolver.h:257</a></div></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="MeshGeneratorSystem_8C_source.html#l00182">MeshGeneratorSystem::createMeshGeneratorOrder()</a>, <a class="el" href="FEProblemBase_8C_source.html#l04521">FEProblemBase::executeControls()</a>, and <a class="el" href="Syntax_8C_source.html#l00100">Syntax::getSortedTask()</a>.</p>

</div>
</div>
<a id="aee9fccd7ae6e769c101435fa4125b04c" name="aee9fccd7ae6e769c101435fa4125b04c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee9fccd7ae6e769c101435fa4125b04c">&#9670;&#160;</a></span>getSortedValuesSets()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; std::vector&lt; T &gt; &gt; &amp; <a class="el" href="classDependencyResolver.html">DependencyResolver</a>&lt; T, Compare &gt;::getSortedValuesSets</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector of sets that represent dependency resolved values. </p>
<p >Items in the same subvector have no dependence upon one and other. </p>

<p class="definition">Definition at line <a class="el" href="DependencyResolver_8h_source.html#l00298">298</a> of file <a class="el" href="DependencyResolver_8h_source.html">DependencyResolver.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  299</span>{</div>
<div class="line"><span class="lineno">  300</span>  <a class="code hl_variable" href="classDependencyResolver.html#a3ed2148b0f29b6fd3a0e80a6ded6328b">_ordered_items</a>.clear();</div>
<div class="line"><span class="lineno">  301</span> </div>
<div class="line"><span class="lineno">  302</span>  <span class="keyword">const</span> <span class="keyword">auto</span> &amp; flat_sorted = <a class="code hl_function" href="classDependencyResolver.html#a6a64ac168507292e64fb0a29d1e7c59e">dfs</a>();</div>
<div class="line"><span class="lineno">  303</span> </div>
<div class="line"><span class="lineno">  304</span>  std::vector&lt;T&gt; current_group;</div>
<div class="line"><span class="lineno">  305</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; <span class="keywordtype">object</span> : flat_sorted)</div>
<div class="line"><span class="lineno">  306</span>  {</div>
<div class="line"><span class="lineno">  307</span>    <span class="keywordflow">if</span> (current_group.empty())</div>
<div class="line"><span class="lineno">  308</span>    {</div>
<div class="line"><span class="lineno">  309</span>      current_group.push_back(<span class="keywordtype">object</span>);</div>
<div class="line"><span class="lineno">  310</span>      <span class="keywordflow">continue</span>;</div>
<div class="line"><span class="lineno">  311</span>    }</div>
<div class="line"><span class="lineno">  312</span> </div>
<div class="line"><span class="lineno">  313</span>    <span class="keyword">const</span> <span class="keyword">auto</span> &amp; prev_adj_list = <a class="code hl_variable" href="classDependencyResolver.html#a414e3355d922317d800fe0322046fd9d">_adj</a>[current_group.back()];</div>
<div class="line"><span class="lineno">  314</span>    <span class="keyword">const</span> <span class="keywordtype">bool</span> depends_on_prev =</div>
<div class="line"><span class="lineno">  315</span>        std::find(prev_adj_list.begin(), prev_adj_list.end(), <span class="keywordtype">object</span>) != prev_adj_list.end();</div>
<div class="line"><span class="lineno">  316</span> </div>
<div class="line"><span class="lineno">  317</span>    <span class="keywordflow">if</span> (depends_on_prev)</div>
<div class="line"><span class="lineno">  318</span>    {</div>
<div class="line"><span class="lineno">  319</span>      <a class="code hl_variable" href="classDependencyResolver.html#a3ed2148b0f29b6fd3a0e80a6ded6328b">_ordered_items</a>.push_back({<span class="keywordtype">object</span>});</div>
<div class="line"><span class="lineno">  320</span>      <span class="keyword">auto</span> &amp; finalized_group = <a class="code hl_variable" href="classDependencyResolver.html#a3ed2148b0f29b6fd3a0e80a6ded6328b">_ordered_items</a>.back();</div>
<div class="line"><span class="lineno">  321</span>      <span class="comment">// Swap the current-group into the back of our ordered items container, and now our newest</span></div>
<div class="line"><span class="lineno">  322</span>      <span class="comment">// object becomes the current group</span></div>
<div class="line"><span class="lineno">  323</span>      finalized_group.swap(current_group);</div>
<div class="line"><span class="lineno">  324</span>    }</div>
<div class="line"><span class="lineno">  325</span>    <span class="keywordflow">else</span></div>
<div class="line"><span class="lineno">  326</span>      current_group.push_back(<span class="keywordtype">object</span>);</div>
<div class="line"><span class="lineno">  327</span>  }</div>
<div class="line"><span class="lineno">  328</span> </div>
<div class="line"><span class="lineno">  329</span>  <span class="keywordflow">if</span> (!current_group.empty())</div>
<div class="line"><span class="lineno">  330</span>    <a class="code hl_variable" href="classDependencyResolver.html#a3ed2148b0f29b6fd3a0e80a6ded6328b">_ordered_items</a>.push_back(std::move(current_group));</div>
<div class="line"><span class="lineno">  331</span> </div>
<div class="line"><span class="lineno">  332</span>  <span class="keywordflow">return</span> <a class="code hl_variable" href="classDependencyResolver.html#a3ed2148b0f29b6fd3a0e80a6ded6328b">_ordered_items</a>;</div>
<div class="line"><span class="lineno">  333</span>}</div>
<div class="ttc" id="aclassDependencyResolver_html_a3ed2148b0f29b6fd3a0e80a6ded6328b"><div class="ttname"><a href="classDependencyResolver.html#a3ed2148b0f29b6fd3a0e80a6ded6328b">DependencyResolver::_ordered_items</a></div><div class="ttdeci">std::vector&lt; std::vector&lt; T &gt; &gt; _ordered_items</div><div class="ttdoc">The sorted vector of sets.</div><div class="ttdef"><b>Definition:</b> <a href="DependencyResolver_8h_source.html#l00164">DependencyResolver.h:164</a></div></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="MeshGeneratorSystem_8C_source.html#l00123">MeshGeneratorSystem::createAddedMeshGenerators()</a>, <a class="el" href="MeshGeneratorSystem_8C_source.html#l00182">MeshGeneratorSystem::createMeshGeneratorOrder()</a>, and <a class="el" href="Syntax_8C_source.html#l00114">Syntax::getSortedTaskSet()</a>.</p>

</div>
</div>
<a id="ad1285a55b39b9c36e595e495c0f7602b" name="ad1285a55b39b9c36e595e495c0f7602b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1285a55b39b9c36e595e495c0f7602b">&#9670;&#160;</a></span>insertDependency()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Compare  = std::less&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDependencyResolver.html">DependencyResolver</a>&lt; T, Compare &gt;::insertDependency </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert a dependency pair - the first value or the "key" depends on the second value or the "value". </p>

<p class="definition">Definition at line <a class="el" href="DependencyResolver_8h_source.html#l00065">65</a> of file <a class="el" href="DependencyResolver_8h_source.html">DependencyResolver.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">   65</span>{ <a class="code hl_function" href="classDependencyResolver.html#ae56032fa917214375123913fed093b53">addEdge</a>(value, key); }</div>
<div class="ttc" id="aclassDependencyResolver_html_ae56032fa917214375123913fed093b53"><div class="ttname"><a href="classDependencyResolver.html#ae56032fa917214375123913fed093b53">DependencyResolver::addEdge</a></div><div class="ttdeci">void addEdge(const T &amp;a, const T &amp;b)</div><div class="ttdoc">Add an edge between nodes 'a' and 'b'.</div><div class="ttdef"><b>Definition:</b> <a href="DependencyResolver_8h_source.html#l00207">DependencyResolver.h:207</a></div></div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="Syntax_8C_source.html#l00055">Syntax::addDependency()</a>.</p>

</div>
</div>
<a id="ad3745c7141b9638a42527c218b2bfff8" name="ad3745c7141b9638a42527c218b2bfff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3745c7141b9638a42527c218b2bfff8">&#9670;&#160;</a></span>removeEdge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDependencyResolver.html">DependencyResolver</a>&lt; T, Compare &gt;::removeEdge </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove an edge between nodes 'a' and 'b'. </p>

<p class="definition">Definition at line <a class="el" href="DependencyResolver_8h_source.html#l00218">218</a> of file <a class="el" href="DependencyResolver_8h_source.html">DependencyResolver.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  219</span>{</div>
<div class="line"><span class="lineno">  220</span>  <span class="keyword">auto</span> remove_item = [](<span class="keyword">auto</span> &amp; list, <span class="keyword">const</span> <span class="keyword">auto</span> &amp; item)</div>
<div class="line"><span class="lineno">  221</span>  {</div>
<div class="line"><span class="lineno">  222</span>    <span class="keyword">auto</span> it = std::find(list.begin(), list.end(), item);</div>
<div class="line"><span class="lineno">  223</span>    mooseAssert(it != list.end(), <span class="stringliteral">&quot;We should have this item&quot;</span>);</div>
<div class="line"><span class="lineno">  224</span>    list.erase(it);</div>
<div class="line"><span class="lineno">  225</span>  };</div>
<div class="line"><span class="lineno">  226</span>  remove_item(<a class="code hl_variable" href="classDependencyResolver.html#a414e3355d922317d800fe0322046fd9d">_adj</a>[a], b);</div>
<div class="line"><span class="lineno">  227</span>  remove_item(<a class="code hl_variable" href="classDependencyResolver.html#a6cf5add89ae685ca108990401ac1b70d">_inv_adj</a>[b], a);</div>
<div class="line"><span class="lineno">  228</span>}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="DependencyResolver_8h_source.html#l00070">DependencyResolver&lt; T, Compare &gt;::deleteDependency()</a>.</p>

</div>
</div>
<a id="ab7e01dd6ea07d95dcc65a2bec2ed1490" name="ab7e01dd6ea07d95dcc65a2bec2ed1490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7e01dd6ea07d95dcc65a2bec2ed1490">&#9670;&#160;</a></span>removeEdgesInvolving()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDependencyResolver.html">DependencyResolver</a>&lt; T, Compare &gt;::removeEdgesInvolving </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove edges drawn from 'a'. </p>

<p class="definition">Definition at line <a class="el" href="DependencyResolver_8h_source.html#l00232">232</a> of file <a class="el" href="DependencyResolver_8h_source.html">DependencyResolver.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  233</span>{</div>
<div class="line"><span class="lineno">  234</span>  <span class="keyword">const</span> <span class="keyword">auto</span> &amp; inv_adjs = <a class="code hl_variable" href="classDependencyResolver.html#a6cf5add89ae685ca108990401ac1b70d">_inv_adj</a>[a];</div>
<div class="line"><span class="lineno">  235</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; inv_adj : inv_adjs)</div>
<div class="line"><span class="lineno">  236</span>  {</div>
<div class="line"><span class="lineno">  237</span>    <span class="keyword">auto</span> &amp; adj = <a class="code hl_variable" href="classDependencyResolver.html#a414e3355d922317d800fe0322046fd9d">_adj</a>[inv_adj];</div>
<div class="line"><span class="lineno">  238</span>    <span class="keyword">auto</span> it = std::find(adj.begin(), adj.end(), a);</div>
<div class="line"><span class="lineno">  239</span>    mooseAssert(it != adj.end(), <span class="stringliteral">&quot;Should have reciprocity&quot;</span>);</div>
<div class="line"><span class="lineno">  240</span>    adj.erase(it);</div>
<div class="line"><span class="lineno">  241</span>  }</div>
<div class="line"><span class="lineno">  242</span> </div>
<div class="line"><span class="lineno">  243</span>  <a class="code hl_variable" href="classDependencyResolver.html#a6cf5add89ae685ca108990401ac1b70d">_inv_adj</a>[a].clear();</div>
<div class="line"><span class="lineno">  244</span>}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="DependencyResolver_8h_source.html#l00075">DependencyResolver&lt; T, Compare &gt;::deleteDependenciesOfKey()</a>.</p>

</div>
</div>
<a id="a9eaa182b142564fc994ef61cbf0c8a32" name="a9eaa182b142564fc994ef61cbf0c8a32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eaa182b142564fc994ef61cbf0c8a32">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Compare  = std::less&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classDependencyResolver.html">DependencyResolver</a>&lt; T, Compare &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of unique items stored in the dependency resolver. </p>
<p >lindsayad comment: does it really return the number of <em>unique</em> items? </p>

<p class="definition">Definition at line <a class="el" href="DependencyResolver_8h_source.html#l00135">135</a> of file <a class="el" href="DependencyResolver_8h_source.html">DependencyResolver.h</a>.</p>
<div class="fragment"><div class="line"><span class="lineno">  135</span>{ <span class="keywordflow">return</span> <a class="code hl_variable" href="classDependencyResolver.html#a51ed8c367cd54a3478836cfc8e9694a5">_sorted_vector</a>.size(); }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="MeshGeneratorSystem_8C_source.html#l00182">MeshGeneratorSystem::createMeshGeneratorOrder()</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a5bdd64f173a3ee76db6f8cfad4c6f9ec" name="a5bdd64f173a3ee76db6f8cfad4c6f9ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bdd64f173a3ee76db6f8cfad4c6f9ec">&#9670;&#160;</a></span>CyclicDependencyException&lt; T, Compare &gt;</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Compare  = std::less&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classCyclicDependencyException.html">CyclicDependencyException</a>&lt; T, Compare &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="DependencyResolver_8h_source.html#l00172">172</a> of file <a class="el" href="DependencyResolver_8h_source.html">DependencyResolver.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a414e3355d922317d800fe0322046fd9d" name="a414e3355d922317d800fe0322046fd9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a414e3355d922317d800fe0322046fd9d">&#9670;&#160;</a></span>_adj</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Compare  = std::less&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;T, std::list&lt;T&gt;, Compare&gt; <a class="el" href="classDependencyResolver.html">DependencyResolver</a>&lt; T, Compare &gt;::_adj</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>adjacency lists (from leaves to roots) </p>

<p class="definition">Definition at line <a class="el" href="DependencyResolver_8h_source.html#l00154">154</a> of file <a class="el" href="DependencyResolver_8h_source.html">DependencyResolver.h</a>.</p>

</div>
</div>
<a id="a1fcf207e6e4e40b8e452549e6c7d67a6" name="a1fcf207e6e4e40b8e452549e6c7d67a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fcf207e6e4e40b8e452549e6c7d67a6">&#9670;&#160;</a></span>_circular_node</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Compare  = std::less&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classDependencyResolver.html">DependencyResolver</a>&lt; T, Compare &gt;::_circular_node = T{}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Data member for storing nodes that appear circularly in the graph. </p>

<p class="definition">Definition at line <a class="el" href="DependencyResolver_8h_source.html#l00172">172</a> of file <a class="el" href="DependencyResolver_8h_source.html">DependencyResolver.h</a>.</p>

</div>
</div>
<a id="a8ddc7b6d88998dc78c3e4a2a59c87a9f" name="a8ddc7b6d88998dc78c3e4a2a59c87a9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ddc7b6d88998dc78c3e4a2a59c87a9f">&#9670;&#160;</a></span>_insertion_order</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Compare  = std::less&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; <a class="el" href="classDependencyResolver.html">DependencyResolver</a>&lt; T, Compare &gt;::_insertion_order</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Container for keeping track of the insertion order. </p>
<p >We will use this to determine iteration order because it is essential that iteration order be sync'd across multiple processes. Iterating over maps with pointer keys, for example, can be out of sync on multiple processes. If dependency resolver memory usage shows up in profiling, we can consider making this a container of reference wrappers </p>

<p class="definition">Definition at line <a class="el" href="DependencyResolver_8h_source.html#l00170">170</a> of file <a class="el" href="DependencyResolver_8h_source.html">DependencyResolver.h</a>.</p>

</div>
</div>
<a id="a6cf5add89ae685ca108990401ac1b70d" name="a6cf5add89ae685ca108990401ac1b70d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cf5add89ae685ca108990401ac1b70d">&#9670;&#160;</a></span>_inv_adj</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Compare  = std::less&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;T, std::list&lt;T&gt;, Compare&gt; <a class="el" href="classDependencyResolver.html">DependencyResolver</a>&lt; T, Compare &gt;::_inv_adj</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>adjacency lists (from roots to leaves) </p>

<p class="definition">Definition at line <a class="el" href="DependencyResolver_8h_source.html#l00156">156</a> of file <a class="el" href="DependencyResolver_8h_source.html">DependencyResolver.h</a>.</p>

</div>
</div>
<a id="a3ed2148b0f29b6fd3a0e80a6ded6328b" name="a3ed2148b0f29b6fd3a0e80a6ded6328b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ed2148b0f29b6fd3a0e80a6ded6328b">&#9670;&#160;</a></span>_ordered_items</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Compare  = std::less&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;T&gt; &gt; <a class="el" href="classDependencyResolver.html">DependencyResolver</a>&lt; T, Compare &gt;::_ordered_items</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The sorted vector of sets. </p>

<p class="definition">Definition at line <a class="el" href="DependencyResolver_8h_source.html#l00164">164</a> of file <a class="el" href="DependencyResolver_8h_source.html">DependencyResolver.h</a>.</p>

</div>
</div>
<a id="a1d5743037e1637fb68fd1dedfdbf8c93" name="a1d5743037e1637fb68fd1dedfdbf8c93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d5743037e1637fb68fd1dedfdbf8c93">&#9670;&#160;</a></span>_rec_stack</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Compare  = std::less&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;T, bool, Compare&gt; <a class="el" href="classDependencyResolver.html">DependencyResolver</a>&lt; T, Compare &gt;::_rec_stack</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>recursive stack </p>

<p class="definition">Definition at line <a class="el" href="DependencyResolver_8h_source.html#l00160">160</a> of file <a class="el" href="DependencyResolver_8h_source.html">DependencyResolver.h</a>.</p>

</div>
</div>
<a id="a51ed8c367cd54a3478836cfc8e9694a5" name="a51ed8c367cd54a3478836cfc8e9694a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51ed8c367cd54a3478836cfc8e9694a5">&#9670;&#160;</a></span>_sorted_vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Compare  = std::less&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; <a class="el" href="classDependencyResolver.html">DependencyResolver</a>&lt; T, Compare &gt;::_sorted_vector</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>"sorted" vector of nodes </p>

<p class="definition">Definition at line <a class="el" href="DependencyResolver_8h_source.html#l00162">162</a> of file <a class="el" href="DependencyResolver_8h_source.html">DependencyResolver.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="DependencyResolver_8h_source.html#l00135">DependencyResolver&lt; T, Compare &gt;::size()</a>.</p>

</div>
</div>
<a id="af8b029ffb518b865a78ef0a959fbcaba" name="af8b029ffb518b865a78ef0a959fbcaba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8b029ffb518b865a78ef0a959fbcaba">&#9670;&#160;</a></span>_visited</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class Compare  = std::less&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;T, bool, Compare&gt; <a class="el" href="classDependencyResolver.html">DependencyResolver</a>&lt; T, Compare &gt;::_visited</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>vector of visited nodes </p>

<p class="definition">Definition at line <a class="el" href="DependencyResolver_8h_source.html#l00158">158</a> of file <a class="el" href="DependencyResolver_8h_source.html">DependencyResolver.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>moose/framework/include/utils/<a class="el" href="DependencyResolver_8h_source.html">DependencyResolver.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Dec 24 2023 00:21:40 for Zapdos by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>

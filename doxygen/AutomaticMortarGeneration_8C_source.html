<!-- HTML header for doxygen 1.9.5-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Zapdos: moose/framework/src/constraints/AutomaticMortarGeneration.C Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
    <a href="https://shannon-lab.github.io/zapdos" style="text-decoration:none"><div id="projectname">Zapdos</div></a><div id="projectname">
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_4c7d3be2d60f4d6ad3d0ee61864d0537.html">moose</a></li><li class="navelem"><a class="el" href="dir_6f4eeb6ddb4ae754f551cb2d3dec9e8e.html">framework</a></li><li class="navelem"><a class="el" href="dir_bfb280a6c1c8c85a152345a0f6a025dc.html">src</a></li><li class="navelem"><a class="el" href="dir_69a1bc1f81c438b5f7053079630efdbb.html">constraints</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle"><div class="title">AutomaticMortarGeneration.C</div></div>
</div><!--header-->
<div class="contents">
<a href="AutomaticMortarGeneration_8C.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a id="l00001" name="l00001"></a><span class="lineno">    1</span><span class="comment">//* This file is part of the MOOSE framework</span></div>
<div class="line"><a id="l00002" name="l00002"></a><span class="lineno">    2</span><span class="comment">//* https://www.mooseframework.org</span></div>
<div class="line"><a id="l00003" name="l00003"></a><span class="lineno">    3</span><span class="comment">//*</span></div>
<div class="line"><a id="l00004" name="l00004"></a><span class="lineno">    4</span><span class="comment">//* All rights reserved, see COPYRIGHT for full restrictions</span></div>
<div class="line"><a id="l00005" name="l00005"></a><span class="lineno">    5</span><span class="comment">//* https://github.com/idaholab/moose/blob/master/COPYRIGHT</span></div>
<div class="line"><a id="l00006" name="l00006"></a><span class="lineno">    6</span><span class="comment">//*</span></div>
<div class="line"><a id="l00007" name="l00007"></a><span class="lineno">    7</span><span class="comment">//* Licensed under LGPL 2.1, please see LICENSE for details</span></div>
<div class="line"><a id="l00008" name="l00008"></a><span class="lineno">    8</span><span class="comment">//* https://www.gnu.org/licenses/lgpl-2.1.html</span></div>
<div class="line"><a id="l00009" name="l00009"></a><span class="lineno">    9</span> </div>
<div class="line"><a id="l00010" name="l00010"></a><span class="lineno">   10</span><span class="preprocessor">#include &quot;<a class="code" href="AutomaticMortarGeneration_8h.html">AutomaticMortarGeneration.h</a>&quot;</span></div>
<div class="line"><a id="l00011" name="l00011"></a><span class="lineno">   11</span><span class="preprocessor">#include &quot;<a class="code" href="MortarSegmentInfo_8h.html">MortarSegmentInfo.h</a>&quot;</span></div>
<div class="line"><a id="l00012" name="l00012"></a><span class="lineno">   12</span><span class="preprocessor">#include &quot;<a class="code" href="NanoflannMeshAdaptor_8h.html">NanoflannMeshAdaptor.h</a>&quot;</span></div>
<div class="line"><a id="l00013" name="l00013"></a><span class="lineno">   13</span><span class="preprocessor">#include &quot;<a class="code" href="MooseError_8h.html">MooseError.h</a>&quot;</span></div>
<div class="line"><a id="l00014" name="l00014"></a><span class="lineno">   14</span><span class="preprocessor">#include &quot;<a class="code" href="MooseTypes_8h.html">MooseTypes.h</a>&quot;</span></div>
<div class="line"><a id="l00015" name="l00015"></a><span class="lineno">   15</span><span class="preprocessor">#include &quot;<a class="code" href="MooseLagrangeHelpers_8h.html">MooseLagrangeHelpers.h</a>&quot;</span></div>
<div class="line"><a id="l00016" name="l00016"></a><span class="lineno">   16</span><span class="preprocessor">#include &quot;<a class="code" href="MortarSegmentHelper_8h.html">MortarSegmentHelper.h</a>&quot;</span></div>
<div class="line"><a id="l00017" name="l00017"></a><span class="lineno">   17</span><span class="preprocessor">#include &quot;<a class="code" href="FormattedTable_8h.html">FormattedTable.h</a>&quot;</span></div>
<div class="line"><a id="l00018" name="l00018"></a><span class="lineno">   18</span><span class="preprocessor">#include &quot;<a class="code" href="FEProblemBase_8h.html">FEProblemBase.h</a>&quot;</span></div>
<div class="line"><a id="l00019" name="l00019"></a><span class="lineno">   19</span><span class="preprocessor">#include &quot;<a class="code" href="DisplacedProblem_8h.html">DisplacedProblem.h</a>&quot;</span></div>
<div class="line"><a id="l00020" name="l00020"></a><span class="lineno">   20</span><span class="preprocessor">#include &quot;<a class="code" href="Output_8h.html">Output.h</a>&quot;</span></div>
<div class="line"><a id="l00021" name="l00021"></a><span class="lineno">   21</span> </div>
<div class="line"><a id="l00022" name="l00022"></a><span class="lineno">   22</span><span class="preprocessor">#include &quot;libmesh/mesh_tools.h&quot;</span></div>
<div class="line"><a id="l00023" name="l00023"></a><span class="lineno">   23</span><span class="preprocessor">#include &quot;libmesh/explicit_system.h&quot;</span></div>
<div class="line"><a id="l00024" name="l00024"></a><span class="lineno">   24</span><span class="preprocessor">#include &quot;libmesh/numeric_vector.h&quot;</span></div>
<div class="line"><a id="l00025" name="l00025"></a><span class="lineno">   25</span><span class="preprocessor">#include &quot;libmesh/elem.h&quot;</span></div>
<div class="line"><a id="l00026" name="l00026"></a><span class="lineno">   26</span><span class="preprocessor">#include &quot;libmesh/node.h&quot;</span></div>
<div class="line"><a id="l00027" name="l00027"></a><span class="lineno">   27</span><span class="preprocessor">#include &quot;libmesh/dof_map.h&quot;</span></div>
<div class="line"><a id="l00028" name="l00028"></a><span class="lineno">   28</span><span class="preprocessor">#include &quot;libmesh/edge_edge2.h&quot;</span></div>
<div class="line"><a id="l00029" name="l00029"></a><span class="lineno">   29</span><span class="preprocessor">#include &quot;libmesh/edge_edge3.h&quot;</span></div>
<div class="line"><a id="l00030" name="l00030"></a><span class="lineno">   30</span><span class="preprocessor">#include &quot;libmesh/face_tri3.h&quot;</span></div>
<div class="line"><a id="l00031" name="l00031"></a><span class="lineno">   31</span><span class="preprocessor">#include &quot;libmesh/face_quad4.h&quot;</span></div>
<div class="line"><a id="l00032" name="l00032"></a><span class="lineno">   32</span><span class="preprocessor">#include &quot;libmesh/exodusII_io.h&quot;</span></div>
<div class="line"><a id="l00033" name="l00033"></a><span class="lineno">   33</span><span class="preprocessor">#include &quot;libmesh/quadrature_gauss.h&quot;</span></div>
<div class="line"><a id="l00034" name="l00034"></a><span class="lineno">   34</span><span class="preprocessor">#include &quot;libmesh/quadrature_nodal.h&quot;</span></div>
<div class="line"><a id="l00035" name="l00035"></a><span class="lineno">   35</span><span class="preprocessor">#include &quot;libmesh/distributed_mesh.h&quot;</span></div>
<div class="line"><a id="l00036" name="l00036"></a><span class="lineno">   36</span><span class="preprocessor">#include &quot;libmesh/replicated_mesh.h&quot;</span></div>
<div class="line"><a id="l00037" name="l00037"></a><span class="lineno">   37</span><span class="preprocessor">#include &quot;libmesh/enum_to_string.h&quot;</span></div>
<div class="line"><a id="l00038" name="l00038"></a><span class="lineno">   38</span><span class="preprocessor">#include &quot;libmesh/statistics.h&quot;</span></div>
<div class="line"><a id="l00039" name="l00039"></a><span class="lineno">   39</span><span class="preprocessor">#include &quot;libmesh/equation_systems.h&quot;</span></div>
<div class="line"><a id="l00040" name="l00040"></a><span class="lineno">   40</span> </div>
<div class="line"><a id="l00041" name="l00041"></a><span class="lineno">   41</span><span class="preprocessor">#include &quot;metaphysicl/dualnumber.h&quot;</span></div>
<div class="line"><a id="l00042" name="l00042"></a><span class="lineno">   42</span> </div>
<div class="line"><a id="l00043" name="l00043"></a><span class="lineno">   43</span><span class="preprocessor">#include &quot;timpi/communicator.h&quot;</span></div>
<div class="line"><a id="l00044" name="l00044"></a><span class="lineno">   44</span><span class="preprocessor">#include &quot;timpi/parallel_sync.h&quot;</span></div>
<div class="line"><a id="l00045" name="l00045"></a><span class="lineno">   45</span> </div>
<div class="line"><a id="l00046" name="l00046"></a><span class="lineno">   46</span><span class="preprocessor">#include &lt;array&gt;</span></div>
<div class="line"><a id="l00047" name="l00047"></a><span class="lineno">   47</span><span class="preprocessor">#include &lt;algorithm&gt;</span></div>
<div class="line"><a id="l00048" name="l00048"></a><span class="lineno">   48</span> </div>
<div class="line"><a id="l00049" name="l00049"></a><span class="lineno">   49</span><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacelibMesh.html">libMesh</a>;</div>
<div class="line"><a id="l00050" name="l00050"></a><span class="lineno">   50</span><span class="keyword">using </span><a class="code hl_class" href="classMetaPhysicL_1_1DualNumber.html">MetaPhysicL::DualNumber</a>;</div>
<div class="line"><a id="l00051" name="l00051"></a><span class="lineno">   51</span> </div>
<div class="line"><a id="l00052" name="l00052"></a><span class="lineno">   52</span><span class="comment">// Make newer nanoflann API spelling compatible with older nanoflann</span></div>
<div class="line"><a id="l00053" name="l00053"></a><span class="lineno">   53</span><span class="comment">// versions</span></div>
<div class="line"><a id="l00054" name="l00054"></a><span class="lineno">   54</span><span class="preprocessor">#if NANOFLANN_VERSION &lt; 0x150</span></div>
<div class="line"><a id="l00055" name="l00055"></a><span class="lineno"><a class="line" href="namespacenanoflann.html">   55</a></span><span class="keyword">namespace </span><a class="code hl_namespace" href="namespacenanoflann.html">nanoflann</a></div>
<div class="line"><a id="l00056" name="l00056"></a><span class="lineno">   56</span>{</div>
<div class="line"><a id="l00057" name="l00057"></a><span class="lineno"><a class="line" href="namespacenanoflann.html#a7475277cf1d06434e352ade6f35de645">   57</a></span><span class="keyword">typedef</span> SearchParams <a class="code hl_typedef" href="namespacenanoflann.html#a7475277cf1d06434e352ade6f35de645">SearchParameters</a>;</div>
<div class="line"><a id="l00058" name="l00058"></a><span class="lineno">   58</span>}</div>
<div class="line"><a id="l00059" name="l00059"></a><span class="lineno">   59</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l00060" name="l00060"></a><span class="lineno">   60</span> </div>
<div class="line"><a id="l00061" name="l00061"></a><span class="lineno"><a class="line" href="classMortarNodalGeometryOutput.html">   61</a></span><span class="keyword">class </span><a class="code hl_class" href="classMortarNodalGeometryOutput.html">MortarNodalGeometryOutput</a> : <span class="keyword">public</span> <a class="code hl_class" href="classOutput.html">Output</a></div>
<div class="line"><a id="l00062" name="l00062"></a><span class="lineno">   62</span>{</div>
<div class="line"><a id="l00063" name="l00063"></a><span class="lineno">   63</span><span class="keyword">public</span>:</div>
<div class="line"><a id="l00064" name="l00064"></a><span class="lineno"><a class="line" href="classMortarNodalGeometryOutput.html#a6bf8458c621e9dba746029f0f658eab1">   64</a></span>  <span class="keyword">static</span> <a class="code hl_class" href="classInputParameters.html">InputParameters</a> <a class="code hl_function" href="classMortarNodalGeometryOutput.html#a6bf8458c621e9dba746029f0f658eab1">validParams</a>()</div>
<div class="line"><a id="l00065" name="l00065"></a><span class="lineno">   65</span>  {</div>
<div class="line"><a id="l00066" name="l00066"></a><span class="lineno">   66</span>    <span class="keyword">auto</span> params = <a class="code hl_function" href="classOutput.html#a56c3206b7b50dfec2c3ca0745399cee3">Output::validParams</a>();</div>
<div class="line"><a id="l00067" name="l00067"></a><span class="lineno">   67</span>    params.addPrivateParam&lt;<a class="code hl_class" href="classAutomaticMortarGeneration.html">AutomaticMortarGeneration</a> *&gt;(<span class="stringliteral">&quot;_amg&quot;</span>, <span class="keyword">nullptr</span>);</div>
<div class="line"><a id="l00068" name="l00068"></a><span class="lineno">   68</span>    params.addPrivateParam&lt;<a class="code hl_class" href="classMooseApp.html">MooseApp</a> *&gt;(<span class="stringliteral">&quot;_moose_app&quot;</span>, <span class="keyword">nullptr</span>);</div>
<div class="line"><a id="l00069" name="l00069"></a><span class="lineno">   69</span>    params.set&lt;std::string&gt;(<span class="stringliteral">&quot;_type&quot;</span>) = <span class="stringliteral">&quot;MortarNodalGeometryOutput&quot;</span>;</div>
<div class="line"><a id="l00070" name="l00070"></a><span class="lineno">   70</span>    <span class="keywordflow">return</span> params;</div>
<div class="line"><a id="l00071" name="l00071"></a><span class="lineno">   71</span>  };</div>
<div class="line"><a id="l00072" name="l00072"></a><span class="lineno">   72</span> </div>
<div class="line"><a id="l00073" name="l00073"></a><span class="lineno"><a class="line" href="classMortarNodalGeometryOutput.html#a0c5e0029e42c789ca8af364a7fe59564">   73</a></span>  <a class="code hl_function" href="classMortarNodalGeometryOutput.html#a0c5e0029e42c789ca8af364a7fe59564">MortarNodalGeometryOutput</a>(<span class="keyword">const</span> <a class="code hl_class" href="classInputParameters.html">InputParameters</a> &amp; params)</div>
<div class="line"><a id="l00074" name="l00074"></a><span class="lineno">   74</span>    : <a class="code hl_class" href="classOutput.html">Output</a>(params), <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#aa3ca853594cf98bdd87e5315b4357c9b">_amg</a>(*<a class="code hl_function" href="classMooseBaseParameterInterface.html#a518f1157d948ba2f02807f76f102849e">getCheckedPointerParam</a>&lt;<a class="code hl_class" href="classAutomaticMortarGeneration.html">AutomaticMortarGeneration</a> *&gt;(<span class="stringliteral">&quot;_amg&quot;</span>))</div>
<div class="line"><a id="l00075" name="l00075"></a><span class="lineno">   75</span>  {</div>
<div class="line"><a id="l00076" name="l00076"></a><span class="lineno">   76</span>  }</div>
<div class="line"><a id="l00077" name="l00077"></a><span class="lineno">   77</span> </div>
<div class="line"><a id="l00078" name="l00078"></a><span class="lineno"><a class="line" href="classMortarNodalGeometryOutput.html#af9de64b107fd3822520533f33cd74b67">   78</a></span>  <span class="keywordtype">void</span> <a class="code hl_function" href="classMortarNodalGeometryOutput.html#af9de64b107fd3822520533f33cd74b67">output</a>()<span class="keyword"> override</span></div>
<div class="line"><a id="l00079" name="l00079"></a><span class="lineno">   79</span><span class="keyword">  </span>{</div>
<div class="line"><a id="l00080" name="l00080"></a><span class="lineno">   80</span>    <span class="comment">// Must call compute_nodal_geometry first!</span></div>
<div class="line"><a id="l00081" name="l00081"></a><span class="lineno">   81</span>    <span class="keywordflow">if</span> (<a class="code hl_variable" href="classMortarNodalGeometryOutput.html#aa3ca853594cf98bdd87e5315b4357c9b">_amg</a>.<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a06fb539aea2e63f3b48a6e1d41a2f568">_secondary_node_to_nodal_normal</a>.empty() ||</div>
<div class="line"><a id="l00082" name="l00082"></a><span class="lineno">   82</span>        <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#aa3ca853594cf98bdd87e5315b4357c9b">_amg</a>.<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a8120c89f18fdff39621fa512087a2da3">_secondary_node_to_hh_nodal_tangents</a>.empty())</div>
<div class="line"><a id="l00083" name="l00083"></a><span class="lineno">   83</span>      <a class="code hl_function" href="classMooseBaseErrorInterface.html#add080f0d929c93db62fe02eac6f7f5da">mooseError</a>(<span class="stringliteral">&quot;No entries found in the secondary node -&gt; nodal geometry map.&quot;</span>);</div>
<div class="line"><a id="l00084" name="l00084"></a><span class="lineno">   84</span> </div>
<div class="line"><a id="l00085" name="l00085"></a><span class="lineno">   85</span>    <span class="keyword">auto</span> &amp; problem = <a class="code hl_variable" href="classMooseObject.html#a7e7be2880d321492519ec806996ed365">_app</a>.<a class="code hl_function" href="classMooseApp.html#a9901a98a17c8276cc00b4841584bb561">feProblem</a>();</div>
<div class="line"><a id="l00086" name="l00086"></a><span class="lineno">   86</span>    <span class="keyword">auto</span> &amp; subproblem = <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#aa3ca853594cf98bdd87e5315b4357c9b">_amg</a>.<a class="code hl_variable" href="classAutomaticMortarGeneration.html#ac1faa015bf0201e49ab822e50b713fc1">_on_displaced</a></div>
<div class="line"><a id="l00087" name="l00087"></a><span class="lineno">   87</span>                            ? <span class="keyword">static_cast&lt;</span><a class="code hl_class" href="classSubProblem.html">SubProblem</a> &amp;<span class="keyword">&gt;</span>(*problem.getDisplacedProblem())</div>
<div class="line"><a id="l00088" name="l00088"></a><span class="lineno">   88</span>                            : <span class="keyword">static_cast&lt;</span><a class="code hl_class" href="classSubProblem.html">SubProblem</a> &amp;<span class="keyword">&gt;</span>(problem);</div>
<div class="line"><a id="l00089" name="l00089"></a><span class="lineno">   89</span>    <span class="keyword">auto</span> &amp; nodal_normals_es = subproblem.<a class="code hl_function" href="classSubProblem.html#aaf79a48be31726ec7871a85918735d26">es</a>();</div>
<div class="line"><a id="l00090" name="l00090"></a><span class="lineno">   90</span> </div>
<div class="line"><a id="l00091" name="l00091"></a><span class="lineno">   91</span>    <span class="keyword">const</span> std::string nodal_normals_sys_name = <span class="stringliteral">&quot;nodal_normals&quot;</span>;</div>
<div class="line"><a id="l00092" name="l00092"></a><span class="lineno">   92</span> </div>
<div class="line"><a id="l00093" name="l00093"></a><span class="lineno">   93</span>    <span class="keywordflow">if</span> (!<a class="code hl_variable" href="classMortarNodalGeometryOutput.html#ad80dfc2071b28d414b231b585612ee1b">_nodal_normals_system</a>)</div>
<div class="line"><a id="l00094" name="l00094"></a><span class="lineno">   94</span>    {</div>
<div class="line"><a id="l00095" name="l00095"></a><span class="lineno">   95</span>      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> s : make_range(nodal_normals_es.n_systems()))</div>
<div class="line"><a id="l00096" name="l00096"></a><span class="lineno">   96</span>        <span class="keywordflow">if</span> (!nodal_normals_es.get_system(s).is_initialized())</div>
<div class="line"><a id="l00097" name="l00097"></a><span class="lineno">   97</span>          <span class="comment">// This is really early on in the simulation and the systems have not been initialized. We</span></div>
<div class="line"><a id="l00098" name="l00098"></a><span class="lineno">   98</span>          <span class="comment">// thus need to avoid calling reinit on systems that haven&#39;t even had their first init yet</span></div>
<div class="line"><a id="l00099" name="l00099"></a><span class="lineno">   99</span>          <span class="keywordflow">return</span>;</div>
<div class="line"><a id="l00100" name="l00100"></a><span class="lineno">  100</span> </div>
<div class="line"><a id="l00101" name="l00101"></a><span class="lineno">  101</span>      <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#ad80dfc2071b28d414b231b585612ee1b">_nodal_normals_system</a> =</div>
<div class="line"><a id="l00102" name="l00102"></a><span class="lineno">  102</span>          &amp;nodal_normals_es.template add_system&lt;ExplicitSystem&gt;(nodal_normals_sys_name);</div>
<div class="line"><a id="l00103" name="l00103"></a><span class="lineno">  103</span>      <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#abacf3fe882f67ac24674bb7617a266a8">_nnx_var_num</a> = <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#ad80dfc2071b28d414b231b585612ee1b">_nodal_normals_system</a>-&gt;add_variable(<span class="stringliteral">&quot;nodal_normal_x&quot;</span>, FEType(FIRST, LAGRANGE)),</div>
<div class="line"><a id="l00104" name="l00104"></a><span class="lineno">  104</span>      <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#a59e55d699cc43d82ea14eb460f66bc92">_nny_var_num</a> = <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#ad80dfc2071b28d414b231b585612ee1b">_nodal_normals_system</a>-&gt;add_variable(<span class="stringliteral">&quot;nodal_normal_y&quot;</span>, FEType(FIRST, LAGRANGE));</div>
<div class="line"><a id="l00105" name="l00105"></a><span class="lineno">  105</span>      <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#ab203b6ac1578045882f4076cce002b30">_nnz_var_num</a> = <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#ad80dfc2071b28d414b231b585612ee1b">_nodal_normals_system</a>-&gt;add_variable(<span class="stringliteral">&quot;nodal_normal_z&quot;</span>, FEType(FIRST, LAGRANGE));</div>
<div class="line"><a id="l00106" name="l00106"></a><span class="lineno">  106</span> </div>
<div class="line"><a id="l00107" name="l00107"></a><span class="lineno">  107</span>      <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#a0ffdd24bb6e71f5af85dba0950d9e47f">_t1x_var_num</a> =</div>
<div class="line"><a id="l00108" name="l00108"></a><span class="lineno">  108</span>          <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#ad80dfc2071b28d414b231b585612ee1b">_nodal_normals_system</a>-&gt;add_variable(<span class="stringliteral">&quot;nodal_tangent_1_x&quot;</span>, FEType(FIRST, LAGRANGE)),</div>
<div class="line"><a id="l00109" name="l00109"></a><span class="lineno">  109</span>      <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#af12ccab062fed7c8002825344263f546">_t1y_var_num</a> =</div>
<div class="line"><a id="l00110" name="l00110"></a><span class="lineno">  110</span>          <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#ad80dfc2071b28d414b231b585612ee1b">_nodal_normals_system</a>-&gt;add_variable(<span class="stringliteral">&quot;nodal_tangent_1_y&quot;</span>, FEType(FIRST, LAGRANGE));</div>
<div class="line"><a id="l00111" name="l00111"></a><span class="lineno">  111</span>      <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#a0eb71ab627d8028efeb1bbf05212dc9e">_t1z_var_num</a> =</div>
<div class="line"><a id="l00112" name="l00112"></a><span class="lineno">  112</span>          <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#ad80dfc2071b28d414b231b585612ee1b">_nodal_normals_system</a>-&gt;add_variable(<span class="stringliteral">&quot;nodal_tangent_1_z&quot;</span>, FEType(FIRST, LAGRANGE));</div>
<div class="line"><a id="l00113" name="l00113"></a><span class="lineno">  113</span> </div>
<div class="line"><a id="l00114" name="l00114"></a><span class="lineno">  114</span>      <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#ac1921976fee38185201ab182c5b56f26">_t2x_var_num</a> =</div>
<div class="line"><a id="l00115" name="l00115"></a><span class="lineno">  115</span>          <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#ad80dfc2071b28d414b231b585612ee1b">_nodal_normals_system</a>-&gt;add_variable(<span class="stringliteral">&quot;nodal_tangent_2_x&quot;</span>, FEType(FIRST, LAGRANGE)),</div>
<div class="line"><a id="l00116" name="l00116"></a><span class="lineno">  116</span>      <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#a5e5bd72ed60f43ecc163b6dd89ef1681">_t2y_var_num</a> =</div>
<div class="line"><a id="l00117" name="l00117"></a><span class="lineno">  117</span>          <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#ad80dfc2071b28d414b231b585612ee1b">_nodal_normals_system</a>-&gt;add_variable(<span class="stringliteral">&quot;nodal_tangent_2_y&quot;</span>, FEType(FIRST, LAGRANGE));</div>
<div class="line"><a id="l00118" name="l00118"></a><span class="lineno">  118</span>      <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#a43a1532163c9c3ae49af3368d14c9a5b">_t2z_var_num</a> =</div>
<div class="line"><a id="l00119" name="l00119"></a><span class="lineno">  119</span>          <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#ad80dfc2071b28d414b231b585612ee1b">_nodal_normals_system</a>-&gt;add_variable(<span class="stringliteral">&quot;nodal_tangent_2_z&quot;</span>, FEType(FIRST, LAGRANGE));</div>
<div class="line"><a id="l00120" name="l00120"></a><span class="lineno">  120</span>      nodal_normals_es.reinit();</div>
<div class="line"><a id="l00121" name="l00121"></a><span class="lineno">  121</span>    }</div>
<div class="line"><a id="l00122" name="l00122"></a><span class="lineno">  122</span> </div>
<div class="line"><a id="l00123" name="l00123"></a><span class="lineno">  123</span>    <span class="keyword">const</span> DofMap &amp; dof_map = <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#ad80dfc2071b28d414b231b585612ee1b">_nodal_normals_system</a>-&gt;get_dof_map();</div>
<div class="line"><a id="l00124" name="l00124"></a><span class="lineno">  124</span>    std::vector&lt;dof_id_type&gt; dof_indices_nnx, dof_indices_nny, dof_indices_nnz;</div>
<div class="line"><a id="l00125" name="l00125"></a><span class="lineno">  125</span>    std::vector&lt;dof_id_type&gt; dof_indices_t1x, dof_indices_t1y, dof_indices_t1z;</div>
<div class="line"><a id="l00126" name="l00126"></a><span class="lineno">  126</span>    std::vector&lt;dof_id_type&gt; dof_indices_t2x, dof_indices_t2y, dof_indices_t2z;</div>
<div class="line"><a id="l00127" name="l00127"></a><span class="lineno">  127</span> </div>
<div class="line"><a id="l00128" name="l00128"></a><span class="lineno">  128</span>    <span class="keywordflow">for</span> (MeshBase::const_element_iterator el = <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#aa3ca853594cf98bdd87e5315b4357c9b">_amg</a>.<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.elements_begin(),</div>
<div class="line"><a id="l00129" name="l00129"></a><span class="lineno">  129</span>                                          end_el = <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#aa3ca853594cf98bdd87e5315b4357c9b">_amg</a>.<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.elements_end();</div>
<div class="line"><a id="l00130" name="l00130"></a><span class="lineno">  130</span>         el != end_el;</div>
<div class="line"><a id="l00131" name="l00131"></a><span class="lineno">  131</span>         ++el)</div>
<div class="line"><a id="l00132" name="l00132"></a><span class="lineno">  132</span>    {</div>
<div class="line"><a id="l00133" name="l00133"></a><span class="lineno">  133</span>      <span class="keyword">const</span> Elem * elem = *el;</div>
<div class="line"><a id="l00134" name="l00134"></a><span class="lineno">  134</span> </div>
<div class="line"><a id="l00135" name="l00135"></a><span class="lineno">  135</span>      <span class="comment">// Get the nodal dofs for this Elem.</span></div>
<div class="line"><a id="l00136" name="l00136"></a><span class="lineno">  136</span>      dof_map.dof_indices(elem, dof_indices_nnx, <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#abacf3fe882f67ac24674bb7617a266a8">_nnx_var_num</a>);</div>
<div class="line"><a id="l00137" name="l00137"></a><span class="lineno">  137</span>      dof_map.dof_indices(elem, dof_indices_nny, <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#a59e55d699cc43d82ea14eb460f66bc92">_nny_var_num</a>);</div>
<div class="line"><a id="l00138" name="l00138"></a><span class="lineno">  138</span>      dof_map.dof_indices(elem, dof_indices_nnz, <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#ab203b6ac1578045882f4076cce002b30">_nnz_var_num</a>);</div>
<div class="line"><a id="l00139" name="l00139"></a><span class="lineno">  139</span> </div>
<div class="line"><a id="l00140" name="l00140"></a><span class="lineno">  140</span>      dof_map.dof_indices(elem, dof_indices_t1x, <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#a0ffdd24bb6e71f5af85dba0950d9e47f">_t1x_var_num</a>);</div>
<div class="line"><a id="l00141" name="l00141"></a><span class="lineno">  141</span>      dof_map.dof_indices(elem, dof_indices_t1y, <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#af12ccab062fed7c8002825344263f546">_t1y_var_num</a>);</div>
<div class="line"><a id="l00142" name="l00142"></a><span class="lineno">  142</span>      dof_map.dof_indices(elem, dof_indices_t1z, <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#a0eb71ab627d8028efeb1bbf05212dc9e">_t1z_var_num</a>);</div>
<div class="line"><a id="l00143" name="l00143"></a><span class="lineno">  143</span> </div>
<div class="line"><a id="l00144" name="l00144"></a><span class="lineno">  144</span>      dof_map.dof_indices(elem, dof_indices_t2x, <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#ac1921976fee38185201ab182c5b56f26">_t2x_var_num</a>);</div>
<div class="line"><a id="l00145" name="l00145"></a><span class="lineno">  145</span>      dof_map.dof_indices(elem, dof_indices_t2y, <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#a5e5bd72ed60f43ecc163b6dd89ef1681">_t2y_var_num</a>);</div>
<div class="line"><a id="l00146" name="l00146"></a><span class="lineno">  146</span>      dof_map.dof_indices(elem, dof_indices_t2z, <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#a43a1532163c9c3ae49af3368d14c9a5b">_t2z_var_num</a>);</div>
<div class="line"><a id="l00147" name="l00147"></a><span class="lineno">  147</span> </div>
<div class="line"><a id="l00148" name="l00148"></a><span class="lineno">  148</span>      <span class="comment">//</span></div>
<div class="line"><a id="l00149" name="l00149"></a><span class="lineno">  149</span> </div>
<div class="line"><a id="l00150" name="l00150"></a><span class="lineno">  150</span>      <span class="comment">// For each node of the Elem, if it is in the secondary_node_to_nodal_normal</span></div>
<div class="line"><a id="l00151" name="l00151"></a><span class="lineno">  151</span>      <span class="comment">// container, set the corresponding nodal normal dof values.</span></div>
<div class="line"><a id="l00152" name="l00152"></a><span class="lineno">  152</span>      <span class="keywordflow">for</span> (MooseIndex(elem-&gt;n_vertices()) n = 0; n &lt; elem-&gt;n_vertices(); ++n)</div>
<div class="line"><a id="l00153" name="l00153"></a><span class="lineno">  153</span>      {</div>
<div class="line"><a id="l00154" name="l00154"></a><span class="lineno">  154</span>        <span class="keyword">auto</span> it = <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#aa3ca853594cf98bdd87e5315b4357c9b">_amg</a>.<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a06fb539aea2e63f3b48a6e1d41a2f568">_secondary_node_to_nodal_normal</a>.find(elem-&gt;node_ptr(n));</div>
<div class="line"><a id="l00155" name="l00155"></a><span class="lineno">  155</span>        <span class="keywordflow">if</span> (it != <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#aa3ca853594cf98bdd87e5315b4357c9b">_amg</a>.<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a06fb539aea2e63f3b48a6e1d41a2f568">_secondary_node_to_nodal_normal</a>.end())</div>
<div class="line"><a id="l00156" name="l00156"></a><span class="lineno">  156</span>        {</div>
<div class="line"><a id="l00157" name="l00157"></a><span class="lineno">  157</span>          <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#ad80dfc2071b28d414b231b585612ee1b">_nodal_normals_system</a>-&gt;solution-&gt;set(dof_indices_nnx[n], it-&gt;second(0));</div>
<div class="line"><a id="l00158" name="l00158"></a><span class="lineno">  158</span>          <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#ad80dfc2071b28d414b231b585612ee1b">_nodal_normals_system</a>-&gt;solution-&gt;set(dof_indices_nny[n], it-&gt;second(1));</div>
<div class="line"><a id="l00159" name="l00159"></a><span class="lineno">  159</span>          <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#ad80dfc2071b28d414b231b585612ee1b">_nodal_normals_system</a>-&gt;solution-&gt;set(dof_indices_nnz[n], it-&gt;second(2));</div>
<div class="line"><a id="l00160" name="l00160"></a><span class="lineno">  160</span>        }</div>
<div class="line"><a id="l00161" name="l00161"></a><span class="lineno">  161</span> </div>
<div class="line"><a id="l00162" name="l00162"></a><span class="lineno">  162</span>        <span class="keyword">auto</span> it_tangent = <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#aa3ca853594cf98bdd87e5315b4357c9b">_amg</a>.<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a8120c89f18fdff39621fa512087a2da3">_secondary_node_to_hh_nodal_tangents</a>.find(elem-&gt;node_ptr(n));</div>
<div class="line"><a id="l00163" name="l00163"></a><span class="lineno">  163</span>        <span class="keywordflow">if</span> (it_tangent != <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#aa3ca853594cf98bdd87e5315b4357c9b">_amg</a>.<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a8120c89f18fdff39621fa512087a2da3">_secondary_node_to_hh_nodal_tangents</a>.end())</div>
<div class="line"><a id="l00164" name="l00164"></a><span class="lineno">  164</span>        {</div>
<div class="line"><a id="l00165" name="l00165"></a><span class="lineno">  165</span>          <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#ad80dfc2071b28d414b231b585612ee1b">_nodal_normals_system</a>-&gt;solution-&gt;set(dof_indices_t1x[n], it_tangent-&gt;second[0](0));</div>
<div class="line"><a id="l00166" name="l00166"></a><span class="lineno">  166</span>          <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#ad80dfc2071b28d414b231b585612ee1b">_nodal_normals_system</a>-&gt;solution-&gt;set(dof_indices_t1y[n], it_tangent-&gt;second[0](1));</div>
<div class="line"><a id="l00167" name="l00167"></a><span class="lineno">  167</span>          <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#ad80dfc2071b28d414b231b585612ee1b">_nodal_normals_system</a>-&gt;solution-&gt;set(dof_indices_t1z[n], it_tangent-&gt;second[0](2));</div>
<div class="line"><a id="l00168" name="l00168"></a><span class="lineno">  168</span> </div>
<div class="line"><a id="l00169" name="l00169"></a><span class="lineno">  169</span>          <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#ad80dfc2071b28d414b231b585612ee1b">_nodal_normals_system</a>-&gt;solution-&gt;set(dof_indices_t2x[n], it_tangent-&gt;second[1](0));</div>
<div class="line"><a id="l00170" name="l00170"></a><span class="lineno">  170</span>          <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#ad80dfc2071b28d414b231b585612ee1b">_nodal_normals_system</a>-&gt;solution-&gt;set(dof_indices_t2y[n], it_tangent-&gt;second[1](1));</div>
<div class="line"><a id="l00171" name="l00171"></a><span class="lineno">  171</span>          <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#ad80dfc2071b28d414b231b585612ee1b">_nodal_normals_system</a>-&gt;solution-&gt;set(dof_indices_t2z[n], it_tangent-&gt;second[1](2));</div>
<div class="line"><a id="l00172" name="l00172"></a><span class="lineno">  172</span>        }</div>
<div class="line"><a id="l00173" name="l00173"></a><span class="lineno">  173</span> </div>
<div class="line"><a id="l00174" name="l00174"></a><span class="lineno">  174</span>      } <span class="comment">// end loop over nodes</span></div>
<div class="line"><a id="l00175" name="l00175"></a><span class="lineno">  175</span>    }   <span class="comment">// end loop over elems</span></div>
<div class="line"><a id="l00176" name="l00176"></a><span class="lineno">  176</span> </div>
<div class="line"><a id="l00177" name="l00177"></a><span class="lineno">  177</span>    <span class="comment">// Finish assembly.</span></div>
<div class="line"><a id="l00178" name="l00178"></a><span class="lineno">  178</span>    <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#ad80dfc2071b28d414b231b585612ee1b">_nodal_normals_system</a>-&gt;solution-&gt;close();</div>
<div class="line"><a id="l00179" name="l00179"></a><span class="lineno">  179</span> </div>
<div class="line"><a id="l00180" name="l00180"></a><span class="lineno">  180</span>    std::set&lt;std::string&gt; sys_names = {nodal_normals_sys_name};</div>
<div class="line"><a id="l00181" name="l00181"></a><span class="lineno">  181</span> </div>
<div class="line"><a id="l00182" name="l00182"></a><span class="lineno">  182</span>    <span class="comment">// Write the nodal normals to file</span></div>
<div class="line"><a id="l00183" name="l00183"></a><span class="lineno">  183</span>    ExodusII_IO nodal_normals_writer(<a class="code hl_variable" href="classMortarNodalGeometryOutput.html#aa3ca853594cf98bdd87e5315b4357c9b">_amg</a>.<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>);</div>
<div class="line"><a id="l00184" name="l00184"></a><span class="lineno">  184</span> </div>
<div class="line"><a id="l00185" name="l00185"></a><span class="lineno">  185</span>    <span class="comment">// Default to non-HDF5 output for wider compatibility</span></div>
<div class="line"><a id="l00186" name="l00186"></a><span class="lineno">  186</span>    nodal_normals_writer.set_hdf5_writing(<span class="keyword">false</span>);</div>
<div class="line"><a id="l00187" name="l00187"></a><span class="lineno">  187</span> </div>
<div class="line"><a id="l00188" name="l00188"></a><span class="lineno">  188</span>    nodal_normals_writer.write_equation_systems(</div>
<div class="line"><a id="l00189" name="l00189"></a><span class="lineno">  189</span>        <span class="stringliteral">&quot;nodal_geometry_only.e&quot;</span>, nodal_normals_es, &amp;sys_names);</div>
<div class="line"><a id="l00190" name="l00190"></a><span class="lineno">  190</span>  }</div>
<div class="line"><a id="l00191" name="l00191"></a><span class="lineno">  191</span> </div>
<div class="line"><a id="l00192" name="l00192"></a><span class="lineno">  192</span><span class="keyword">private</span>:</div>
<div class="line"><a id="l00194" name="l00194"></a><span class="lineno"><a class="line" href="classMortarNodalGeometryOutput.html#aa3ca853594cf98bdd87e5315b4357c9b">  194</a></span>  <a class="code hl_class" href="classAutomaticMortarGeneration.html">AutomaticMortarGeneration</a> &amp; <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#aa3ca853594cf98bdd87e5315b4357c9b">_amg</a>;</div>
<div class="line"><a id="l00195" name="l00195"></a><span class="lineno">  195</span> </div>
<div class="line"><a id="l00197" name="l00197"></a><span class="lineno">  197</span> </div>
<div class="line"><a id="l00198" name="l00198"></a><span class="lineno"><a class="line" href="classMortarNodalGeometryOutput.html#ad80dfc2071b28d414b231b585612ee1b">  198</a></span>  libMesh::System * <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#ad80dfc2071b28d414b231b585612ee1b">_nodal_normals_system</a> = <span class="keyword">nullptr</span>;</div>
<div class="line"><a id="l00199" name="l00199"></a><span class="lineno"><a class="line" href="classMortarNodalGeometryOutput.html#abacf3fe882f67ac24674bb7617a266a8">  199</a></span>  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#abacf3fe882f67ac24674bb7617a266a8">_nnx_var_num</a>;</div>
<div class="line"><a id="l00200" name="l00200"></a><span class="lineno"><a class="line" href="classMortarNodalGeometryOutput.html#a59e55d699cc43d82ea14eb460f66bc92">  200</a></span>  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#a59e55d699cc43d82ea14eb460f66bc92">_nny_var_num</a>;</div>
<div class="line"><a id="l00201" name="l00201"></a><span class="lineno"><a class="line" href="classMortarNodalGeometryOutput.html#ab203b6ac1578045882f4076cce002b30">  201</a></span>  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#ab203b6ac1578045882f4076cce002b30">_nnz_var_num</a>;</div>
<div class="line"><a id="l00202" name="l00202"></a><span class="lineno">  202</span> </div>
<div class="line"><a id="l00203" name="l00203"></a><span class="lineno"><a class="line" href="classMortarNodalGeometryOutput.html#a0ffdd24bb6e71f5af85dba0950d9e47f">  203</a></span>  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#a0ffdd24bb6e71f5af85dba0950d9e47f">_t1x_var_num</a>;</div>
<div class="line"><a id="l00204" name="l00204"></a><span class="lineno"><a class="line" href="classMortarNodalGeometryOutput.html#af12ccab062fed7c8002825344263f546">  204</a></span>  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#af12ccab062fed7c8002825344263f546">_t1y_var_num</a>;</div>
<div class="line"><a id="l00205" name="l00205"></a><span class="lineno"><a class="line" href="classMortarNodalGeometryOutput.html#a0eb71ab627d8028efeb1bbf05212dc9e">  205</a></span>  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#a0eb71ab627d8028efeb1bbf05212dc9e">_t1z_var_num</a>;</div>
<div class="line"><a id="l00206" name="l00206"></a><span class="lineno">  206</span> </div>
<div class="line"><a id="l00207" name="l00207"></a><span class="lineno"><a class="line" href="classMortarNodalGeometryOutput.html#ac1921976fee38185201ab182c5b56f26">  207</a></span>  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#ac1921976fee38185201ab182c5b56f26">_t2x_var_num</a>;</div>
<div class="line"><a id="l00208" name="l00208"></a><span class="lineno"><a class="line" href="classMortarNodalGeometryOutput.html#a5e5bd72ed60f43ecc163b6dd89ef1681">  208</a></span>  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#a5e5bd72ed60f43ecc163b6dd89ef1681">_t2y_var_num</a>;</div>
<div class="line"><a id="l00209" name="l00209"></a><span class="lineno"><a class="line" href="classMortarNodalGeometryOutput.html#a43a1532163c9c3ae49af3368d14c9a5b">  209</a></span>  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code hl_variable" href="classMortarNodalGeometryOutput.html#a43a1532163c9c3ae49af3368d14c9a5b">_t2z_var_num</a>;</div>
<div class="line"><a id="l00211" name="l00211"></a><span class="lineno">  211</span>};</div>
<div class="line"><a id="l00212" name="l00212"></a><span class="lineno">  212</span> </div>
<div class="line"><a id="l00213" name="l00213"></a><span class="lineno"><a class="line" href="classAutomaticMortarGeneration.html#a9f5f8acc9b0a8749aaa3d0f32302c8a6">  213</a></span><a class="code hl_function" href="classAutomaticMortarGeneration.html#a9f5f8acc9b0a8749aaa3d0f32302c8a6">AutomaticMortarGeneration::AutomaticMortarGeneration</a>(</div>
<div class="line"><a id="l00214" name="l00214"></a><span class="lineno">  214</span>    <a class="code hl_class" href="classMooseApp.html">MooseApp</a> &amp; app,</div>
<div class="line"><a id="l00215" name="l00215"></a><span class="lineno">  215</span>    MeshBase &amp; mesh_in,</div>
<div class="line"><a id="l00216" name="l00216"></a><span class="lineno">  216</span>    <span class="keyword">const</span> std::pair&lt;BoundaryID, BoundaryID&gt; &amp; boundary_key,</div>
<div class="line"><a id="l00217" name="l00217"></a><span class="lineno">  217</span>    <span class="keyword">const</span> std::pair&lt;SubdomainID, SubdomainID&gt; &amp; subdomain_key,</div>
<div class="line"><a id="l00218" name="l00218"></a><span class="lineno">  218</span>    <span class="keywordtype">bool</span> on_displaced,</div>
<div class="line"><a id="l00219" name="l00219"></a><span class="lineno">  219</span>    <span class="keywordtype">bool</span> periodic,</div>
<div class="line"><a id="l00220" name="l00220"></a><span class="lineno">  220</span>    <span class="keyword">const</span> <span class="keywordtype">bool</span> debug,</div>
<div class="line"><a id="l00221" name="l00221"></a><span class="lineno">  221</span>    <span class="keyword">const</span> <span class="keywordtype">bool</span> correct_edge_dropping,</div>
<div class="line"><a id="l00222" name="l00222"></a><span class="lineno">  222</span>    <span class="keyword">const</span> Real minimum_projection_angle)</div>
<div class="line"><a id="l00223" name="l00223"></a><span class="lineno">  223</span>  : <a class="code hl_class" href="classConsoleStreamInterface.html">ConsoleStreamInterface</a>(app),</div>
<div class="line"><a id="l00224" name="l00224"></a><span class="lineno">  224</span>    _app(app),</div>
<div class="line"><a id="l00225" name="l00225"></a><span class="lineno">  225</span>    _mesh(mesh_in),</div>
<div class="line"><a id="l00226" name="l00226"></a><span class="lineno">  226</span>    _debug(debug),</div>
<div class="line"><a id="l00227" name="l00227"></a><span class="lineno">  227</span>    _on_displaced(on_displaced),</div>
<div class="line"><a id="l00228" name="l00228"></a><span class="lineno">  228</span>    _periodic(periodic),</div>
<div class="line"><a id="l00229" name="l00229"></a><span class="lineno">  229</span>    _distributed(!_mesh.is_replicated()),</div>
<div class="line"><a id="l00230" name="l00230"></a><span class="lineno">  230</span>    _correct_edge_dropping(correct_edge_dropping),</div>
<div class="line"><a id="l00231" name="l00231"></a><span class="lineno">  231</span>    _minimum_projection_angle(minimum_projection_angle)</div>
<div class="line"><a id="l00232" name="l00232"></a><span class="lineno">  232</span>{</div>
<div class="line"><a id="l00233" name="l00233"></a><span class="lineno">  233</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a36e1a5b919de8cfdc39c8af4098fb450">_primary_secondary_boundary_id_pairs</a>.push_back(boundary_key);</div>
<div class="line"><a id="l00234" name="l00234"></a><span class="lineno">  234</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#ad67507605b6ed18765d5ffd1243ff619">_primary_requested_boundary_ids</a>.insert(boundary_key.first);</div>
<div class="line"><a id="l00235" name="l00235"></a><span class="lineno">  235</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a1d4166e27bcb186c75c320b232652cf1">_secondary_requested_boundary_ids</a>.insert(boundary_key.second);</div>
<div class="line"><a id="l00236" name="l00236"></a><span class="lineno">  236</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a969d4ab038fc8d447e966cd1e1600091">_primary_secondary_subdomain_id_pairs</a>.push_back(subdomain_key);</div>
<div class="line"><a id="l00237" name="l00237"></a><span class="lineno">  237</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#acbe701da36a67d2d9546f9db735b1faf">_primary_boundary_subdomain_ids</a>.insert(subdomain_key.first);</div>
<div class="line"><a id="l00238" name="l00238"></a><span class="lineno">  238</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a59c6fd297125023195e7bfb3714846c5">_secondary_boundary_subdomain_ids</a>.insert(subdomain_key.second);</div>
<div class="line"><a id="l00239" name="l00239"></a><span class="lineno">  239</span> </div>
<div class="line"><a id="l00240" name="l00240"></a><span class="lineno">  240</span>  <span class="keywordflow">if</span> (<a class="code hl_variable" href="classAutomaticMortarGeneration.html#ac4462365906bd50aeb9a76b07a5ff34d">_distributed</a>)</div>
<div class="line"><a id="l00241" name="l00241"></a><span class="lineno">  241</span>    <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a> = std::make_unique&lt;DistributedMesh&gt;(<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.comm());</div>
<div class="line"><a id="l00242" name="l00242"></a><span class="lineno">  242</span>  <span class="keywordflow">else</span></div>
<div class="line"><a id="l00243" name="l00243"></a><span class="lineno">  243</span>    <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a> = std::make_unique&lt;ReplicatedMesh&gt;(<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.comm());</div>
<div class="line"><a id="l00244" name="l00244"></a><span class="lineno">  244</span>}</div>
<div class="line"><a id="l00245" name="l00245"></a><span class="lineno">  245</span> </div>
<div class="line"><a id="l00246" name="l00246"></a><span class="lineno">  246</span><span class="keywordtype">void</span></div>
<div class="line"><a id="l00247" name="l00247"></a><span class="lineno"><a class="line" href="classAutomaticMortarGeneration.html#a7b7d494bc9dfe051e07cbbdeacc9a28d">  247</a></span><a class="code hl_function" href="classAutomaticMortarGeneration.html#a7b7d494bc9dfe051e07cbbdeacc9a28d">AutomaticMortarGeneration::initOutput</a>()</div>
<div class="line"><a id="l00248" name="l00248"></a><span class="lineno">  248</span>{</div>
<div class="line"><a id="l00249" name="l00249"></a><span class="lineno">  249</span>  <span class="keywordflow">if</span> (!<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a958de5b754ec676f463c50d2f16b5d0c">_debug</a>)</div>
<div class="line"><a id="l00250" name="l00250"></a><span class="lineno">  250</span>    <span class="keywordflow">return</span>;</div>
<div class="line"><a id="l00251" name="l00251"></a><span class="lineno">  251</span> </div>
<div class="line"><a id="l00252" name="l00252"></a><span class="lineno">  252</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a3a19330f38987cd9318f38d932c5a2ad">_output_params</a> = std::make_unique&lt;InputParameters&gt;(<a class="code hl_function" href="classMortarNodalGeometryOutput.html#a6bf8458c621e9dba746029f0f658eab1">MortarNodalGeometryOutput::validParams</a>());</div>
<div class="line"><a id="l00253" name="l00253"></a><span class="lineno">  253</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a3a19330f38987cd9318f38d932c5a2ad">_output_params</a>-&gt;set&lt;<a class="code hl_class" href="classAutomaticMortarGeneration.html">AutomaticMortarGeneration</a> *&gt;(<span class="stringliteral">&quot;_amg&quot;</span>) = <span class="keyword">this</span>;</div>
<div class="line"><a id="l00254" name="l00254"></a><span class="lineno">  254</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a3a19330f38987cd9318f38d932c5a2ad">_output_params</a>-&gt;set&lt;<a class="code hl_class" href="classFEProblemBase.html">FEProblemBase</a> *&gt;(<span class="stringliteral">&quot;_fe_problem_base&quot;</span>) = &amp;<a class="code hl_variable" href="classAutomaticMortarGeneration.html#aaad114f9251de54152c04ef277441578">_app</a>.<a class="code hl_function" href="classMooseApp.html#a9901a98a17c8276cc00b4841584bb561">feProblem</a>();</div>
<div class="line"><a id="l00255" name="l00255"></a><span class="lineno">  255</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a3a19330f38987cd9318f38d932c5a2ad">_output_params</a>-&gt;set&lt;<a class="code hl_class" href="classMooseApp.html">MooseApp</a> *&gt;(<span class="stringliteral">&quot;_moose_app&quot;</span>) = &amp;<a class="code hl_variable" href="classAutomaticMortarGeneration.html#aaad114f9251de54152c04ef277441578">_app</a>;</div>
<div class="line"><a id="l00256" name="l00256"></a><span class="lineno">  256</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a3a19330f38987cd9318f38d932c5a2ad">_output_params</a>-&gt;set&lt;std::string&gt;(<span class="stringliteral">&quot;_object_name&quot;</span>) =</div>
<div class="line"><a id="l00257" name="l00257"></a><span class="lineno">  257</span>      <span class="stringliteral">&quot;mortar_nodal_geometry_&quot;</span> +</div>
<div class="line"><a id="l00258" name="l00258"></a><span class="lineno">  258</span>      std::to_string(<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a36e1a5b919de8cfdc39c8af4098fb450">_primary_secondary_boundary_id_pairs</a>.front().first) +</div>
<div class="line"><a id="l00259" name="l00259"></a><span class="lineno">  259</span>      std::to_string(<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a36e1a5b919de8cfdc39c8af4098fb450">_primary_secondary_boundary_id_pairs</a>.front().second) + <span class="stringliteral">&quot;_&quot;</span> +</div>
<div class="line"><a id="l00260" name="l00260"></a><span class="lineno">  260</span>      (<a class="code hl_variable" href="classAutomaticMortarGeneration.html#ac1faa015bf0201e49ab822e50b713fc1">_on_displaced</a> ? <span class="stringliteral">&quot;displaced&quot;</span> : <span class="stringliteral">&quot;undisplaced&quot;</span>);</div>
<div class="line"><a id="l00261" name="l00261"></a><span class="lineno">  261</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#aaad114f9251de54152c04ef277441578">_app</a>.<a class="code hl_function" href="classMooseApp.html#a446e24d786a991471cfc3a1f0aeccaea">getOutputWarehouse</a>().<a class="code hl_function" href="classOutputWarehouse.html#af1e105715b5393f3341b24fdc4f31627">addOutput</a>(std::make_shared&lt;MortarNodalGeometryOutput&gt;(*<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a3a19330f38987cd9318f38d932c5a2ad">_output_params</a>));</div>
<div class="line"><a id="l00262" name="l00262"></a><span class="lineno">  262</span>}</div>
<div class="line"><a id="l00263" name="l00263"></a><span class="lineno">  263</span> </div>
<div class="line"><a id="l00264" name="l00264"></a><span class="lineno">  264</span><span class="keywordtype">void</span></div>
<div class="line"><a id="l00265" name="l00265"></a><span class="lineno"><a class="line" href="classAutomaticMortarGeneration.html#aa871943ba7a8761cc220e90af9c716a0">  265</a></span><a class="code hl_function" href="classAutomaticMortarGeneration.html#aa871943ba7a8761cc220e90af9c716a0">AutomaticMortarGeneration::clear</a>()</div>
<div class="line"><a id="l00266" name="l00266"></a><span class="lineno">  266</span>{</div>
<div class="line"><a id="l00267" name="l00267"></a><span class="lineno">  267</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;clear();</div>
<div class="line"><a id="l00268" name="l00268"></a><span class="lineno">  268</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a1ad443aa196d2c81d195b29ddeee1d5e">_nodes_to_secondary_elem_map</a>.clear();</div>
<div class="line"><a id="l00269" name="l00269"></a><span class="lineno">  269</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a1ee9b6e4f8bd88603e22117085758f70">_nodes_to_primary_elem_map</a>.clear();</div>
<div class="line"><a id="l00270" name="l00270"></a><span class="lineno">  270</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#abb4cc3e3102675e52675a95347ad8e95">_secondary_node_and_elem_to_xi2_primary_elem</a>.clear();</div>
<div class="line"><a id="l00271" name="l00271"></a><span class="lineno">  271</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#ac174eedb02e9681baf439360903700d4">_primary_node_and_elem_to_xi1_secondary_elem</a>.clear();</div>
<div class="line"><a id="l00272" name="l00272"></a><span class="lineno">  272</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#abbd91d3cf8bef528976fe6f932622d2d">_msm_elem_to_info</a>.clear();</div>
<div class="line"><a id="l00273" name="l00273"></a><span class="lineno">  273</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a169550fc1a82fca976e386edae0d254d">_lower_elem_to_side_id</a>.clear();</div>
<div class="line"><a id="l00274" name="l00274"></a><span class="lineno">  274</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#ab2357a3aacfa2cae90078e3b6293bf26">_mortar_interface_coupling</a>.clear();</div>
<div class="line"><a id="l00275" name="l00275"></a><span class="lineno">  275</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a06fb539aea2e63f3b48a6e1d41a2f568">_secondary_node_to_nodal_normal</a>.clear();</div>
<div class="line"><a id="l00276" name="l00276"></a><span class="lineno">  276</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a8120c89f18fdff39621fa512087a2da3">_secondary_node_to_hh_nodal_tangents</a>.clear();</div>
<div class="line"><a id="l00277" name="l00277"></a><span class="lineno">  277</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#acb676f79ae207404fb5d224ac768df42">_secondary_element_to_secondary_lowerd_element</a>.clear();</div>
<div class="line"><a id="l00278" name="l00278"></a><span class="lineno">  278</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#af0da3b7d9e404238718805e12452d74d">_secondary_elems_to_mortar_segments</a>.clear();</div>
<div class="line"><a id="l00279" name="l00279"></a><span class="lineno">  279</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a7254faea651acd63b60b408ab560a0e5">_secondary_ip_sub_ids</a>.clear();</div>
<div class="line"><a id="l00280" name="l00280"></a><span class="lineno">  280</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#ac99e408cefd4da80efa2649ef1d32e93">_primary_ip_sub_ids</a>.clear();</div>
<div class="line"><a id="l00281" name="l00281"></a><span class="lineno">  281</span>}</div>
<div class="line"><a id="l00282" name="l00282"></a><span class="lineno">  282</span> </div>
<div class="line"><a id="l00283" name="l00283"></a><span class="lineno">  283</span><span class="keywordtype">void</span></div>
<div class="line"><a id="l00284" name="l00284"></a><span class="lineno"><a class="line" href="classAutomaticMortarGeneration.html#a9b366747e19933f0beae2fbb9c0d969b">  284</a></span><a class="code hl_function" href="classAutomaticMortarGeneration.html#a9b366747e19933f0beae2fbb9c0d969b">AutomaticMortarGeneration::buildNodeToElemMaps</a>()</div>
<div class="line"><a id="l00285" name="l00285"></a><span class="lineno">  285</span>{</div>
<div class="line"><a id="l00286" name="l00286"></a><span class="lineno">  286</span>  <span class="keywordflow">if</span> (<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a1d4166e27bcb186c75c320b232652cf1">_secondary_requested_boundary_ids</a>.empty() || <a class="code hl_variable" href="classAutomaticMortarGeneration.html#ad67507605b6ed18765d5ffd1243ff619">_primary_requested_boundary_ids</a>.empty())</div>
<div class="line"><a id="l00287" name="l00287"></a><span class="lineno">  287</span>    <a class="code hl_function" href="MooseError_8h.html#aa959168eed29caa7aaa85ffc1319a9ad">mooseError</a>(</div>
<div class="line"><a id="l00288" name="l00288"></a><span class="lineno">  288</span>        <span class="stringliteral">&quot;Must specify secondary and primary boundary ids before building node-to-elem maps.&quot;</span>);</div>
<div class="line"><a id="l00289" name="l00289"></a><span class="lineno">  289</span> </div>
<div class="line"><a id="l00290" name="l00290"></a><span class="lineno">  290</span>  <span class="comment">// Construct nodes_to_secondary_elem_map</span></div>
<div class="line"><a id="l00291" name="l00291"></a><span class="lineno">  291</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; secondary_elem :</div>
<div class="line"><a id="l00292" name="l00292"></a><span class="lineno">  292</span>       as_range(<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.active_elements_begin(), <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.active_elements_end()))</div>
<div class="line"><a id="l00293" name="l00293"></a><span class="lineno">  293</span>  {</div>
<div class="line"><a id="l00294" name="l00294"></a><span class="lineno">  294</span>    <span class="comment">// If this is not one of the lower-dimensional secondary side elements, go on to the next one.</span></div>
<div class="line"><a id="l00295" name="l00295"></a><span class="lineno">  295</span>    <span class="keywordflow">if</span> (!this-&gt;<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a59c6fd297125023195e7bfb3714846c5">_secondary_boundary_subdomain_ids</a>.count(secondary_elem-&gt;subdomain_id()))</div>
<div class="line"><a id="l00296" name="l00296"></a><span class="lineno">  296</span>      <span class="keywordflow">continue</span>;</div>
<div class="line"><a id="l00297" name="l00297"></a><span class="lineno">  297</span> </div>
<div class="line"><a id="l00298" name="l00298"></a><span class="lineno">  298</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; nd : secondary_elem-&gt;node_ref_range())</div>
<div class="line"><a id="l00299" name="l00299"></a><span class="lineno">  299</span>    {</div>
<div class="line"><a id="l00300" name="l00300"></a><span class="lineno">  300</span>      std::vector&lt;const Elem *&gt; &amp; vec = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a1ad443aa196d2c81d195b29ddeee1d5e">_nodes_to_secondary_elem_map</a>[nd.id()];</div>
<div class="line"><a id="l00301" name="l00301"></a><span class="lineno">  301</span>      vec.push_back(secondary_elem);</div>
<div class="line"><a id="l00302" name="l00302"></a><span class="lineno">  302</span>    }</div>
<div class="line"><a id="l00303" name="l00303"></a><span class="lineno">  303</span>  }</div>
<div class="line"><a id="l00304" name="l00304"></a><span class="lineno">  304</span> </div>
<div class="line"><a id="l00305" name="l00305"></a><span class="lineno">  305</span>  <span class="comment">// Construct nodes_to_primary_elem_map</span></div>
<div class="line"><a id="l00306" name="l00306"></a><span class="lineno">  306</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; primary_elem :</div>
<div class="line"><a id="l00307" name="l00307"></a><span class="lineno">  307</span>       as_range(<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.active_elements_begin(), <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.active_elements_end()))</div>
<div class="line"><a id="l00308" name="l00308"></a><span class="lineno">  308</span>  {</div>
<div class="line"><a id="l00309" name="l00309"></a><span class="lineno">  309</span>    <span class="comment">// If this is not one of the lower-dimensional primary side elements, go on to the next one.</span></div>
<div class="line"><a id="l00310" name="l00310"></a><span class="lineno">  310</span>    <span class="keywordflow">if</span> (!this-&gt;<a class="code hl_variable" href="classAutomaticMortarGeneration.html#acbe701da36a67d2d9546f9db735b1faf">_primary_boundary_subdomain_ids</a>.count(primary_elem-&gt;subdomain_id()))</div>
<div class="line"><a id="l00311" name="l00311"></a><span class="lineno">  311</span>      <span class="keywordflow">continue</span>;</div>
<div class="line"><a id="l00312" name="l00312"></a><span class="lineno">  312</span> </div>
<div class="line"><a id="l00313" name="l00313"></a><span class="lineno">  313</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; nd : primary_elem-&gt;node_ref_range())</div>
<div class="line"><a id="l00314" name="l00314"></a><span class="lineno">  314</span>    {</div>
<div class="line"><a id="l00315" name="l00315"></a><span class="lineno">  315</span>      std::vector&lt;const Elem *&gt; &amp; vec = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a1ee9b6e4f8bd88603e22117085758f70">_nodes_to_primary_elem_map</a>[nd.id()];</div>
<div class="line"><a id="l00316" name="l00316"></a><span class="lineno">  316</span>      vec.push_back(primary_elem);</div>
<div class="line"><a id="l00317" name="l00317"></a><span class="lineno">  317</span>    }</div>
<div class="line"><a id="l00318" name="l00318"></a><span class="lineno">  318</span>  }</div>
<div class="line"><a id="l00319" name="l00319"></a><span class="lineno">  319</span>}</div>
<div class="line"><a id="l00320" name="l00320"></a><span class="lineno">  320</span> </div>
<div class="line"><a id="l00321" name="l00321"></a><span class="lineno">  321</span>std::vector&lt;Point&gt;</div>
<div class="line"><a id="l00322" name="l00322"></a><span class="lineno"><a class="line" href="classAutomaticMortarGeneration.html#ae200397e9841242f1bc2438b2156f253">  322</a></span><a class="code hl_function" href="classAutomaticMortarGeneration.html#ae200397e9841242f1bc2438b2156f253">AutomaticMortarGeneration::getNodalNormals</a>(<span class="keyword">const</span> Elem &amp; secondary_elem)<span class="keyword"> const</span></div>
<div class="line"><a id="l00323" name="l00323"></a><span class="lineno">  323</span><span class="keyword"></span>{</div>
<div class="line"><a id="l00324" name="l00324"></a><span class="lineno">  324</span>  std::vector&lt;Point&gt; nodal_normals(secondary_elem.n_nodes());</div>
<div class="line"><a id="l00325" name="l00325"></a><span class="lineno">  325</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> n : make_range(secondary_elem.n_nodes()))</div>
<div class="line"><a id="l00326" name="l00326"></a><span class="lineno">  326</span>    nodal_normals[n] = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a06fb539aea2e63f3b48a6e1d41a2f568">_secondary_node_to_nodal_normal</a>.at(secondary_elem.node_ptr(n));</div>
<div class="line"><a id="l00327" name="l00327"></a><span class="lineno">  327</span> </div>
<div class="line"><a id="l00328" name="l00328"></a><span class="lineno">  328</span>  <span class="keywordflow">return</span> nodal_normals;</div>
<div class="line"><a id="l00329" name="l00329"></a><span class="lineno">  329</span>}</div>
<div class="line"><a id="l00330" name="l00330"></a><span class="lineno">  330</span> </div>
<div class="line"><a id="l00331" name="l00331"></a><span class="lineno">  331</span><span class="keyword">const</span> Elem *</div>
<div class="line"><a id="l00332" name="l00332"></a><span class="lineno"><a class="line" href="classAutomaticMortarGeneration.html#a02fad9659b03bfd39cc92b30a4a988d6">  332</a></span><a class="code hl_function" href="classAutomaticMortarGeneration.html#a02fad9659b03bfd39cc92b30a4a988d6">AutomaticMortarGeneration::getSecondaryLowerdElemFromSecondaryElem</a>(</div>
<div class="line"><a id="l00333" name="l00333"></a><span class="lineno">  333</span>    dof_id_type secondary_elem_id)<span class="keyword"> const</span></div>
<div class="line"><a id="l00334" name="l00334"></a><span class="lineno">  334</span><span class="keyword"></span>{</div>
<div class="line"><a id="l00335" name="l00335"></a><span class="lineno">  335</span>  mooseAssert(<a class="code hl_variable" href="classAutomaticMortarGeneration.html#acb676f79ae207404fb5d224ac768df42">_secondary_element_to_secondary_lowerd_element</a>.count(secondary_elem_id),</div>
<div class="line"><a id="l00336" name="l00336"></a><span class="lineno">  336</span>              <span class="stringliteral">&quot;Map should locate secondary element&quot;</span>);</div>
<div class="line"><a id="l00337" name="l00337"></a><span class="lineno">  337</span> </div>
<div class="line"><a id="l00338" name="l00338"></a><span class="lineno">  338</span>  <span class="keywordflow">return</span> <a class="code hl_variable" href="classAutomaticMortarGeneration.html#acb676f79ae207404fb5d224ac768df42">_secondary_element_to_secondary_lowerd_element</a>.at(secondary_elem_id);</div>
<div class="line"><a id="l00339" name="l00339"></a><span class="lineno">  339</span>}</div>
<div class="line"><a id="l00340" name="l00340"></a><span class="lineno">  340</span> </div>
<div class="line"><a id="l00341" name="l00341"></a><span class="lineno">  341</span>std::map&lt;unsigned int, unsigned int&gt;</div>
<div class="line"><a id="l00342" name="l00342"></a><span class="lineno"><a class="line" href="classAutomaticMortarGeneration.html#a9a41db0dea91a39a5ec0e1356b544d23">  342</a></span><a class="code hl_function" href="classAutomaticMortarGeneration.html#a9a41db0dea91a39a5ec0e1356b544d23">AutomaticMortarGeneration::getSecondaryIpToLowerElementMap</a>(<span class="keyword">const</span> Elem &amp; lower_secondary_elem)<span class="keyword"> const</span></div>
<div class="line"><a id="l00343" name="l00343"></a><span class="lineno">  343</span><span class="keyword"></span>{</div>
<div class="line"><a id="l00344" name="l00344"></a><span class="lineno">  344</span>  std::map&lt;unsigned int, unsigned int&gt; secondary_ip_i_to_lower_secondary_i;</div>
<div class="line"><a id="l00345" name="l00345"></a><span class="lineno">  345</span>  <span class="keyword">const</span> Elem * <span class="keyword">const</span> secondary_ip = lower_secondary_elem.interior_parent();</div>
<div class="line"><a id="l00346" name="l00346"></a><span class="lineno">  346</span>  mooseAssert(secondary_ip, <span class="stringliteral">&quot;This should be non-null&quot;</span>);</div>
<div class="line"><a id="l00347" name="l00347"></a><span class="lineno">  347</span> </div>
<div class="line"><a id="l00348" name="l00348"></a><span class="lineno">  348</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : make_range(lower_secondary_elem.n_nodes()))</div>
<div class="line"><a id="l00349" name="l00349"></a><span class="lineno">  349</span>  {</div>
<div class="line"><a id="l00350" name="l00350"></a><span class="lineno">  350</span>    <span class="keyword">const</span> <span class="keyword">auto</span> &amp; nd = lower_secondary_elem.node_ref(i);</div>
<div class="line"><a id="l00351" name="l00351"></a><span class="lineno">  351</span>    secondary_ip_i_to_lower_secondary_i[secondary_ip-&gt;get_node_index(&amp;nd)] = i;</div>
<div class="line"><a id="l00352" name="l00352"></a><span class="lineno">  352</span>  }</div>
<div class="line"><a id="l00353" name="l00353"></a><span class="lineno">  353</span> </div>
<div class="line"><a id="l00354" name="l00354"></a><span class="lineno">  354</span>  <span class="keywordflow">return</span> secondary_ip_i_to_lower_secondary_i;</div>
<div class="line"><a id="l00355" name="l00355"></a><span class="lineno">  355</span>}</div>
<div class="line"><a id="l00356" name="l00356"></a><span class="lineno">  356</span> </div>
<div class="line"><a id="l00357" name="l00357"></a><span class="lineno">  357</span>std::map&lt;unsigned int, unsigned int&gt;</div>
<div class="line"><a id="l00358" name="l00358"></a><span class="lineno"><a class="line" href="classAutomaticMortarGeneration.html#ab8f33d0072ce0d896b4f058980640488">  358</a></span><a class="code hl_function" href="classAutomaticMortarGeneration.html#ab8f33d0072ce0d896b4f058980640488">AutomaticMortarGeneration::getPrimaryIpToLowerElementMap</a>(</div>
<div class="line"><a id="l00359" name="l00359"></a><span class="lineno">  359</span>    <span class="keyword">const</span> Elem &amp; lower_primary_elem,</div>
<div class="line"><a id="l00360" name="l00360"></a><span class="lineno">  360</span>    <span class="keyword">const</span> Elem &amp; primary_elem,</div>
<div class="line"><a id="l00361" name="l00361"></a><span class="lineno">  361</span>    <span class="keyword">const</span> Elem &amp; <span class="comment">/*lower_secondary_elem*/</span>)<span class="keyword"> const</span></div>
<div class="line"><a id="l00362" name="l00362"></a><span class="lineno">  362</span><span class="keyword"></span>{</div>
<div class="line"><a id="l00363" name="l00363"></a><span class="lineno">  363</span>  std::map&lt;unsigned int, unsigned int&gt; primary_ip_i_to_lower_primary_i;</div>
<div class="line"><a id="l00364" name="l00364"></a><span class="lineno">  364</span> </div>
<div class="line"><a id="l00365" name="l00365"></a><span class="lineno">  365</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : make_range(lower_primary_elem.n_nodes()))</div>
<div class="line"><a id="l00366" name="l00366"></a><span class="lineno">  366</span>  {</div>
<div class="line"><a id="l00367" name="l00367"></a><span class="lineno">  367</span>    <span class="keyword">const</span> <span class="keyword">auto</span> &amp; nd = lower_primary_elem.node_ref(i);</div>
<div class="line"><a id="l00368" name="l00368"></a><span class="lineno">  368</span>    primary_ip_i_to_lower_primary_i[primary_elem.get_node_index(&amp;nd)] = i;</div>
<div class="line"><a id="l00369" name="l00369"></a><span class="lineno">  369</span>  }</div>
<div class="line"><a id="l00370" name="l00370"></a><span class="lineno">  370</span> </div>
<div class="line"><a id="l00371" name="l00371"></a><span class="lineno">  371</span>  <span class="keywordflow">return</span> primary_ip_i_to_lower_primary_i;</div>
<div class="line"><a id="l00372" name="l00372"></a><span class="lineno">  372</span>}</div>
<div class="line"><a id="l00373" name="l00373"></a><span class="lineno">  373</span> </div>
<div class="line"><a id="l00374" name="l00374"></a><span class="lineno">  374</span>std::array&lt;MooseUtils::SemidynamicVector&lt;Point, 9&gt;, 2&gt;</div>
<div class="line"><a id="l00375" name="l00375"></a><span class="lineno"><a class="line" href="classAutomaticMortarGeneration.html#ac9594ceb9068d6cf33b6e1ca2f5951fe">  375</a></span><a class="code hl_function" href="classAutomaticMortarGeneration.html#ac9594ceb9068d6cf33b6e1ca2f5951fe">AutomaticMortarGeneration::getNodalTangents</a>(<span class="keyword">const</span> Elem &amp; secondary_elem)<span class="keyword"> const</span></div>
<div class="line"><a id="l00376" name="l00376"></a><span class="lineno">  376</span><span class="keyword"></span>{</div>
<div class="line"><a id="l00377" name="l00377"></a><span class="lineno">  377</span>  <span class="comment">// MetaPhysicL will check if we ran out of allocated space.</span></div>
<div class="line"><a id="l00378" name="l00378"></a><span class="lineno">  378</span>  <a class="code hl_class" href="classMooseUtils_1_1SemidynamicVector.html">MooseUtils::SemidynamicVector&lt;Point, 9&gt;</a> nodal_tangents_one(0);</div>
<div class="line"><a id="l00379" name="l00379"></a><span class="lineno">  379</span>  <a class="code hl_class" href="classMooseUtils_1_1SemidynamicVector.html">MooseUtils::SemidynamicVector&lt;Point, 9&gt;</a> nodal_tangents_two(0);</div>
<div class="line"><a id="l00380" name="l00380"></a><span class="lineno">  380</span> </div>
<div class="line"><a id="l00381" name="l00381"></a><span class="lineno">  381</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> n : make_range(secondary_elem.n_nodes()))</div>
<div class="line"><a id="l00382" name="l00382"></a><span class="lineno">  382</span>  {</div>
<div class="line"><a id="l00383" name="l00383"></a><span class="lineno">  383</span>    <span class="keyword">const</span> <span class="keyword">auto</span> &amp; tangent_vectors =</div>
<div class="line"><a id="l00384" name="l00384"></a><span class="lineno">  384</span>        libmesh_map_find(<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a8120c89f18fdff39621fa512087a2da3">_secondary_node_to_hh_nodal_tangents</a>, secondary_elem.node_ptr(n));</div>
<div class="line"><a id="l00385" name="l00385"></a><span class="lineno">  385</span>    nodal_tangents_one.<a class="code hl_function" href="classMooseUtils_1_1SemidynamicVector.html#af16f5c51b00a9051eb61ccdefcf905c9">push_back</a>(tangent_vectors[0]);</div>
<div class="line"><a id="l00386" name="l00386"></a><span class="lineno">  386</span>    nodal_tangents_two.<a class="code hl_function" href="classMooseUtils_1_1SemidynamicVector.html#af16f5c51b00a9051eb61ccdefcf905c9">push_back</a>(tangent_vectors[1]);</div>
<div class="line"><a id="l00387" name="l00387"></a><span class="lineno">  387</span>  }</div>
<div class="line"><a id="l00388" name="l00388"></a><span class="lineno">  388</span> </div>
<div class="line"><a id="l00389" name="l00389"></a><span class="lineno">  389</span>  <span class="keywordflow">return</span> {{nodal_tangents_one, nodal_tangents_two}};</div>
<div class="line"><a id="l00390" name="l00390"></a><span class="lineno">  390</span>}</div>
<div class="line"><a id="l00391" name="l00391"></a><span class="lineno">  391</span> </div>
<div class="line"><a id="l00392" name="l00392"></a><span class="lineno">  392</span>std::vector&lt;Point&gt;</div>
<div class="line"><a id="l00393" name="l00393"></a><span class="lineno"><a class="line" href="classAutomaticMortarGeneration.html#a061f0533b7776fd51a0dcce78a8a71b9">  393</a></span><a class="code hl_function" href="classAutomaticMortarGeneration.html#a71eb5cecb4437a9a0edfe8d5ce38007e">AutomaticMortarGeneration::getNormals</a>(<span class="keyword">const</span> Elem &amp; secondary_elem,</div>
<div class="line"><a id="l00394" name="l00394"></a><span class="lineno">  394</span>                                      <span class="keyword">const</span> std::vector&lt;Real&gt; &amp; oned_xi1_pts)<span class="keyword"> const</span></div>
<div class="line"><a id="l00395" name="l00395"></a><span class="lineno">  395</span><span class="keyword"></span>{</div>
<div class="line"><a id="l00396" name="l00396"></a><span class="lineno">  396</span>  std::vector&lt;Point&gt; xi1_pts(oned_xi1_pts.size());</div>
<div class="line"><a id="l00397" name="l00397"></a><span class="lineno">  397</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> qp : index_range(oned_xi1_pts))</div>
<div class="line"><a id="l00398" name="l00398"></a><span class="lineno">  398</span>    xi1_pts[qp] = oned_xi1_pts[qp];</div>
<div class="line"><a id="l00399" name="l00399"></a><span class="lineno">  399</span> </div>
<div class="line"><a id="l00400" name="l00400"></a><span class="lineno">  400</span>  <span class="keywordflow">return</span> <a class="code hl_function" href="classAutomaticMortarGeneration.html#a71eb5cecb4437a9a0edfe8d5ce38007e">getNormals</a>(secondary_elem, xi1_pts);</div>
<div class="line"><a id="l00401" name="l00401"></a><span class="lineno">  401</span>}</div>
<div class="line"><a id="l00402" name="l00402"></a><span class="lineno">  402</span> </div>
<div class="line"><a id="l00403" name="l00403"></a><span class="lineno">  403</span>std::vector&lt;Point&gt;</div>
<div class="line"><a id="l00404" name="l00404"></a><span class="lineno"><a class="line" href="classAutomaticMortarGeneration.html#a71eb5cecb4437a9a0edfe8d5ce38007e">  404</a></span><a class="code hl_function" href="classAutomaticMortarGeneration.html#a71eb5cecb4437a9a0edfe8d5ce38007e">AutomaticMortarGeneration::getNormals</a>(<span class="keyword">const</span> Elem &amp; secondary_elem,</div>
<div class="line"><a id="l00405" name="l00405"></a><span class="lineno">  405</span>                                      <span class="keyword">const</span> std::vector&lt;Point&gt; &amp; xi1_pts)<span class="keyword"> const</span></div>
<div class="line"><a id="l00406" name="l00406"></a><span class="lineno">  406</span><span class="keyword"></span>{</div>
<div class="line"><a id="l00407" name="l00407"></a><span class="lineno">  407</span>  <span class="keyword">const</span> <span class="keyword">auto</span> mortar_dim = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.mesh_dimension() - 1;</div>
<div class="line"><a id="l00408" name="l00408"></a><span class="lineno">  408</span>  <span class="keyword">const</span> <span class="keyword">auto</span> num_qps = xi1_pts.size();</div>
<div class="line"><a id="l00409" name="l00409"></a><span class="lineno">  409</span>  <span class="keyword">const</span> <span class="keyword">auto</span> nodal_normals = <a class="code hl_function" href="classAutomaticMortarGeneration.html#ae200397e9841242f1bc2438b2156f253">getNodalNormals</a>(secondary_elem);</div>
<div class="line"><a id="l00410" name="l00410"></a><span class="lineno">  410</span>  std::vector&lt;Point&gt; normals(num_qps);</div>
<div class="line"><a id="l00411" name="l00411"></a><span class="lineno">  411</span> </div>
<div class="line"><a id="l00412" name="l00412"></a><span class="lineno">  412</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> n : make_range(secondary_elem.n_nodes()))</div>
<div class="line"><a id="l00413" name="l00413"></a><span class="lineno">  413</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> qp : make_range(num_qps))</div>
<div class="line"><a id="l00414" name="l00414"></a><span class="lineno">  414</span>    {</div>
<div class="line"><a id="l00415" name="l00415"></a><span class="lineno">  415</span>      <span class="keyword">const</span> <span class="keyword">auto</span> phi =</div>
<div class="line"><a id="l00416" name="l00416"></a><span class="lineno">  416</span>          (mortar_dim == 1)</div>
<div class="line"><a id="l00417" name="l00417"></a><span class="lineno">  417</span>              ? <a class="code hl_function" href="namespaceMoose.html#a9ed3373b5072c07f1f010afb75ac20c9">Moose::fe_lagrange_1D_shape</a>(secondary_elem.default_order(), n, xi1_pts[qp](0))</div>
<div class="line"><a id="l00418" name="l00418"></a><span class="lineno">  418</span>              : <a class="code hl_function" href="namespaceMoose.html#a5fd6a33e7b0246beaf68f64045de310c">Moose::fe_lagrange_2D_shape</a>(secondary_elem.type(),</div>
<div class="line"><a id="l00419" name="l00419"></a><span class="lineno">  419</span>                                            secondary_elem.default_order(),</div>
<div class="line"><a id="l00420" name="l00420"></a><span class="lineno">  420</span>                                            n,</div>
<div class="line"><a id="l00421" name="l00421"></a><span class="lineno">  421</span>                                            <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code hl_class" href="classlibMesh_1_1TypeVector.html">TypeVector&lt;Real&gt;</a> &amp;<span class="keyword">&gt;</span>(xi1_pts[qp]));</div>
<div class="line"><a id="l00422" name="l00422"></a><span class="lineno">  422</span>      normals[qp] += phi * nodal_normals[n];</div>
<div class="line"><a id="l00423" name="l00423"></a><span class="lineno">  423</span>    }</div>
<div class="line"><a id="l00424" name="l00424"></a><span class="lineno">  424</span> </div>
<div class="line"><a id="l00425" name="l00425"></a><span class="lineno">  425</span>  <span class="keywordflow">if</span> (<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a509e5164f1c4cd0f981eaa901c37c632">_periodic</a>)</div>
<div class="line"><a id="l00426" name="l00426"></a><span class="lineno">  426</span>    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; normal : normals)</div>
<div class="line"><a id="l00427" name="l00427"></a><span class="lineno">  427</span>      normal *= -1;</div>
<div class="line"><a id="l00428" name="l00428"></a><span class="lineno">  428</span> </div>
<div class="line"><a id="l00429" name="l00429"></a><span class="lineno">  429</span>  <span class="keywordflow">return</span> normals;</div>
<div class="line"><a id="l00430" name="l00430"></a><span class="lineno">  430</span>}</div>
<div class="line"><a id="l00431" name="l00431"></a><span class="lineno">  431</span> </div>
<div class="line"><a id="l00432" name="l00432"></a><span class="lineno">  432</span><span class="keywordtype">void</span></div>
<div class="line"><a id="l00433" name="l00433"></a><span class="lineno"><a class="line" href="classAutomaticMortarGeneration.html#a3a49a5fc49ca76d1e89b938d3b3a202e">  433</a></span><a class="code hl_function" href="classAutomaticMortarGeneration.html#a3a49a5fc49ca76d1e89b938d3b3a202e">AutomaticMortarGeneration::buildMortarSegmentMesh</a>()</div>
<div class="line"><a id="l00434" name="l00434"></a><span class="lineno">  434</span>{</div>
<div class="line"><a id="l00435" name="l00435"></a><span class="lineno">  435</span>  dof_id_type local_id_index = 0;</div>
<div class="line"><a id="l00436" name="l00436"></a><span class="lineno">  436</span>  std::size_t node_unique_id_offset = 0;</div>
<div class="line"><a id="l00437" name="l00437"></a><span class="lineno">  437</span> </div>
<div class="line"><a id="l00438" name="l00438"></a><span class="lineno">  438</span>  <span class="comment">// Create an offset by the maximum number of mortar segment elements that can be created *plus*</span></div>
<div class="line"><a id="l00439" name="l00439"></a><span class="lineno">  439</span>  <span class="comment">// the number of lower-dimensional secondary subdomain elements. Recall that the number of mortar</span></div>
<div class="line"><a id="l00440" name="l00440"></a><span class="lineno">  440</span>  <span class="comment">// segments created is a function of node projection, *and* that if we split elems we will delete</span></div>
<div class="line"><a id="l00441" name="l00441"></a><span class="lineno">  441</span>  <span class="comment">// that elem which has already taken a unique id</span></div>
<div class="line"><a id="l00442" name="l00442"></a><span class="lineno">  442</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; pr : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a36e1a5b919de8cfdc39c8af4098fb450">_primary_secondary_boundary_id_pairs</a>)</div>
<div class="line"><a id="l00443" name="l00443"></a><span class="lineno">  443</span>  {</div>
<div class="line"><a id="l00444" name="l00444"></a><span class="lineno">  444</span>    <span class="keyword">const</span> <span class="keyword">auto</span> primary_bnd_id = pr.first;</div>
<div class="line"><a id="l00445" name="l00445"></a><span class="lineno">  445</span>    <span class="keyword">const</span> <span class="keyword">auto</span> secondary_bnd_id = pr.second;</div>
<div class="line"><a id="l00446" name="l00446"></a><span class="lineno">  446</span>    <span class="keyword">const</span> <span class="keyword">auto</span> num_primary_nodes =</div>
<div class="line"><a id="l00447" name="l00447"></a><span class="lineno">  447</span>        std::distance(<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.bid_nodes_begin(primary_bnd_id), <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.bid_nodes_end(primary_bnd_id));</div>
<div class="line"><a id="l00448" name="l00448"></a><span class="lineno">  448</span>    <span class="keyword">const</span> <span class="keyword">auto</span> num_secondary_nodes = std::distance(<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.bid_nodes_begin(secondary_bnd_id),</div>
<div class="line"><a id="l00449" name="l00449"></a><span class="lineno">  449</span>                                                   <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.bid_nodes_end(secondary_bnd_id));</div>
<div class="line"><a id="l00450" name="l00450"></a><span class="lineno">  450</span>    mooseAssert(num_primary_nodes,</div>
<div class="line"><a id="l00451" name="l00451"></a><span class="lineno">  451</span>                <span class="stringliteral">&quot;There are no primary nodes on boundary ID &quot;</span></div>
<div class="line"><a id="l00452" name="l00452"></a><span class="lineno">  452</span>                    &lt;&lt; primary_bnd_id &lt;&lt; <span class="stringliteral">&quot;. Does that bondary ID even exist on the mesh?&quot;</span>);</div>
<div class="line"><a id="l00453" name="l00453"></a><span class="lineno">  453</span>    mooseAssert(num_secondary_nodes,</div>
<div class="line"><a id="l00454" name="l00454"></a><span class="lineno">  454</span>                <span class="stringliteral">&quot;There are no secondary nodes on boundary ID &quot;</span></div>
<div class="line"><a id="l00455" name="l00455"></a><span class="lineno">  455</span>                    &lt;&lt; secondary_bnd_id &lt;&lt; <span class="stringliteral">&quot;. Does that bondary ID even exist on the mesh?&quot;</span>);</div>
<div class="line"><a id="l00456" name="l00456"></a><span class="lineno">  456</span> </div>
<div class="line"><a id="l00457" name="l00457"></a><span class="lineno">  457</span>    node_unique_id_offset += num_primary_nodes + 2 * num_secondary_nodes;</div>
<div class="line"><a id="l00458" name="l00458"></a><span class="lineno">  458</span>  }</div>
<div class="line"><a id="l00459" name="l00459"></a><span class="lineno">  459</span> </div>
<div class="line"><a id="l00460" name="l00460"></a><span class="lineno">  460</span>  <span class="comment">// 1.) Add all lower-dimensional secondary side elements as the &quot;initial&quot; mortar segments.</span></div>
<div class="line"><a id="l00461" name="l00461"></a><span class="lineno">  461</span>  <span class="keywordflow">for</span> (MeshBase::const_element_iterator el = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.active_elements_begin(),</div>
<div class="line"><a id="l00462" name="l00462"></a><span class="lineno">  462</span>                                        end_el = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.active_elements_end();</div>
<div class="line"><a id="l00463" name="l00463"></a><span class="lineno">  463</span>       el != end_el;</div>
<div class="line"><a id="l00464" name="l00464"></a><span class="lineno">  464</span>       ++el)</div>
<div class="line"><a id="l00465" name="l00465"></a><span class="lineno">  465</span>  {</div>
<div class="line"><a id="l00466" name="l00466"></a><span class="lineno">  466</span>    <span class="keyword">const</span> Elem * secondary_elem = *el;</div>
<div class="line"><a id="l00467" name="l00467"></a><span class="lineno">  467</span> </div>
<div class="line"><a id="l00468" name="l00468"></a><span class="lineno">  468</span>    <span class="comment">// If this is not one of the lower-dimensional secondary side elements, go on to the next one.</span></div>
<div class="line"><a id="l00469" name="l00469"></a><span class="lineno">  469</span>    <span class="keywordflow">if</span> (!this-&gt;<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a59c6fd297125023195e7bfb3714846c5">_secondary_boundary_subdomain_ids</a>.count(secondary_elem-&gt;subdomain_id()))</div>
<div class="line"><a id="l00470" name="l00470"></a><span class="lineno">  470</span>      <span class="keywordflow">continue</span>;</div>
<div class="line"><a id="l00471" name="l00471"></a><span class="lineno">  471</span> </div>
<div class="line"><a id="l00472" name="l00472"></a><span class="lineno">  472</span>    std::vector&lt;Node *&gt; new_nodes;</div>
<div class="line"><a id="l00473" name="l00473"></a><span class="lineno">  473</span>    <span class="keywordflow">for</span> (MooseIndex(secondary_elem-&gt;n_nodes()) n = 0; n &lt; secondary_elem-&gt;n_nodes(); ++n)</div>
<div class="line"><a id="l00474" name="l00474"></a><span class="lineno">  474</span>    {</div>
<div class="line"><a id="l00475" name="l00475"></a><span class="lineno">  475</span>      new_nodes.push_back(<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;add_point(</div>
<div class="line"><a id="l00476" name="l00476"></a><span class="lineno">  476</span>          secondary_elem-&gt;point(n), secondary_elem-&gt;node_id(n), secondary_elem-&gt;processor_id()));</div>
<div class="line"><a id="l00477" name="l00477"></a><span class="lineno">  477</span>      Node * <span class="keyword">const</span> new_node = new_nodes.back();</div>
<div class="line"><a id="l00478" name="l00478"></a><span class="lineno">  478</span>      new_node-&gt;set_unique_id(new_node-&gt;id() + node_unique_id_offset);</div>
<div class="line"><a id="l00479" name="l00479"></a><span class="lineno">  479</span>    }</div>
<div class="line"><a id="l00480" name="l00480"></a><span class="lineno">  480</span> </div>
<div class="line"><a id="l00481" name="l00481"></a><span class="lineno">  481</span>    std::unique_ptr&lt;Elem&gt; new_elem;</div>
<div class="line"><a id="l00482" name="l00482"></a><span class="lineno">  482</span>    <span class="keywordflow">if</span> (secondary_elem-&gt;default_order() == SECOND)</div>
<div class="line"><a id="l00483" name="l00483"></a><span class="lineno">  483</span>      new_elem = std::make_unique&lt;Edge3&gt;();</div>
<div class="line"><a id="l00484" name="l00484"></a><span class="lineno">  484</span>    <span class="keywordflow">else</span></div>
<div class="line"><a id="l00485" name="l00485"></a><span class="lineno">  485</span>      new_elem = std::make_unique&lt;Edge2&gt;();</div>
<div class="line"><a id="l00486" name="l00486"></a><span class="lineno">  486</span> </div>
<div class="line"><a id="l00487" name="l00487"></a><span class="lineno">  487</span>    new_elem-&gt;processor_id() = secondary_elem-&gt;processor_id();</div>
<div class="line"><a id="l00488" name="l00488"></a><span class="lineno">  488</span>    new_elem-&gt;subdomain_id() = secondary_elem-&gt;subdomain_id();</div>
<div class="line"><a id="l00489" name="l00489"></a><span class="lineno">  489</span>    new_elem-&gt;set_id(local_id_index++);</div>
<div class="line"><a id="l00490" name="l00490"></a><span class="lineno">  490</span>    new_elem-&gt;set_unique_id(new_elem-&gt;id());</div>
<div class="line"><a id="l00491" name="l00491"></a><span class="lineno">  491</span> </div>
<div class="line"><a id="l00492" name="l00492"></a><span class="lineno">  492</span>    <span class="keywordflow">for</span> (MooseIndex(new_elem-&gt;n_nodes()) n = 0; n &lt; new_elem-&gt;n_nodes(); ++n)</div>
<div class="line"><a id="l00493" name="l00493"></a><span class="lineno">  493</span>      new_elem-&gt;set_node(n) = new_nodes[n];</div>
<div class="line"><a id="l00494" name="l00494"></a><span class="lineno">  494</span> </div>
<div class="line"><a id="l00495" name="l00495"></a><span class="lineno">  495</span>    Elem * new_elem_ptr = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;add_elem(new_elem.release());</div>
<div class="line"><a id="l00496" name="l00496"></a><span class="lineno">  496</span> </div>
<div class="line"><a id="l00497" name="l00497"></a><span class="lineno">  497</span>    <span class="comment">// The xi^(1) values for this mortar segment are initially -1 and 1.</span></div>
<div class="line"><a id="l00498" name="l00498"></a><span class="lineno">  498</span>    <a class="code hl_struct" href="structMortarSegmentInfo.html">MortarSegmentInfo</a> msinfo;</div>
<div class="line"><a id="l00499" name="l00499"></a><span class="lineno">  499</span>    msinfo.<a class="code hl_variable" href="structMortarSegmentInfo.html#ad4205fbab31bbda066622c55c8e93b87">xi1_a</a> = -1;</div>
<div class="line"><a id="l00500" name="l00500"></a><span class="lineno">  500</span>    msinfo.<a class="code hl_variable" href="structMortarSegmentInfo.html#a648c7f480b2ce6404b1db1d21642b919">xi1_b</a> = +1;</div>
<div class="line"><a id="l00501" name="l00501"></a><span class="lineno">  501</span>    msinfo.<a class="code hl_variable" href="structMortarSegmentInfo.html#afa8c2918a473f0dad90d5c68dad00eb4">secondary_elem</a> = secondary_elem;</div>
<div class="line"><a id="l00502" name="l00502"></a><span class="lineno">  502</span> </div>
<div class="line"><a id="l00503" name="l00503"></a><span class="lineno">  503</span>    <span class="keyword">auto</span> new_container_it0 = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#abb4cc3e3102675e52675a95347ad8e95">_secondary_node_and_elem_to_xi2_primary_elem</a>.find(</div>
<div class="line"><a id="l00504" name="l00504"></a><span class="lineno">  504</span>             std::make_pair(secondary_elem-&gt;node_ptr(0), secondary_elem)),</div>
<div class="line"><a id="l00505" name="l00505"></a><span class="lineno">  505</span>         new_container_it1 = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#abb4cc3e3102675e52675a95347ad8e95">_secondary_node_and_elem_to_xi2_primary_elem</a>.find(</div>
<div class="line"><a id="l00506" name="l00506"></a><span class="lineno">  506</span>             std::make_pair(secondary_elem-&gt;node_ptr(1), secondary_elem));</div>
<div class="line"><a id="l00507" name="l00507"></a><span class="lineno">  507</span> </div>
<div class="line"><a id="l00508" name="l00508"></a><span class="lineno">  508</span>    <span class="keywordtype">bool</span> new_container_node0_found =</div>
<div class="line"><a id="l00509" name="l00509"></a><span class="lineno">  509</span>             (new_container_it0 != <a class="code hl_variable" href="classAutomaticMortarGeneration.html#abb4cc3e3102675e52675a95347ad8e95">_secondary_node_and_elem_to_xi2_primary_elem</a>.end()),</div>
<div class="line"><a id="l00510" name="l00510"></a><span class="lineno">  510</span>         new_container_node1_found =</div>
<div class="line"><a id="l00511" name="l00511"></a><span class="lineno">  511</span>             (new_container_it1 != <a class="code hl_variable" href="classAutomaticMortarGeneration.html#abb4cc3e3102675e52675a95347ad8e95">_secondary_node_and_elem_to_xi2_primary_elem</a>.end());</div>
<div class="line"><a id="l00512" name="l00512"></a><span class="lineno">  512</span> </div>
<div class="line"><a id="l00513" name="l00513"></a><span class="lineno">  513</span>    <span class="keyword">const</span> Elem * node0_primary_candidate = <span class="keyword">nullptr</span>;</div>
<div class="line"><a id="l00514" name="l00514"></a><span class="lineno">  514</span>    <span class="keyword">const</span> Elem * node1_primary_candidate = <span class="keyword">nullptr</span>;</div>
<div class="line"><a id="l00515" name="l00515"></a><span class="lineno">  515</span> </div>
<div class="line"><a id="l00516" name="l00516"></a><span class="lineno">  516</span>    <span class="keywordflow">if</span> (new_container_node0_found)</div>
<div class="line"><a id="l00517" name="l00517"></a><span class="lineno">  517</span>    {</div>
<div class="line"><a id="l00518" name="l00518"></a><span class="lineno">  518</span>      <span class="keyword">const</span> <span class="keyword">auto</span> &amp; xi2_primary_elem_pair = new_container_it0-&gt;second;</div>
<div class="line"><a id="l00519" name="l00519"></a><span class="lineno">  519</span>      msinfo.<a class="code hl_variable" href="structMortarSegmentInfo.html#abcfb0183363f3e21b43f9ffd3dc477b4">xi2_a</a> = xi2_primary_elem_pair.first;</div>
<div class="line"><a id="l00520" name="l00520"></a><span class="lineno">  520</span>      node0_primary_candidate = xi2_primary_elem_pair.second;</div>
<div class="line"><a id="l00521" name="l00521"></a><span class="lineno">  521</span>    }</div>
<div class="line"><a id="l00522" name="l00522"></a><span class="lineno">  522</span> </div>
<div class="line"><a id="l00523" name="l00523"></a><span class="lineno">  523</span>    <span class="keywordflow">if</span> (new_container_node1_found)</div>
<div class="line"><a id="l00524" name="l00524"></a><span class="lineno">  524</span>    {</div>
<div class="line"><a id="l00525" name="l00525"></a><span class="lineno">  525</span>      <span class="keyword">const</span> <span class="keyword">auto</span> &amp; xi2_primary_elem_pair = new_container_it1-&gt;second;</div>
<div class="line"><a id="l00526" name="l00526"></a><span class="lineno">  526</span>      msinfo.<a class="code hl_variable" href="structMortarSegmentInfo.html#a4fe559d3196b77718c1052ab7c1aa4d3">xi2_b</a> = xi2_primary_elem_pair.first;</div>
<div class="line"><a id="l00527" name="l00527"></a><span class="lineno">  527</span>      node1_primary_candidate = xi2_primary_elem_pair.second;</div>
<div class="line"><a id="l00528" name="l00528"></a><span class="lineno">  528</span>    }</div>
<div class="line"><a id="l00529" name="l00529"></a><span class="lineno">  529</span> </div>
<div class="line"><a id="l00530" name="l00530"></a><span class="lineno">  530</span>    <span class="comment">// If both node0 and node1 agree on the primary element they are</span></div>
<div class="line"><a id="l00531" name="l00531"></a><span class="lineno">  531</span>    <span class="comment">// projected into, then this mortar segment fits entirely within</span></div>
<div class="line"><a id="l00532" name="l00532"></a><span class="lineno">  532</span>    <span class="comment">// a single primary element, and we can go ahead and set the</span></div>
<div class="line"><a id="l00533" name="l00533"></a><span class="lineno">  533</span>    <span class="comment">// msinfo.primary_elem pointer now.</span></div>
<div class="line"><a id="l00534" name="l00534"></a><span class="lineno">  534</span>    <span class="keywordflow">if</span> (node0_primary_candidate == node1_primary_candidate)</div>
<div class="line"><a id="l00535" name="l00535"></a><span class="lineno">  535</span>      msinfo.<a class="code hl_variable" href="structMortarSegmentInfo.html#a3316fbff8584e06e3c973d3f3e6ff05f">primary_elem</a> = node0_primary_candidate;</div>
<div class="line"><a id="l00536" name="l00536"></a><span class="lineno">  536</span> </div>
<div class="line"><a id="l00537" name="l00537"></a><span class="lineno">  537</span>    <span class="comment">// Associate this MSM elem with the MortarSegmentInfo.</span></div>
<div class="line"><a id="l00538" name="l00538"></a><span class="lineno">  538</span>    <a class="code hl_variable" href="classAutomaticMortarGeneration.html#abbd91d3cf8bef528976fe6f932622d2d">_msm_elem_to_info</a>.emplace(new_elem_ptr, msinfo);</div>
<div class="line"><a id="l00539" name="l00539"></a><span class="lineno">  539</span> </div>
<div class="line"><a id="l00540" name="l00540"></a><span class="lineno">  540</span>    <span class="comment">// Maintain the mapping between secondary elems and mortar segment elems contained within them.</span></div>
<div class="line"><a id="l00541" name="l00541"></a><span class="lineno">  541</span>    <span class="comment">// Initially, only the original secondary_elem is present.</span></div>
<div class="line"><a id="l00542" name="l00542"></a><span class="lineno">  542</span>    <a class="code hl_variable" href="classAutomaticMortarGeneration.html#af0da3b7d9e404238718805e12452d74d">_secondary_elems_to_mortar_segments</a>[secondary_elem-&gt;id()].insert(new_elem_ptr);</div>
<div class="line"><a id="l00543" name="l00543"></a><span class="lineno">  543</span>  }</div>
<div class="line"><a id="l00544" name="l00544"></a><span class="lineno">  544</span> </div>
<div class="line"><a id="l00545" name="l00545"></a><span class="lineno">  545</span>  <span class="comment">// 2.) Insert new nodes from primary side and split mortar segments as necessary.</span></div>
<div class="line"><a id="l00546" name="l00546"></a><span class="lineno">  546</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; pr : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#ac174eedb02e9681baf439360903700d4">_primary_node_and_elem_to_xi1_secondary_elem</a>)</div>
<div class="line"><a id="l00547" name="l00547"></a><span class="lineno">  547</span>  {</div>
<div class="line"><a id="l00548" name="l00548"></a><span class="lineno">  548</span>    <span class="keyword">auto</span> key = pr.first;</div>
<div class="line"><a id="l00549" name="l00549"></a><span class="lineno">  549</span>    <span class="keyword">auto</span> val = pr.second;</div>
<div class="line"><a id="l00550" name="l00550"></a><span class="lineno">  550</span> </div>
<div class="line"><a id="l00551" name="l00551"></a><span class="lineno">  551</span>    <span class="keyword">const</span> Node * primary_node = std::get&lt;1&gt;(key);</div>
<div class="line"><a id="l00552" name="l00552"></a><span class="lineno">  552</span>    Real xi1 = val.first;</div>
<div class="line"><a id="l00553" name="l00553"></a><span class="lineno">  553</span>    <span class="keyword">const</span> Elem * secondary_elem = val.second;</div>
<div class="line"><a id="l00554" name="l00554"></a><span class="lineno">  554</span> </div>
<div class="line"><a id="l00555" name="l00555"></a><span class="lineno">  555</span>    <span class="comment">// If this is an aligned node, we don&#39;t need to do anything.</span></div>
<div class="line"><a id="l00556" name="l00556"></a><span class="lineno">  556</span>    <span class="keywordflow">if</span> (std::abs(std::abs(xi1) - 1.) &lt; <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a25f6f147b1b0a4b00e7c6739dd17b98c">_xi_tolerance</a>)</div>
<div class="line"><a id="l00557" name="l00557"></a><span class="lineno">  557</span>      <span class="keywordflow">continue</span>;</div>
<div class="line"><a id="l00558" name="l00558"></a><span class="lineno">  558</span> </div>
<div class="line"><a id="l00559" name="l00559"></a><span class="lineno">  559</span>    <span class="keyword">auto</span> &amp;&amp; order = secondary_elem-&gt;default_order();</div>
<div class="line"><a id="l00560" name="l00560"></a><span class="lineno">  560</span> </div>
<div class="line"><a id="l00561" name="l00561"></a><span class="lineno">  561</span>    <span class="comment">// Determine physical location of new point to be inserted.</span></div>
<div class="line"><a id="l00562" name="l00562"></a><span class="lineno">  562</span>    Point new_pt(0);</div>
<div class="line"><a id="l00563" name="l00563"></a><span class="lineno">  563</span>    <span class="keywordflow">for</span> (MooseIndex(secondary_elem-&gt;n_nodes()) n = 0; n &lt; secondary_elem-&gt;n_nodes(); ++n)</div>
<div class="line"><a id="l00564" name="l00564"></a><span class="lineno">  564</span>      new_pt += <a class="code hl_function" href="namespaceMoose.html#a9ed3373b5072c07f1f010afb75ac20c9">Moose::fe_lagrange_1D_shape</a>(order, n, xi1) * secondary_elem-&gt;point(n);</div>
<div class="line"><a id="l00565" name="l00565"></a><span class="lineno">  565</span> </div>
<div class="line"><a id="l00566" name="l00566"></a><span class="lineno">  566</span>    <span class="comment">// Find the current mortar segment that will have to be split.</span></div>
<div class="line"><a id="l00567" name="l00567"></a><span class="lineno">  567</span>    <span class="keyword">auto</span> &amp; mortar_segment_set = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#af0da3b7d9e404238718805e12452d74d">_secondary_elems_to_mortar_segments</a>[secondary_elem-&gt;id()];</div>
<div class="line"><a id="l00568" name="l00568"></a><span class="lineno">  568</span>    Elem * current_mortar_segment = <span class="keyword">nullptr</span>;</div>
<div class="line"><a id="l00569" name="l00569"></a><span class="lineno">  569</span>    <a class="code hl_struct" href="structMortarSegmentInfo.html">MortarSegmentInfo</a> * info = <span class="keyword">nullptr</span>;</div>
<div class="line"><a id="l00570" name="l00570"></a><span class="lineno">  570</span> </div>
<div class="line"><a id="l00571" name="l00571"></a><span class="lineno">  571</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; mortar_segment_candidate : mortar_segment_set)</div>
<div class="line"><a id="l00572" name="l00572"></a><span class="lineno">  572</span>    {</div>
<div class="line"><a id="l00573" name="l00573"></a><span class="lineno">  573</span>      <span class="keywordflow">try</span></div>
<div class="line"><a id="l00574" name="l00574"></a><span class="lineno">  574</span>      {</div>
<div class="line"><a id="l00575" name="l00575"></a><span class="lineno">  575</span>        info = &amp;<a class="code hl_variable" href="classAutomaticMortarGeneration.html#abbd91d3cf8bef528976fe6f932622d2d">_msm_elem_to_info</a>.at(mortar_segment_candidate);</div>
<div class="line"><a id="l00576" name="l00576"></a><span class="lineno">  576</span>      }</div>
<div class="line"><a id="l00577" name="l00577"></a><span class="lineno">  577</span>      <span class="keywordflow">catch</span> (std::out_of_range &amp;)</div>
<div class="line"><a id="l00578" name="l00578"></a><span class="lineno">  578</span>      {</div>
<div class="line"><a id="l00579" name="l00579"></a><span class="lineno">  579</span>        <a class="code hl_function" href="MooseError_8h.html#aa959168eed29caa7aaa85ffc1319a9ad">mooseError</a>(<span class="stringliteral">&quot;MortarSegmentInfo not found for the mortar segment candidate&quot;</span>);</div>
<div class="line"><a id="l00580" name="l00580"></a><span class="lineno">  580</span>      }</div>
<div class="line"><a id="l00581" name="l00581"></a><span class="lineno">  581</span>      <span class="keywordflow">if</span> (info-&gt;<a class="code hl_variable" href="structMortarSegmentInfo.html#ad4205fbab31bbda066622c55c8e93b87">xi1_a</a> &lt;= xi1 &amp;&amp; xi1 &lt;= info-&gt;xi1_b)</div>
<div class="line"><a id="l00582" name="l00582"></a><span class="lineno">  582</span>      {</div>
<div class="line"><a id="l00583" name="l00583"></a><span class="lineno">  583</span>        current_mortar_segment = mortar_segment_candidate;</div>
<div class="line"><a id="l00584" name="l00584"></a><span class="lineno">  584</span>        <span class="keywordflow">break</span>;</div>
<div class="line"><a id="l00585" name="l00585"></a><span class="lineno">  585</span>      }</div>
<div class="line"><a id="l00586" name="l00586"></a><span class="lineno">  586</span>    }</div>
<div class="line"><a id="l00587" name="l00587"></a><span class="lineno">  587</span> </div>
<div class="line"><a id="l00588" name="l00588"></a><span class="lineno">  588</span>    <span class="comment">// Make sure we found one.</span></div>
<div class="line"><a id="l00589" name="l00589"></a><span class="lineno">  589</span>    <span class="keywordflow">if</span> (current_mortar_segment == <span class="keyword">nullptr</span>)</div>
<div class="line"><a id="l00590" name="l00590"></a><span class="lineno">  590</span>      <a class="code hl_function" href="MooseError_8h.html#aa959168eed29caa7aaa85ffc1319a9ad">mooseError</a>(<span class="stringliteral">&quot;Unable to find appropriate mortar segment during linear search!&quot;</span>);</div>
<div class="line"><a id="l00591" name="l00591"></a><span class="lineno">  591</span> </div>
<div class="line"><a id="l00592" name="l00592"></a><span class="lineno">  592</span>    <span class="comment">// If node lands on endpoint of segment, don&#39;t split.</span></div>
<div class="line"><a id="l00593" name="l00593"></a><span class="lineno">  593</span>    <span class="comment">// Jacob: This condition was getting missed by the &lt; comparison a few lines above. To fix it I</span></div>
<div class="line"><a id="l00594" name="l00594"></a><span class="lineno">  594</span>    <span class="comment">// just made it &lt;= and put this condition in to handle equality different. It probably could be</span></div>
<div class="line"><a id="l00595" name="l00595"></a><span class="lineno">  595</span>    <span class="comment">// done with a tolerance but the the toleranced equality is already handled later when we drop</span></div>
<div class="line"><a id="l00596" name="l00596"></a><span class="lineno">  596</span>    <span class="comment">// segments with small volume.</span></div>
<div class="line"><a id="l00597" name="l00597"></a><span class="lineno">  597</span>    <span class="keywordflow">if</span> (info-&gt;<a class="code hl_variable" href="structMortarSegmentInfo.html#ad4205fbab31bbda066622c55c8e93b87">xi1_a</a> == xi1 || xi1 == info-&gt;<a class="code hl_variable" href="structMortarSegmentInfo.html#a648c7f480b2ce6404b1db1d21642b919">xi1_b</a>)</div>
<div class="line"><a id="l00598" name="l00598"></a><span class="lineno">  598</span>      <span class="keywordflow">continue</span>;</div>
<div class="line"><a id="l00599" name="l00599"></a><span class="lineno">  599</span> </div>
<div class="line"><a id="l00600" name="l00600"></a><span class="lineno">  600</span>    <span class="keyword">const</span> <span class="keyword">auto</span> new_id = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;max_node_id() + 1;</div>
<div class="line"><a id="l00601" name="l00601"></a><span class="lineno">  601</span>    mooseAssert(<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;comm().verify(new_id),</div>
<div class="line"><a id="l00602" name="l00602"></a><span class="lineno">  602</span>                <span class="stringliteral">&quot;new_id must be the same on all processes&quot;</span>);</div>
<div class="line"><a id="l00603" name="l00603"></a><span class="lineno">  603</span>    Node * <span class="keyword">const</span> new_node =</div>
<div class="line"><a id="l00604" name="l00604"></a><span class="lineno">  604</span>        <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;add_point(new_pt, new_id, secondary_elem-&gt;processor_id());</div>
<div class="line"><a id="l00605" name="l00605"></a><span class="lineno">  605</span>    new_node-&gt;set_unique_id(new_id + node_unique_id_offset);</div>
<div class="line"><a id="l00606" name="l00606"></a><span class="lineno">  606</span> </div>
<div class="line"><a id="l00607" name="l00607"></a><span class="lineno">  607</span>    <span class="comment">// Reconstruct the nodal normal at xi1. This will help us</span></div>
<div class="line"><a id="l00608" name="l00608"></a><span class="lineno">  608</span>    <span class="comment">// determine the orientation of the primary elems relative to the</span></div>
<div class="line"><a id="l00609" name="l00609"></a><span class="lineno">  609</span>    <span class="comment">// new mortar segments.</span></div>
<div class="line"><a id="l00610" name="l00610"></a><span class="lineno">  610</span>    <span class="keyword">const</span> Point normal = <a class="code hl_function" href="classAutomaticMortarGeneration.html#a71eb5cecb4437a9a0edfe8d5ce38007e">getNormals</a>(*secondary_elem, std::vector&lt;Real&gt;({xi1}))[0];</div>
<div class="line"><a id="l00611" name="l00611"></a><span class="lineno">  611</span> </div>
<div class="line"><a id="l00612" name="l00612"></a><span class="lineno">  612</span>    <span class="comment">// Get the set of primary_node neighbors.</span></div>
<div class="line"><a id="l00613" name="l00613"></a><span class="lineno">  613</span>    <span class="keywordflow">if</span> (this-&gt;<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a1ee9b6e4f8bd88603e22117085758f70">_nodes_to_primary_elem_map</a>.find(primary_node-&gt;id()) ==</div>
<div class="line"><a id="l00614" name="l00614"></a><span class="lineno">  614</span>        this-&gt;_nodes_to_primary_elem_map.end())</div>
<div class="line"><a id="l00615" name="l00615"></a><span class="lineno">  615</span>      <a class="code hl_function" href="MooseError_8h.html#aa959168eed29caa7aaa85ffc1319a9ad">mooseError</a>(<span class="stringliteral">&quot;We should already have built this primary node to elem pair!&quot;</span>);</div>
<div class="line"><a id="l00616" name="l00616"></a><span class="lineno">  616</span>    <span class="keyword">const</span> std::vector&lt;const Elem *&gt; &amp; primary_node_neighbors =</div>
<div class="line"><a id="l00617" name="l00617"></a><span class="lineno">  617</span>        this-&gt;<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a1ee9b6e4f8bd88603e22117085758f70">_nodes_to_primary_elem_map</a>[primary_node-&gt;id()];</div>
<div class="line"><a id="l00618" name="l00618"></a><span class="lineno">  618</span> </div>
<div class="line"><a id="l00619" name="l00619"></a><span class="lineno">  619</span>    <span class="comment">// Sanity check</span></div>
<div class="line"><a id="l00620" name="l00620"></a><span class="lineno">  620</span>    <span class="keywordflow">if</span> (primary_node_neighbors.size() == 0 || primary_node_neighbors.size() &gt; 2)</div>
<div class="line"><a id="l00621" name="l00621"></a><span class="lineno">  621</span>      <a class="code hl_function" href="MooseError_8h.html#aa959168eed29caa7aaa85ffc1319a9ad">mooseError</a>(<span class="stringliteral">&quot;We must have either 1 or 2 primary side nodal neighbors, but we had &quot;</span>,</div>
<div class="line"><a id="l00622" name="l00622"></a><span class="lineno">  622</span>                 primary_node_neighbors.size());</div>
<div class="line"><a id="l00623" name="l00623"></a><span class="lineno">  623</span> </div>
<div class="line"><a id="l00624" name="l00624"></a><span class="lineno">  624</span>    <span class="comment">// Primary Elem pointers which we will eventually assign to the</span></div>
<div class="line"><a id="l00625" name="l00625"></a><span class="lineno">  625</span>    <span class="comment">// mortar segments being created.  We start by assuming</span></div>
<div class="line"><a id="l00626" name="l00626"></a><span class="lineno">  626</span>    <span class="comment">// primary_node_neighbor[0] is on the &quot;left&quot; and</span></div>
<div class="line"><a id="l00627" name="l00627"></a><span class="lineno">  627</span>    <span class="comment">// primary_node_neighbor[1]/&quot;nothing&quot; is on the &quot;right&quot; and then</span></div>
<div class="line"><a id="l00628" name="l00628"></a><span class="lineno">  628</span>    <span class="comment">// swap them if that&#39;s not the case.</span></div>
<div class="line"><a id="l00629" name="l00629"></a><span class="lineno">  629</span>    <span class="keyword">const</span> Elem * left_primary_elem = primary_node_neighbors[0];</div>
<div class="line"><a id="l00630" name="l00630"></a><span class="lineno">  630</span>    <span class="keyword">const</span> Elem * right_primary_elem =</div>
<div class="line"><a id="l00631" name="l00631"></a><span class="lineno">  631</span>        (primary_node_neighbors.size() == 2) ? primary_node_neighbors[1] : <span class="keyword">nullptr</span>;</div>
<div class="line"><a id="l00632" name="l00632"></a><span class="lineno">  632</span> </div>
<div class="line"><a id="l00633" name="l00633"></a><span class="lineno">  633</span>    Real left_xi2 = <a class="code hl_variable" href="structMortarSegmentInfo.html#ae240d424b2112e4d23e66597318160ca">MortarSegmentInfo::invalid_xi</a>, right_xi2 = <a class="code hl_variable" href="structMortarSegmentInfo.html#ae240d424b2112e4d23e66597318160ca">MortarSegmentInfo::invalid_xi</a>;</div>
<div class="line"><a id="l00634" name="l00634"></a><span class="lineno">  634</span> </div>
<div class="line"><a id="l00635" name="l00635"></a><span class="lineno">  635</span>    <span class="comment">// Storage for z-component of cross products for determining</span></div>
<div class="line"><a id="l00636" name="l00636"></a><span class="lineno">  636</span>    <span class="comment">// orientation.</span></div>
<div class="line"><a id="l00637" name="l00637"></a><span class="lineno">  637</span>    std::array&lt;Real, 2&gt; secondary_node_cps;</div>
<div class="line"><a id="l00638" name="l00638"></a><span class="lineno">  638</span>    std::vector&lt;Real&gt; primary_node_cps(primary_node_neighbors.size());</div>
<div class="line"><a id="l00639" name="l00639"></a><span class="lineno">  639</span> </div>
<div class="line"><a id="l00640" name="l00640"></a><span class="lineno">  640</span>    <span class="comment">// Store z-component of left and right secondary node cross products with the nodal normal.</span></div>
<div class="line"><a id="l00641" name="l00641"></a><span class="lineno">  641</span>    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nid = 0; nid &lt; 2; ++nid)</div>
<div class="line"><a id="l00642" name="l00642"></a><span class="lineno">  642</span>      secondary_node_cps[nid] = normal.cross(secondary_elem-&gt;point(nid) - new_pt)(2);</div>
<div class="line"><a id="l00643" name="l00643"></a><span class="lineno">  643</span> </div>
<div class="line"><a id="l00644" name="l00644"></a><span class="lineno">  644</span>    <span class="keywordflow">for</span> (MooseIndex(primary_node_neighbors) mnn = 0; mnn &lt; primary_node_neighbors.size(); ++mnn)</div>
<div class="line"><a id="l00645" name="l00645"></a><span class="lineno">  645</span>    {</div>
<div class="line"><a id="l00646" name="l00646"></a><span class="lineno">  646</span>      <span class="keyword">const</span> Elem * primary_neigh = primary_node_neighbors[mnn];</div>
<div class="line"><a id="l00647" name="l00647"></a><span class="lineno">  647</span>      Point opposite = (primary_neigh-&gt;node_ptr(0) == primary_node) ? primary_neigh-&gt;point(1)</div>
<div class="line"><a id="l00648" name="l00648"></a><span class="lineno">  648</span>                                                                    : primary_neigh-&gt;point(0);</div>
<div class="line"><a id="l00649" name="l00649"></a><span class="lineno">  649</span>      Point cp = normal.cross(opposite - new_pt);</div>
<div class="line"><a id="l00650" name="l00650"></a><span class="lineno">  650</span>      primary_node_cps[mnn] = cp(2);</div>
<div class="line"><a id="l00651" name="l00651"></a><span class="lineno">  651</span>    }</div>
<div class="line"><a id="l00652" name="l00652"></a><span class="lineno">  652</span> </div>
<div class="line"><a id="l00653" name="l00653"></a><span class="lineno">  653</span>    <span class="comment">// We will verify that only 1 orientation is actually valid.</span></div>
<div class="line"><a id="l00654" name="l00654"></a><span class="lineno">  654</span>    <span class="keywordtype">bool</span> orientation1_valid = <span class="keyword">false</span>, orientation2_valid = <span class="keyword">false</span>;</div>
<div class="line"><a id="l00655" name="l00655"></a><span class="lineno">  655</span> </div>
<div class="line"><a id="l00656" name="l00656"></a><span class="lineno">  656</span>    <span class="keywordflow">if</span> (primary_node_neighbors.size() == 2)</div>
<div class="line"><a id="l00657" name="l00657"></a><span class="lineno">  657</span>    {</div>
<div class="line"><a id="l00658" name="l00658"></a><span class="lineno">  658</span>      <span class="comment">// 2 primary neighbor case</span></div>
<div class="line"><a id="l00659" name="l00659"></a><span class="lineno">  659</span>      orientation1_valid = (secondary_node_cps[0] * primary_node_cps[0] &gt; 0.) &amp;&amp;</div>
<div class="line"><a id="l00660" name="l00660"></a><span class="lineno">  660</span>                           (secondary_node_cps[1] * primary_node_cps[1] &gt; 0.);</div>
<div class="line"><a id="l00661" name="l00661"></a><span class="lineno">  661</span> </div>
<div class="line"><a id="l00662" name="l00662"></a><span class="lineno">  662</span>      orientation2_valid = (secondary_node_cps[0] * primary_node_cps[1] &gt; 0.) &amp;&amp;</div>
<div class="line"><a id="l00663" name="l00663"></a><span class="lineno">  663</span>                           (secondary_node_cps[1] * primary_node_cps[0] &gt; 0.);</div>
<div class="line"><a id="l00664" name="l00664"></a><span class="lineno">  664</span>    }</div>
<div class="line"><a id="l00665" name="l00665"></a><span class="lineno">  665</span>    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (primary_node_neighbors.size() == 1)</div>
<div class="line"><a id="l00666" name="l00666"></a><span class="lineno">  666</span>    {</div>
<div class="line"><a id="l00667" name="l00667"></a><span class="lineno">  667</span>      <span class="comment">// 1 primary neighbor case</span></div>
<div class="line"><a id="l00668" name="l00668"></a><span class="lineno">  668</span>      orientation1_valid = (secondary_node_cps[0] * primary_node_cps[0] &gt; 0.);</div>
<div class="line"><a id="l00669" name="l00669"></a><span class="lineno">  669</span>      orientation2_valid = (secondary_node_cps[1] * primary_node_cps[0] &gt; 0.);</div>
<div class="line"><a id="l00670" name="l00670"></a><span class="lineno">  670</span>    }</div>
<div class="line"><a id="l00671" name="l00671"></a><span class="lineno">  671</span>    <span class="keywordflow">else</span></div>
<div class="line"><a id="l00672" name="l00672"></a><span class="lineno">  672</span>      <a class="code hl_function" href="MooseError_8h.html#aa959168eed29caa7aaa85ffc1319a9ad">mooseError</a>(<span class="stringliteral">&quot;Invalid primary node neighbors size &quot;</span>, primary_node_neighbors.size());</div>
<div class="line"><a id="l00673" name="l00673"></a><span class="lineno">  673</span> </div>
<div class="line"><a id="l00674" name="l00674"></a><span class="lineno">  674</span>    <span class="comment">// Verify that both orientations are not simultaneously valid/invalid. If they are not, then we</span></div>
<div class="line"><a id="l00675" name="l00675"></a><span class="lineno">  675</span>    <span class="comment">// are going to throw an exception instead of erroring out since we can easily reach this point</span></div>
<div class="line"><a id="l00676" name="l00676"></a><span class="lineno">  676</span>    <span class="comment">// if we have one bad linear solve. It&#39;s better in general to catch the error and then try a</span></div>
<div class="line"><a id="l00677" name="l00677"></a><span class="lineno">  677</span>    <span class="comment">// smaller time-step</span></div>
<div class="line"><a id="l00678" name="l00678"></a><span class="lineno">  678</span>    <span class="keywordflow">if</span> (orientation1_valid &amp;&amp; orientation2_valid)</div>
<div class="line"><a id="l00679" name="l00679"></a><span class="lineno">  679</span>      <span class="keywordflow">throw</span> <a class="code hl_class" href="classMooseException.html">MooseException</a>(</div>
<div class="line"><a id="l00680" name="l00680"></a><span class="lineno">  680</span>          <span class="stringliteral">&quot;AutomaticMortarGeneration: Both orientations cannot simultaneously be valid.&quot;</span>);</div>
<div class="line"><a id="l00681" name="l00681"></a><span class="lineno">  681</span> </div>
<div class="line"><a id="l00682" name="l00682"></a><span class="lineno">  682</span>    <span class="comment">// We are going to treat the case where both orientations are invalid as a case in which we</span></div>
<div class="line"><a id="l00683" name="l00683"></a><span class="lineno">  683</span>    <span class="comment">// should not be splitting the mortar mesh to incorporate primary mesh elements.</span></div>
<div class="line"><a id="l00684" name="l00684"></a><span class="lineno">  684</span>    <span class="comment">// In practice, this case has appeared for very oblique projections, so we assume these cases</span></div>
<div class="line"><a id="l00685" name="l00685"></a><span class="lineno">  685</span>    <span class="comment">// will not be considered in mortar thermomechanical contact.</span></div>
<div class="line"><a id="l00686" name="l00686"></a><span class="lineno">  686</span>    <span class="keywordflow">if</span> (!orientation1_valid &amp;&amp; !orientation2_valid)</div>
<div class="line"><a id="l00687" name="l00687"></a><span class="lineno">  687</span>    {</div>
<div class="line"><a id="l00688" name="l00688"></a><span class="lineno">  688</span>      mooseDoOnce(<a class="code hl_function" href="MooseError_8h.html#a3d351254665674621ecbd38f57bb28ae">mooseWarning</a>(</div>
<div class="line"><a id="l00689" name="l00689"></a><span class="lineno">  689</span>          <span class="stringliteral">&quot;AutomaticMortarGeneration: Unable to determine valid secondary-primary orientation. &quot;</span></div>
<div class="line"><a id="l00690" name="l00690"></a><span class="lineno">  690</span>          <span class="stringliteral">&quot;Consequently we will consider projection of the primary node invalid and not split the &quot;</span></div>
<div class="line"><a id="l00691" name="l00691"></a><span class="lineno">  691</span>          <span class="stringliteral">&quot;mortar segment. &quot;</span></div>
<div class="line"><a id="l00692" name="l00692"></a><span class="lineno">  692</span>          <span class="stringliteral">&quot;This situation can indicate there are very oblique projections between primary (mortar) &quot;</span></div>
<div class="line"><a id="l00693" name="l00693"></a><span class="lineno">  693</span>          <span class="stringliteral">&quot;and secondary (non-mortar) surfaces for a good problem set up. It can also mean your &quot;</span></div>
<div class="line"><a id="l00694" name="l00694"></a><span class="lineno">  694</span>          <span class="stringliteral">&quot;time step is too large. This message is only printed once.&quot;</span>));</div>
<div class="line"><a id="l00695" name="l00695"></a><span class="lineno">  695</span>      <span class="keywordflow">continue</span>;</div>
<div class="line"><a id="l00696" name="l00696"></a><span class="lineno">  696</span>    }</div>
<div class="line"><a id="l00697" name="l00697"></a><span class="lineno">  697</span> </div>
<div class="line"><a id="l00698" name="l00698"></a><span class="lineno">  698</span>    <span class="comment">// Make an Elem on the left</span></div>
<div class="line"><a id="l00699" name="l00699"></a><span class="lineno">  699</span>    std::unique_ptr&lt;Elem&gt; new_elem_left;</div>
<div class="line"><a id="l00700" name="l00700"></a><span class="lineno">  700</span>    <span class="keywordflow">if</span> (order == SECOND)</div>
<div class="line"><a id="l00701" name="l00701"></a><span class="lineno">  701</span>      new_elem_left = std::make_unique&lt;Edge3&gt;();</div>
<div class="line"><a id="l00702" name="l00702"></a><span class="lineno">  702</span>    <span class="keywordflow">else</span></div>
<div class="line"><a id="l00703" name="l00703"></a><span class="lineno">  703</span>      new_elem_left = std::make_unique&lt;Edge2&gt;();</div>
<div class="line"><a id="l00704" name="l00704"></a><span class="lineno">  704</span> </div>
<div class="line"><a id="l00705" name="l00705"></a><span class="lineno">  705</span>    new_elem_left-&gt;processor_id() = current_mortar_segment-&gt;processor_id();</div>
<div class="line"><a id="l00706" name="l00706"></a><span class="lineno">  706</span>    new_elem_left-&gt;subdomain_id() = current_mortar_segment-&gt;subdomain_id();</div>
<div class="line"><a id="l00707" name="l00707"></a><span class="lineno">  707</span>    new_elem_left-&gt;set_id(local_id_index++);</div>
<div class="line"><a id="l00708" name="l00708"></a><span class="lineno">  708</span>    new_elem_left-&gt;set_unique_id(new_elem_left-&gt;id());</div>
<div class="line"><a id="l00709" name="l00709"></a><span class="lineno">  709</span>    new_elem_left-&gt;set_node(0) = current_mortar_segment-&gt;node_ptr(0);</div>
<div class="line"><a id="l00710" name="l00710"></a><span class="lineno">  710</span>    new_elem_left-&gt;set_node(1) = new_node;</div>
<div class="line"><a id="l00711" name="l00711"></a><span class="lineno">  711</span> </div>
<div class="line"><a id="l00712" name="l00712"></a><span class="lineno">  712</span>    <span class="comment">// Make an Elem on the right</span></div>
<div class="line"><a id="l00713" name="l00713"></a><span class="lineno">  713</span>    std::unique_ptr&lt;Elem&gt; new_elem_right;</div>
<div class="line"><a id="l00714" name="l00714"></a><span class="lineno">  714</span>    <span class="keywordflow">if</span> (order == SECOND)</div>
<div class="line"><a id="l00715" name="l00715"></a><span class="lineno">  715</span>      new_elem_right = std::make_unique&lt;Edge3&gt;();</div>
<div class="line"><a id="l00716" name="l00716"></a><span class="lineno">  716</span>    <span class="keywordflow">else</span></div>
<div class="line"><a id="l00717" name="l00717"></a><span class="lineno">  717</span>      new_elem_right = std::make_unique&lt;Edge2&gt;();</div>
<div class="line"><a id="l00718" name="l00718"></a><span class="lineno">  718</span> </div>
<div class="line"><a id="l00719" name="l00719"></a><span class="lineno">  719</span>    new_elem_right-&gt;processor_id() = current_mortar_segment-&gt;processor_id();</div>
<div class="line"><a id="l00720" name="l00720"></a><span class="lineno">  720</span>    new_elem_right-&gt;subdomain_id() = current_mortar_segment-&gt;subdomain_id();</div>
<div class="line"><a id="l00721" name="l00721"></a><span class="lineno">  721</span>    new_elem_right-&gt;set_id(local_id_index++);</div>
<div class="line"><a id="l00722" name="l00722"></a><span class="lineno">  722</span>    new_elem_right-&gt;set_unique_id(new_elem_right-&gt;id());</div>
<div class="line"><a id="l00723" name="l00723"></a><span class="lineno">  723</span>    new_elem_right-&gt;set_node(0) = new_node;</div>
<div class="line"><a id="l00724" name="l00724"></a><span class="lineno">  724</span>    new_elem_right-&gt;set_node(1) = current_mortar_segment-&gt;node_ptr(1);</div>
<div class="line"><a id="l00725" name="l00725"></a><span class="lineno">  725</span> </div>
<div class="line"><a id="l00726" name="l00726"></a><span class="lineno">  726</span>    <span class="keywordflow">if</span> (order == SECOND)</div>
<div class="line"><a id="l00727" name="l00727"></a><span class="lineno">  727</span>    {</div>
<div class="line"><a id="l00728" name="l00728"></a><span class="lineno">  728</span>      <span class="comment">// left</span></div>
<div class="line"><a id="l00729" name="l00729"></a><span class="lineno">  729</span>      Point left_interior_point(0);</div>
<div class="line"><a id="l00730" name="l00730"></a><span class="lineno">  730</span>      Real left_interior_xi = (xi1 + info-&gt;<a class="code hl_variable" href="structMortarSegmentInfo.html#ad4205fbab31bbda066622c55c8e93b87">xi1_a</a>) / 2;</div>
<div class="line"><a id="l00731" name="l00731"></a><span class="lineno">  731</span> </div>
<div class="line"><a id="l00732" name="l00732"></a><span class="lineno">  732</span>      <span class="comment">// This is eta for the current mortar segment that we&#39;re splitting</span></div>
<div class="line"><a id="l00733" name="l00733"></a><span class="lineno">  733</span>      Real current_left_interior_eta =</div>
<div class="line"><a id="l00734" name="l00734"></a><span class="lineno">  734</span>          (2. * left_interior_xi - info-&gt;<a class="code hl_variable" href="structMortarSegmentInfo.html#ad4205fbab31bbda066622c55c8e93b87">xi1_a</a> - info-&gt;<a class="code hl_variable" href="structMortarSegmentInfo.html#a648c7f480b2ce6404b1db1d21642b919">xi1_b</a>) / (info-&gt;<a class="code hl_variable" href="structMortarSegmentInfo.html#a648c7f480b2ce6404b1db1d21642b919">xi1_b</a> - info-&gt;<a class="code hl_variable" href="structMortarSegmentInfo.html#ad4205fbab31bbda066622c55c8e93b87">xi1_a</a>);</div>
<div class="line"><a id="l00735" name="l00735"></a><span class="lineno">  735</span> </div>
<div class="line"><a id="l00736" name="l00736"></a><span class="lineno">  736</span>      <span class="keywordflow">for</span> (MooseIndex(current_mortar_segment-&gt;n_nodes()) n = 0;</div>
<div class="line"><a id="l00737" name="l00737"></a><span class="lineno">  737</span>           n &lt; current_mortar_segment-&gt;n_nodes();</div>
<div class="line"><a id="l00738" name="l00738"></a><span class="lineno">  738</span>           ++n)</div>
<div class="line"><a id="l00739" name="l00739"></a><span class="lineno">  739</span>        left_interior_point += <a class="code hl_function" href="namespaceMoose.html#a9ed3373b5072c07f1f010afb75ac20c9">Moose::fe_lagrange_1D_shape</a>(order, n, current_left_interior_eta) *</div>
<div class="line"><a id="l00740" name="l00740"></a><span class="lineno">  740</span>                               current_mortar_segment-&gt;point(n);</div>
<div class="line"><a id="l00741" name="l00741"></a><span class="lineno">  741</span> </div>
<div class="line"><a id="l00742" name="l00742"></a><span class="lineno">  742</span>      <span class="keyword">const</span> <span class="keyword">auto</span> new_interior_left_id = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;max_node_id() + 1;</div>
<div class="line"><a id="l00743" name="l00743"></a><span class="lineno">  743</span>      mooseAssert(<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;comm().verify(new_interior_left_id),</div>
<div class="line"><a id="l00744" name="l00744"></a><span class="lineno">  744</span>                  <span class="stringliteral">&quot;new_id must be the same on all processes&quot;</span>);</div>
<div class="line"><a id="l00745" name="l00745"></a><span class="lineno">  745</span>      Node * <span class="keyword">const</span> new_interior_node_left = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;add_point(</div>
<div class="line"><a id="l00746" name="l00746"></a><span class="lineno">  746</span>          left_interior_point, new_interior_left_id, new_elem_left-&gt;processor_id());</div>
<div class="line"><a id="l00747" name="l00747"></a><span class="lineno">  747</span>      new_elem_left-&gt;set_node(2) = new_interior_node_left;</div>
<div class="line"><a id="l00748" name="l00748"></a><span class="lineno">  748</span>      new_interior_node_left-&gt;set_unique_id(new_interior_left_id + node_unique_id_offset);</div>
<div class="line"><a id="l00749" name="l00749"></a><span class="lineno">  749</span> </div>
<div class="line"><a id="l00750" name="l00750"></a><span class="lineno">  750</span>      <span class="comment">// right</span></div>
<div class="line"><a id="l00751" name="l00751"></a><span class="lineno">  751</span>      Point right_interior_point(0);</div>
<div class="line"><a id="l00752" name="l00752"></a><span class="lineno">  752</span>      Real right_interior_xi = (xi1 + info-&gt;<a class="code hl_variable" href="structMortarSegmentInfo.html#a648c7f480b2ce6404b1db1d21642b919">xi1_b</a>) / 2;</div>
<div class="line"><a id="l00753" name="l00753"></a><span class="lineno">  753</span>      <span class="comment">// This is eta for the current mortar segment that we&#39;re splitting</span></div>
<div class="line"><a id="l00754" name="l00754"></a><span class="lineno">  754</span>      Real current_right_interior_eta =</div>
<div class="line"><a id="l00755" name="l00755"></a><span class="lineno">  755</span>          (2. * right_interior_xi - info-&gt;<a class="code hl_variable" href="structMortarSegmentInfo.html#ad4205fbab31bbda066622c55c8e93b87">xi1_a</a> - info-&gt;<a class="code hl_variable" href="structMortarSegmentInfo.html#a648c7f480b2ce6404b1db1d21642b919">xi1_b</a>) / (info-&gt;<a class="code hl_variable" href="structMortarSegmentInfo.html#a648c7f480b2ce6404b1db1d21642b919">xi1_b</a> - info-&gt;<a class="code hl_variable" href="structMortarSegmentInfo.html#ad4205fbab31bbda066622c55c8e93b87">xi1_a</a>);</div>
<div class="line"><a id="l00756" name="l00756"></a><span class="lineno">  756</span> </div>
<div class="line"><a id="l00757" name="l00757"></a><span class="lineno">  757</span>      <span class="keywordflow">for</span> (MooseIndex(current_mortar_segment-&gt;n_nodes()) n = 0;</div>
<div class="line"><a id="l00758" name="l00758"></a><span class="lineno">  758</span>           n &lt; current_mortar_segment-&gt;n_nodes();</div>
<div class="line"><a id="l00759" name="l00759"></a><span class="lineno">  759</span>           ++n)</div>
<div class="line"><a id="l00760" name="l00760"></a><span class="lineno">  760</span>        right_interior_point += <a class="code hl_function" href="namespaceMoose.html#a9ed3373b5072c07f1f010afb75ac20c9">Moose::fe_lagrange_1D_shape</a>(order, n, current_right_interior_eta) *</div>
<div class="line"><a id="l00761" name="l00761"></a><span class="lineno">  761</span>                                current_mortar_segment-&gt;point(n);</div>
<div class="line"><a id="l00762" name="l00762"></a><span class="lineno">  762</span> </div>
<div class="line"><a id="l00763" name="l00763"></a><span class="lineno">  763</span>      <span class="keyword">const</span> <span class="keyword">auto</span> new_interior_id_right = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;max_node_id() + 1;</div>
<div class="line"><a id="l00764" name="l00764"></a><span class="lineno">  764</span>      mooseAssert(<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;comm().verify(new_interior_id_right),</div>
<div class="line"><a id="l00765" name="l00765"></a><span class="lineno">  765</span>                  <span class="stringliteral">&quot;new_id must be the same on all processes&quot;</span>);</div>
<div class="line"><a id="l00766" name="l00766"></a><span class="lineno">  766</span>      Node * <span class="keyword">const</span> new_interior_node_right = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;add_point(</div>
<div class="line"><a id="l00767" name="l00767"></a><span class="lineno">  767</span>          right_interior_point, new_interior_id_right, new_elem_right-&gt;processor_id());</div>
<div class="line"><a id="l00768" name="l00768"></a><span class="lineno">  768</span>      new_elem_right-&gt;set_node(2) = new_interior_node_right;</div>
<div class="line"><a id="l00769" name="l00769"></a><span class="lineno">  769</span>      new_interior_node_right-&gt;set_unique_id(new_interior_id_right + node_unique_id_offset);</div>
<div class="line"><a id="l00770" name="l00770"></a><span class="lineno">  770</span>    }</div>
<div class="line"><a id="l00771" name="l00771"></a><span class="lineno">  771</span> </div>
<div class="line"><a id="l00772" name="l00772"></a><span class="lineno">  772</span>    <span class="comment">// If orientation 2 was valid, swap the left and right primaries.</span></div>
<div class="line"><a id="l00773" name="l00773"></a><span class="lineno">  773</span>    <span class="keywordflow">if</span> (orientation2_valid)</div>
<div class="line"><a id="l00774" name="l00774"></a><span class="lineno">  774</span>      std::swap(left_primary_elem, right_primary_elem);</div>
<div class="line"><a id="l00775" name="l00775"></a><span class="lineno">  775</span> </div>
<div class="line"><a id="l00776" name="l00776"></a><span class="lineno">  776</span>    <span class="comment">// Now that we know left_primary_elem and right_primary_elem, we can determine left_xi2 and</span></div>
<div class="line"><a id="l00777" name="l00777"></a><span class="lineno">  777</span>    <span class="comment">// right_xi2.</span></div>
<div class="line"><a id="l00778" name="l00778"></a><span class="lineno">  778</span>    <span class="keywordflow">if</span> (left_primary_elem)</div>
<div class="line"><a id="l00779" name="l00779"></a><span class="lineno">  779</span>      left_xi2 = (primary_node == left_primary_elem-&gt;node_ptr(0)) ? -1 : +1;</div>
<div class="line"><a id="l00780" name="l00780"></a><span class="lineno">  780</span>    <span class="keywordflow">if</span> (right_primary_elem)</div>
<div class="line"><a id="l00781" name="l00781"></a><span class="lineno">  781</span>      right_xi2 = (primary_node == right_primary_elem-&gt;node_ptr(0)) ? -1 : +1;</div>
<div class="line"><a id="l00782" name="l00782"></a><span class="lineno">  782</span> </div>
<div class="line"><a id="l00783" name="l00783"></a><span class="lineno">  783</span>    <span class="comment">// Grab the MortarSegmentInfo object associated with this</span></div>
<div class="line"><a id="l00784" name="l00784"></a><span class="lineno">  784</span>    <span class="comment">// segment. We can use &quot;at()&quot; here since we want this to fail if</span></div>
<div class="line"><a id="l00785" name="l00785"></a><span class="lineno">  785</span>    <span class="comment">// current_mortar_segment is not found... Since we&#39;re going to</span></div>
<div class="line"><a id="l00786" name="l00786"></a><span class="lineno">  786</span>    <span class="comment">// erase this entry from the map momentarily, we make an actual</span></div>
<div class="line"><a id="l00787" name="l00787"></a><span class="lineno">  787</span>    <span class="comment">// copy rather than grabbing a reference.</span></div>
<div class="line"><a id="l00788" name="l00788"></a><span class="lineno">  788</span>    <span class="keyword">auto</span> msm_it = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#abbd91d3cf8bef528976fe6f932622d2d">_msm_elem_to_info</a>.find(current_mortar_segment);</div>
<div class="line"><a id="l00789" name="l00789"></a><span class="lineno">  789</span>    <span class="keywordflow">if</span> (msm_it == <a class="code hl_variable" href="classAutomaticMortarGeneration.html#abbd91d3cf8bef528976fe6f932622d2d">_msm_elem_to_info</a>.end())</div>
<div class="line"><a id="l00790" name="l00790"></a><span class="lineno">  790</span>      <a class="code hl_function" href="MooseError_8h.html#aa959168eed29caa7aaa85ffc1319a9ad">mooseError</a>(<span class="stringliteral">&quot;MortarSegmentInfo not found for current_mortar_segment.&quot;</span>);</div>
<div class="line"><a id="l00791" name="l00791"></a><span class="lineno">  791</span>    <a class="code hl_struct" href="structMortarSegmentInfo.html">MortarSegmentInfo</a> current_msinfo = msm_it-&gt;second;</div>
<div class="line"><a id="l00792" name="l00792"></a><span class="lineno">  792</span> </div>
<div class="line"><a id="l00793" name="l00793"></a><span class="lineno">  793</span>    <span class="comment">// add_left</span></div>
<div class="line"><a id="l00794" name="l00794"></a><span class="lineno">  794</span>    {</div>
<div class="line"><a id="l00795" name="l00795"></a><span class="lineno">  795</span>      Elem * msm_new_elem = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;add_elem(new_elem_left.release());</div>
<div class="line"><a id="l00796" name="l00796"></a><span class="lineno">  796</span> </div>
<div class="line"><a id="l00797" name="l00797"></a><span class="lineno">  797</span>      <span class="comment">// Create new MortarSegmentInfo objects for new_elem_left</span></div>
<div class="line"><a id="l00798" name="l00798"></a><span class="lineno">  798</span>      <a class="code hl_struct" href="structMortarSegmentInfo.html">MortarSegmentInfo</a> new_msinfo_left;</div>
<div class="line"><a id="l00799" name="l00799"></a><span class="lineno">  799</span> </div>
<div class="line"><a id="l00800" name="l00800"></a><span class="lineno">  800</span>      <span class="comment">// The new MortarSegmentInfo info objects inherit their &quot;outer&quot;</span></div>
<div class="line"><a id="l00801" name="l00801"></a><span class="lineno">  801</span>      <span class="comment">// information from current_msinfo and the rest is determined by</span></div>
<div class="line"><a id="l00802" name="l00802"></a><span class="lineno">  802</span>      <span class="comment">// the Node being inserted.</span></div>
<div class="line"><a id="l00803" name="l00803"></a><span class="lineno">  803</span>      new_msinfo_left.<a class="code hl_variable" href="structMortarSegmentInfo.html#ad4205fbab31bbda066622c55c8e93b87">xi1_a</a> = current_msinfo.<a class="code hl_variable" href="structMortarSegmentInfo.html#ad4205fbab31bbda066622c55c8e93b87">xi1_a</a>;</div>
<div class="line"><a id="l00804" name="l00804"></a><span class="lineno">  804</span>      new_msinfo_left.<a class="code hl_variable" href="structMortarSegmentInfo.html#abcfb0183363f3e21b43f9ffd3dc477b4">xi2_a</a> = current_msinfo.<a class="code hl_variable" href="structMortarSegmentInfo.html#abcfb0183363f3e21b43f9ffd3dc477b4">xi2_a</a>;</div>
<div class="line"><a id="l00805" name="l00805"></a><span class="lineno">  805</span>      new_msinfo_left.<a class="code hl_variable" href="structMortarSegmentInfo.html#afa8c2918a473f0dad90d5c68dad00eb4">secondary_elem</a> = secondary_elem;</div>
<div class="line"><a id="l00806" name="l00806"></a><span class="lineno">  806</span>      new_msinfo_left.<a class="code hl_variable" href="structMortarSegmentInfo.html#a648c7f480b2ce6404b1db1d21642b919">xi1_b</a> = xi1;</div>
<div class="line"><a id="l00807" name="l00807"></a><span class="lineno">  807</span>      new_msinfo_left.<a class="code hl_variable" href="structMortarSegmentInfo.html#a4fe559d3196b77718c1052ab7c1aa4d3">xi2_b</a> = left_xi2;</div>
<div class="line"><a id="l00808" name="l00808"></a><span class="lineno">  808</span>      new_msinfo_left.<a class="code hl_variable" href="structMortarSegmentInfo.html#a3316fbff8584e06e3c973d3f3e6ff05f">primary_elem</a> = left_primary_elem;</div>
<div class="line"><a id="l00809" name="l00809"></a><span class="lineno">  809</span> </div>
<div class="line"><a id="l00810" name="l00810"></a><span class="lineno">  810</span>      <span class="comment">// Add new msinfo objects to the map.</span></div>
<div class="line"><a id="l00811" name="l00811"></a><span class="lineno">  811</span>      <a class="code hl_variable" href="classAutomaticMortarGeneration.html#abbd91d3cf8bef528976fe6f932622d2d">_msm_elem_to_info</a>.emplace(msm_new_elem, new_msinfo_left);</div>
<div class="line"><a id="l00812" name="l00812"></a><span class="lineno">  812</span> </div>
<div class="line"><a id="l00813" name="l00813"></a><span class="lineno">  813</span>      <span class="comment">// We need to insert new_elem_left in</span></div>
<div class="line"><a id="l00814" name="l00814"></a><span class="lineno">  814</span>      <span class="comment">// the mortar_segment_set for this secondary_elem.</span></div>
<div class="line"><a id="l00815" name="l00815"></a><span class="lineno">  815</span>      mortar_segment_set.insert(msm_new_elem);</div>
<div class="line"><a id="l00816" name="l00816"></a><span class="lineno">  816</span>    }</div>
<div class="line"><a id="l00817" name="l00817"></a><span class="lineno">  817</span> </div>
<div class="line"><a id="l00818" name="l00818"></a><span class="lineno">  818</span>    <span class="comment">// add_right</span></div>
<div class="line"><a id="l00819" name="l00819"></a><span class="lineno">  819</span>    {</div>
<div class="line"><a id="l00820" name="l00820"></a><span class="lineno">  820</span>      Elem * msm_new_elem = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;add_elem(new_elem_right.release());</div>
<div class="line"><a id="l00821" name="l00821"></a><span class="lineno">  821</span> </div>
<div class="line"><a id="l00822" name="l00822"></a><span class="lineno">  822</span>      <span class="comment">// Create new MortarSegmentInfo objects for new_elem_right</span></div>
<div class="line"><a id="l00823" name="l00823"></a><span class="lineno">  823</span>      <a class="code hl_struct" href="structMortarSegmentInfo.html">MortarSegmentInfo</a> new_msinfo_right;</div>
<div class="line"><a id="l00824" name="l00824"></a><span class="lineno">  824</span> </div>
<div class="line"><a id="l00825" name="l00825"></a><span class="lineno">  825</span>      new_msinfo_right.<a class="code hl_variable" href="structMortarSegmentInfo.html#a648c7f480b2ce6404b1db1d21642b919">xi1_b</a> = current_msinfo.<a class="code hl_variable" href="structMortarSegmentInfo.html#a648c7f480b2ce6404b1db1d21642b919">xi1_b</a>;</div>
<div class="line"><a id="l00826" name="l00826"></a><span class="lineno">  826</span>      new_msinfo_right.<a class="code hl_variable" href="structMortarSegmentInfo.html#a4fe559d3196b77718c1052ab7c1aa4d3">xi2_b</a> = current_msinfo.<a class="code hl_variable" href="structMortarSegmentInfo.html#a4fe559d3196b77718c1052ab7c1aa4d3">xi2_b</a>;</div>
<div class="line"><a id="l00827" name="l00827"></a><span class="lineno">  827</span>      new_msinfo_right.<a class="code hl_variable" href="structMortarSegmentInfo.html#afa8c2918a473f0dad90d5c68dad00eb4">secondary_elem</a> = secondary_elem;</div>
<div class="line"><a id="l00828" name="l00828"></a><span class="lineno">  828</span>      new_msinfo_right.<a class="code hl_variable" href="structMortarSegmentInfo.html#ad4205fbab31bbda066622c55c8e93b87">xi1_a</a> = xi1;</div>
<div class="line"><a id="l00829" name="l00829"></a><span class="lineno">  829</span>      new_msinfo_right.<a class="code hl_variable" href="structMortarSegmentInfo.html#abcfb0183363f3e21b43f9ffd3dc477b4">xi2_a</a> = right_xi2;</div>
<div class="line"><a id="l00830" name="l00830"></a><span class="lineno">  830</span>      new_msinfo_right.<a class="code hl_variable" href="structMortarSegmentInfo.html#a3316fbff8584e06e3c973d3f3e6ff05f">primary_elem</a> = right_primary_elem;</div>
<div class="line"><a id="l00831" name="l00831"></a><span class="lineno">  831</span> </div>
<div class="line"><a id="l00832" name="l00832"></a><span class="lineno">  832</span>      <a class="code hl_variable" href="classAutomaticMortarGeneration.html#abbd91d3cf8bef528976fe6f932622d2d">_msm_elem_to_info</a>.emplace(msm_new_elem, new_msinfo_right);</div>
<div class="line"><a id="l00833" name="l00833"></a><span class="lineno">  833</span> </div>
<div class="line"><a id="l00834" name="l00834"></a><span class="lineno">  834</span>      mortar_segment_set.insert(msm_new_elem);</div>
<div class="line"><a id="l00835" name="l00835"></a><span class="lineno">  835</span>    }</div>
<div class="line"><a id="l00836" name="l00836"></a><span class="lineno">  836</span> </div>
<div class="line"><a id="l00837" name="l00837"></a><span class="lineno">  837</span>    <span class="comment">// Erase the MortarSegmentInfo object for current_mortar_segment from the map.</span></div>
<div class="line"><a id="l00838" name="l00838"></a><span class="lineno">  838</span>    <a class="code hl_variable" href="classAutomaticMortarGeneration.html#abbd91d3cf8bef528976fe6f932622d2d">_msm_elem_to_info</a>.erase(msm_it);</div>
<div class="line"><a id="l00839" name="l00839"></a><span class="lineno">  839</span> </div>
<div class="line"><a id="l00840" name="l00840"></a><span class="lineno">  840</span>    <span class="comment">// current_mortar_segment must be erased from the</span></div>
<div class="line"><a id="l00841" name="l00841"></a><span class="lineno">  841</span>    <span class="comment">// mortar_segment_set since it has now been split.</span></div>
<div class="line"><a id="l00842" name="l00842"></a><span class="lineno">  842</span>    mortar_segment_set.erase(current_mortar_segment);</div>
<div class="line"><a id="l00843" name="l00843"></a><span class="lineno">  843</span> </div>
<div class="line"><a id="l00844" name="l00844"></a><span class="lineno">  844</span>    <span class="comment">// The original mortar segment has been split, so erase it from</span></div>
<div class="line"><a id="l00845" name="l00845"></a><span class="lineno">  845</span>    <span class="comment">// the mortar segment mesh.</span></div>
<div class="line"><a id="l00846" name="l00846"></a><span class="lineno">  846</span>    <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;delete_elem(current_mortar_segment);</div>
<div class="line"><a id="l00847" name="l00847"></a><span class="lineno">  847</span>  }</div>
<div class="line"><a id="l00848" name="l00848"></a><span class="lineno">  848</span> </div>
<div class="line"><a id="l00849" name="l00849"></a><span class="lineno">  849</span>  <span class="comment">// Remove all MSM elements without a primary contribution</span></div>
<div class="line"><a id="l00855" name="l00855"></a><span class="lineno">  855</span><span class="comment"></span>  <span class="keywordflow">for</span> (<span class="keyword">auto</span> msm_elem : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;active_element_ptr_range())</div>
<div class="line"><a id="l00856" name="l00856"></a><span class="lineno">  856</span>  {</div>
<div class="line"><a id="l00857" name="l00857"></a><span class="lineno">  857</span>    <a class="code hl_struct" href="structMortarSegmentInfo.html">MortarSegmentInfo</a> &amp; msinfo = libmesh_map_find(<a class="code hl_variable" href="classAutomaticMortarGeneration.html#abbd91d3cf8bef528976fe6f932622d2d">_msm_elem_to_info</a>, msm_elem);</div>
<div class="line"><a id="l00858" name="l00858"></a><span class="lineno">  858</span>    Elem * primary_elem = <span class="keyword">const_cast&lt;</span>Elem *<span class="keyword">&gt;</span>(msinfo.<a class="code hl_variable" href="structMortarSegmentInfo.html#a3316fbff8584e06e3c973d3f3e6ff05f">primary_elem</a>);</div>
<div class="line"><a id="l00859" name="l00859"></a><span class="lineno">  859</span>    <span class="keywordflow">if</span> (primary_elem == <span class="keyword">nullptr</span> || std::abs(msinfo.<a class="code hl_variable" href="structMortarSegmentInfo.html#abcfb0183363f3e21b43f9ffd3dc477b4">xi2_a</a>) &gt; 1.0 + TOLERANCE ||</div>
<div class="line"><a id="l00860" name="l00860"></a><span class="lineno">  860</span>        std::abs(msinfo.<a class="code hl_variable" href="structMortarSegmentInfo.html#a4fe559d3196b77718c1052ab7c1aa4d3">xi2_b</a>) &gt; 1.0 + TOLERANCE)</div>
<div class="line"><a id="l00861" name="l00861"></a><span class="lineno">  861</span>    {</div>
<div class="line"><a id="l00862" name="l00862"></a><span class="lineno">  862</span>      <span class="comment">// Erase from secondary to msms map</span></div>
<div class="line"><a id="l00863" name="l00863"></a><span class="lineno">  863</span>      <span class="keyword">auto</span> it = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#af0da3b7d9e404238718805e12452d74d">_secondary_elems_to_mortar_segments</a>.find(msinfo.<a class="code hl_variable" href="structMortarSegmentInfo.html#afa8c2918a473f0dad90d5c68dad00eb4">secondary_elem</a>-&gt;id());</div>
<div class="line"><a id="l00864" name="l00864"></a><span class="lineno">  864</span>      mooseAssert(it != <a class="code hl_variable" href="classAutomaticMortarGeneration.html#af0da3b7d9e404238718805e12452d74d">_secondary_elems_to_mortar_segments</a>.end(),</div>
<div class="line"><a id="l00865" name="l00865"></a><span class="lineno">  865</span>                  <span class="stringliteral">&quot;We should have found the element&quot;</span>);</div>
<div class="line"><a id="l00866" name="l00866"></a><span class="lineno">  866</span>      <span class="keyword">auto</span> &amp; msm_set = it-&gt;second;</div>
<div class="line"><a id="l00867" name="l00867"></a><span class="lineno">  867</span>      msm_set.erase(msm_elem);</div>
<div class="line"><a id="l00868" name="l00868"></a><span class="lineno">  868</span>      <span class="comment">// We may be creating nodes with only one element neighbor where before this removal there</span></div>
<div class="line"><a id="l00869" name="l00869"></a><span class="lineno">  869</span>      <span class="comment">// were two. But the nodal normal used in computations will reflect the two-neighbor geometry.</span></div>
<div class="line"><a id="l00870" name="l00870"></a><span class="lineno">  870</span>      <span class="comment">// For a lower-d secondary mesh corner, that will imply the corner node will have a tilted</span></div>
<div class="line"><a id="l00871" name="l00871"></a><span class="lineno">  871</span>      <span class="comment">// normal vector (same for tangents) despite the mortar segment mesh not including its</span></div>
<div class="line"><a id="l00872" name="l00872"></a><span class="lineno">  872</span>      <span class="comment">// vertical neighboring element. It is the secondary element neighbors (not mortar segment</span></div>
<div class="line"><a id="l00873" name="l00873"></a><span class="lineno">  873</span>      <span class="comment">// mesh neighbors) that determine the nodal normal field.</span></div>
<div class="line"><a id="l00874" name="l00874"></a><span class="lineno">  874</span>      <span class="keywordflow">if</span> (msm_set.empty())</div>
<div class="line"><a id="l00875" name="l00875"></a><span class="lineno">  875</span>        <a class="code hl_variable" href="classAutomaticMortarGeneration.html#af0da3b7d9e404238718805e12452d74d">_secondary_elems_to_mortar_segments</a>.erase(it);</div>
<div class="line"><a id="l00876" name="l00876"></a><span class="lineno">  876</span> </div>
<div class="line"><a id="l00877" name="l00877"></a><span class="lineno">  877</span>      <span class="comment">// Erase msinfo</span></div>
<div class="line"><a id="l00878" name="l00878"></a><span class="lineno">  878</span>      <a class="code hl_variable" href="classAutomaticMortarGeneration.html#abbd91d3cf8bef528976fe6f932622d2d">_msm_elem_to_info</a>.erase(msm_elem);</div>
<div class="line"><a id="l00879" name="l00879"></a><span class="lineno">  879</span> </div>
<div class="line"><a id="l00880" name="l00880"></a><span class="lineno">  880</span>      <span class="comment">// Remove element from mortar segment mesh</span></div>
<div class="line"><a id="l00881" name="l00881"></a><span class="lineno">  881</span>      <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;delete_elem(msm_elem);</div>
<div class="line"><a id="l00882" name="l00882"></a><span class="lineno">  882</span>    }</div>
<div class="line"><a id="l00883" name="l00883"></a><span class="lineno">  883</span>    <span class="keywordflow">else</span></div>
<div class="line"><a id="l00884" name="l00884"></a><span class="lineno">  884</span>    {</div>
<div class="line"><a id="l00885" name="l00885"></a><span class="lineno">  885</span>      <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a7254faea651acd63b60b408ab560a0e5">_secondary_ip_sub_ids</a>.insert(msinfo.<a class="code hl_variable" href="structMortarSegmentInfo.html#afa8c2918a473f0dad90d5c68dad00eb4">secondary_elem</a>-&gt;interior_parent()-&gt;subdomain_id());</div>
<div class="line"><a id="l00886" name="l00886"></a><span class="lineno">  886</span>      <a class="code hl_variable" href="classAutomaticMortarGeneration.html#ac99e408cefd4da80efa2649ef1d32e93">_primary_ip_sub_ids</a>.insert(msinfo.<a class="code hl_variable" href="structMortarSegmentInfo.html#a3316fbff8584e06e3c973d3f3e6ff05f">primary_elem</a>-&gt;interior_parent()-&gt;subdomain_id());</div>
<div class="line"><a id="l00887" name="l00887"></a><span class="lineno">  887</span>    }</div>
<div class="line"><a id="l00888" name="l00888"></a><span class="lineno">  888</span>  }</div>
<div class="line"><a id="l00889" name="l00889"></a><span class="lineno">  889</span> </div>
<div class="line"><a id="l00890" name="l00890"></a><span class="lineno">  890</span>  std::unordered_set&lt;Node *&gt; msm_connected_nodes;</div>
<div class="line"><a id="l00891" name="l00891"></a><span class="lineno">  891</span> </div>
<div class="line"><a id="l00892" name="l00892"></a><span class="lineno">  892</span>  <span class="comment">// Deleting elements may produce isolated nodes.</span></div>
<div class="line"><a id="l00893" name="l00893"></a><span class="lineno">  893</span>  <span class="comment">// Loops for identifying and removing such nodes from mortar segment mesh.</span></div>
<div class="line"><a id="l00894" name="l00894"></a><span class="lineno">  894</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; element : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;element_ptr_range())</div>
<div class="line"><a id="l00895" name="l00895"></a><span class="lineno">  895</span>    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; n : element-&gt;node_ref_range())</div>
<div class="line"><a id="l00896" name="l00896"></a><span class="lineno">  896</span>      msm_connected_nodes.insert(&amp;n);</div>
<div class="line"><a id="l00897" name="l00897"></a><span class="lineno">  897</span> </div>
<div class="line"><a id="l00898" name="l00898"></a><span class="lineno">  898</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; node : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;node_ptr_range())</div>
<div class="line"><a id="l00899" name="l00899"></a><span class="lineno">  899</span>    <span class="keywordflow">if</span> (!msm_connected_nodes.count(node))</div>
<div class="line"><a id="l00900" name="l00900"></a><span class="lineno">  900</span>      <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;delete_node(node);</div>
<div class="line"><a id="l00901" name="l00901"></a><span class="lineno">  901</span> </div>
<div class="line"><a id="l00902" name="l00902"></a><span class="lineno">  902</span><span class="preprocessor">#ifdef DEBUG</span></div>
<div class="line"><a id="l00903" name="l00903"></a><span class="lineno">  903</span>  <span class="comment">// Verify that all segments without primary contribution have been deleted</span></div>
<div class="line"><a id="l00904" name="l00904"></a><span class="lineno">  904</span>  <span class="keywordflow">for</span> (<span class="keyword">auto</span> msm_elem : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;active_element_ptr_range())</div>
<div class="line"><a id="l00905" name="l00905"></a><span class="lineno">  905</span>  {</div>
<div class="line"><a id="l00906" name="l00906"></a><span class="lineno">  906</span>    <span class="keyword">const</span> <a class="code hl_struct" href="structMortarSegmentInfo.html">MortarSegmentInfo</a> &amp; msinfo = libmesh_map_find(<a class="code hl_variable" href="classAutomaticMortarGeneration.html#abbd91d3cf8bef528976fe6f932622d2d">_msm_elem_to_info</a>, msm_elem);</div>
<div class="line"><a id="l00907" name="l00907"></a><span class="lineno">  907</span>    mooseAssert(msinfo.<a class="code hl_variable" href="structMortarSegmentInfo.html#a3316fbff8584e06e3c973d3f3e6ff05f">primary_elem</a> != <span class="keyword">nullptr</span>,</div>
<div class="line"><a id="l00908" name="l00908"></a><span class="lineno">  908</span>                <span class="stringliteral">&quot;All mortar segment elements should have valid &quot;</span></div>
<div class="line"><a id="l00909" name="l00909"></a><span class="lineno">  909</span>                <span class="stringliteral">&quot;primary element.&quot;</span>);</div>
<div class="line"><a id="l00910" name="l00910"></a><span class="lineno">  910</span>  }</div>
<div class="line"><a id="l00911" name="l00911"></a><span class="lineno">  911</span><span class="preprocessor">#endif</span></div>
<div class="line"><a id="l00912" name="l00912"></a><span class="lineno">  912</span> </div>
<div class="line"><a id="l00913" name="l00913"></a><span class="lineno">  913</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;cache_elem_data();</div>
<div class="line"><a id="l00914" name="l00914"></a><span class="lineno">  914</span> </div>
<div class="line"><a id="l00915" name="l00915"></a><span class="lineno">  915</span>  <span class="comment">// (Optionally) Write the mortar segment mesh to file for inspection</span></div>
<div class="line"><a id="l00916" name="l00916"></a><span class="lineno">  916</span>  <span class="keywordflow">if</span> (<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a958de5b754ec676f463c50d2f16b5d0c">_debug</a>)</div>
<div class="line"><a id="l00917" name="l00917"></a><span class="lineno">  917</span>  {</div>
<div class="line"><a id="l00918" name="l00918"></a><span class="lineno">  918</span>    ExodusII_IO mortar_segment_mesh_writer(*<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>);</div>
<div class="line"><a id="l00919" name="l00919"></a><span class="lineno">  919</span> </div>
<div class="line"><a id="l00920" name="l00920"></a><span class="lineno">  920</span>    <span class="comment">// Default to non-HDF5 output for wider compatibility</span></div>
<div class="line"><a id="l00921" name="l00921"></a><span class="lineno">  921</span>    mortar_segment_mesh_writer.set_hdf5_writing(<span class="keyword">false</span>);</div>
<div class="line"><a id="l00922" name="l00922"></a><span class="lineno">  922</span> </div>
<div class="line"><a id="l00923" name="l00923"></a><span class="lineno">  923</span>    mortar_segment_mesh_writer.write(<span class="stringliteral">&quot;mortar_segment_mesh.e&quot;</span>);</div>
<div class="line"><a id="l00924" name="l00924"></a><span class="lineno">  924</span>  }</div>
<div class="line"><a id="l00925" name="l00925"></a><span class="lineno">  925</span> </div>
<div class="line"><a id="l00926" name="l00926"></a><span class="lineno">  926</span>  <a class="code hl_function" href="classAutomaticMortarGeneration.html#a6dfaa66a5dc83c679a3c4dd7aa0bf1ab">buildCouplingInformation</a>();</div>
<div class="line"><a id="l00927" name="l00927"></a><span class="lineno">  927</span>}</div>
<div class="line"><a id="l00928" name="l00928"></a><span class="lineno">  928</span> </div>
<div class="line"><a id="l00929" name="l00929"></a><span class="lineno">  929</span><span class="keywordtype">void</span></div>
<div class="line"><a id="l00930" name="l00930"></a><span class="lineno"><a class="line" href="classAutomaticMortarGeneration.html#a533e6ee50c2892de7d5e436f524bcb83">  930</a></span><a class="code hl_function" href="classAutomaticMortarGeneration.html#a533e6ee50c2892de7d5e436f524bcb83">AutomaticMortarGeneration::buildMortarSegmentMesh3d</a>()</div>
<div class="line"><a id="l00931" name="l00931"></a><span class="lineno">  931</span>{</div>
<div class="line"><a id="l00932" name="l00932"></a><span class="lineno">  932</span>  <span class="comment">// Add an integer flag to mortar segment mesh to keep track of which subelem</span></div>
<div class="line"><a id="l00933" name="l00933"></a><span class="lineno">  933</span>  <span class="comment">// of second order primal elements mortar segments correspond to</span></div>
<div class="line"><a id="l00934" name="l00934"></a><span class="lineno">  934</span>  <span class="keyword">auto</span> secondary_sub_elem = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;add_elem_integer(<span class="stringliteral">&quot;secondary_sub_elem&quot;</span>);</div>
<div class="line"><a id="l00935" name="l00935"></a><span class="lineno">  935</span>  <span class="keyword">auto</span> primary_sub_elem = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;add_elem_integer(<span class="stringliteral">&quot;primary_sub_elem&quot;</span>);</div>
<div class="line"><a id="l00936" name="l00936"></a><span class="lineno">  936</span> </div>
<div class="line"><a id="l00937" name="l00937"></a><span class="lineno">  937</span>  dof_id_type local_id_index = 0;</div>
<div class="line"><a id="l00938" name="l00938"></a><span class="lineno">  938</span> </div>
<div class="line"><a id="l00939" name="l00939"></a><span class="lineno">  939</span>  <span class="comment">// Loop through mortar secondary and primary pairs to create mortar segment mesh between each</span></div>
<div class="line"><a id="l00940" name="l00940"></a><span class="lineno">  940</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; pr : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a969d4ab038fc8d447e966cd1e1600091">_primary_secondary_subdomain_id_pairs</a>)</div>
<div class="line"><a id="l00941" name="l00941"></a><span class="lineno">  941</span>  {</div>
<div class="line"><a id="l00942" name="l00942"></a><span class="lineno">  942</span>    <span class="keyword">const</span> <span class="keyword">auto</span> primary_subd_id = pr.first;</div>
<div class="line"><a id="l00943" name="l00943"></a><span class="lineno">  943</span>    <span class="keyword">const</span> <span class="keyword">auto</span> secondary_subd_id = pr.second;</div>
<div class="line"><a id="l00944" name="l00944"></a><span class="lineno">  944</span> </div>
<div class="line"><a id="l00945" name="l00945"></a><span class="lineno">  945</span>    <span class="comment">// Build k-d tree for use in Step 1.2 for primary interface coarse screening</span></div>
<div class="line"><a id="l00946" name="l00946"></a><span class="lineno">  946</span>    <a class="code hl_class" href="classNanoflannMeshSubdomainAdaptor.html">NanoflannMeshSubdomainAdaptor&lt;3&gt;</a> mesh_adaptor(<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>, primary_subd_id);</div>
<div class="line"><a id="l00947" name="l00947"></a><span class="lineno">  947</span>    <a class="code hl_typedef" href="NanoflannMeshAdaptor_8h.html#a3a70df33047194961ce21a0133717038">subdomain_kd_tree_t</a> kd_tree(</div>
<div class="line"><a id="l00948" name="l00948"></a><span class="lineno">  948</span>        3, mesh_adaptor, nanoflann::KDTreeSingleIndexAdaptorParams(<span class="comment">/*max leaf=*/</span>10));</div>
<div class="line"><a id="l00949" name="l00949"></a><span class="lineno">  949</span> </div>
<div class="line"><a id="l00950" name="l00950"></a><span class="lineno">  950</span>    <span class="comment">// Construct the KD tree.</span></div>
<div class="line"><a id="l00951" name="l00951"></a><span class="lineno">  951</span>    kd_tree.buildIndex();</div>
<div class="line"><a id="l00952" name="l00952"></a><span class="lineno">  952</span> </div>
<div class="line"><a id="l00953" name="l00953"></a><span class="lineno">  953</span>    <span class="comment">// Define expression for getting sub-elements nodes (for sub-dividing secondary elements)</span></div>
<div class="line"><a id="l00954" name="l00954"></a><span class="lineno">  954</span>    <span class="keyword">auto</span> get_sub_elem_nodes = [](<span class="keyword">const</span> ElemType type,</div>
<div class="line"><a id="l00955" name="l00955"></a><span class="lineno">  955</span>                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sub_elem) -&gt; std::vector&lt;unsigned int&gt;</div>
<div class="line"><a id="l00956" name="l00956"></a><span class="lineno">  956</span>    {</div>
<div class="line"><a id="l00957" name="l00957"></a><span class="lineno">  957</span>      <span class="keywordflow">switch</span> (type)</div>
<div class="line"><a id="l00958" name="l00958"></a><span class="lineno">  958</span>      {</div>
<div class="line"><a id="l00959" name="l00959"></a><span class="lineno">  959</span>        <span class="keywordflow">case</span> TRI3:</div>
<div class="line"><a id="l00960" name="l00960"></a><span class="lineno">  960</span>          <span class="keywordflow">return</span> {{0, 1, 2}};</div>
<div class="line"><a id="l00961" name="l00961"></a><span class="lineno">  961</span>        <span class="keywordflow">case</span> QUAD4:</div>
<div class="line"><a id="l00962" name="l00962"></a><span class="lineno">  962</span>          <span class="keywordflow">return</span> {{0, 1, 2, 3}};</div>
<div class="line"><a id="l00963" name="l00963"></a><span class="lineno">  963</span>        <span class="keywordflow">case</span> TRI6:</div>
<div class="line"><a id="l00964" name="l00964"></a><span class="lineno">  964</span>        <span class="keywordflow">case</span> TRI7:</div>
<div class="line"><a id="l00965" name="l00965"></a><span class="lineno">  965</span>          <span class="keywordflow">switch</span> (sub_elem)</div>
<div class="line"><a id="l00966" name="l00966"></a><span class="lineno">  966</span>          {</div>
<div class="line"><a id="l00967" name="l00967"></a><span class="lineno">  967</span>            <span class="keywordflow">case</span> 0:</div>
<div class="line"><a id="l00968" name="l00968"></a><span class="lineno">  968</span>              <span class="keywordflow">return</span> {{0, 3, 5}};</div>
<div class="line"><a id="l00969" name="l00969"></a><span class="lineno">  969</span>            <span class="keywordflow">case</span> 1:</div>
<div class="line"><a id="l00970" name="l00970"></a><span class="lineno">  970</span>              <span class="keywordflow">return</span> {{3, 4, 5}};</div>
<div class="line"><a id="l00971" name="l00971"></a><span class="lineno">  971</span>            <span class="keywordflow">case</span> 2:</div>
<div class="line"><a id="l00972" name="l00972"></a><span class="lineno">  972</span>              <span class="keywordflow">return</span> {{3, 1, 4}};</div>
<div class="line"><a id="l00973" name="l00973"></a><span class="lineno">  973</span>            <span class="keywordflow">case</span> 3:</div>
<div class="line"><a id="l00974" name="l00974"></a><span class="lineno">  974</span>              <span class="keywordflow">return</span> {{5, 4, 2}};</div>
<div class="line"><a id="l00975" name="l00975"></a><span class="lineno">  975</span>            <span class="keywordflow">default</span>:</div>
<div class="line"><a id="l00976" name="l00976"></a><span class="lineno">  976</span>              <a class="code hl_function" href="MooseError_8h.html#aa959168eed29caa7aaa85ffc1319a9ad">mooseError</a>(<span class="stringliteral">&quot;get_sub_elem_nodes: Invalid sub_elem: &quot;</span>, sub_elem);</div>
<div class="line"><a id="l00977" name="l00977"></a><span class="lineno">  977</span>          }</div>
<div class="line"><a id="l00978" name="l00978"></a><span class="lineno">  978</span>        <span class="keywordflow">case</span> QUAD8:</div>
<div class="line"><a id="l00979" name="l00979"></a><span class="lineno">  979</span>          <span class="keywordflow">switch</span> (sub_elem)</div>
<div class="line"><a id="l00980" name="l00980"></a><span class="lineno">  980</span>          {</div>
<div class="line"><a id="l00981" name="l00981"></a><span class="lineno">  981</span>            <span class="keywordflow">case</span> 0:</div>
<div class="line"><a id="l00982" name="l00982"></a><span class="lineno">  982</span>              <span class="keywordflow">return</span> {{0, 4, 7}};</div>
<div class="line"><a id="l00983" name="l00983"></a><span class="lineno">  983</span>            <span class="keywordflow">case</span> 1:</div>
<div class="line"><a id="l00984" name="l00984"></a><span class="lineno">  984</span>              <span class="keywordflow">return</span> {{4, 1, 5}};</div>
<div class="line"><a id="l00985" name="l00985"></a><span class="lineno">  985</span>            <span class="keywordflow">case</span> 2:</div>
<div class="line"><a id="l00986" name="l00986"></a><span class="lineno">  986</span>              <span class="keywordflow">return</span> {{5, 2, 6}};</div>
<div class="line"><a id="l00987" name="l00987"></a><span class="lineno">  987</span>            <span class="keywordflow">case</span> 3:</div>
<div class="line"><a id="l00988" name="l00988"></a><span class="lineno">  988</span>              <span class="keywordflow">return</span> {{7, 6, 3}};</div>
<div class="line"><a id="l00989" name="l00989"></a><span class="lineno">  989</span>            <span class="keywordflow">case</span> 4:</div>
<div class="line"><a id="l00990" name="l00990"></a><span class="lineno">  990</span>              <span class="keywordflow">return</span> {{4, 5, 6, 7}};</div>
<div class="line"><a id="l00991" name="l00991"></a><span class="lineno">  991</span>            <span class="keywordflow">default</span>:</div>
<div class="line"><a id="l00992" name="l00992"></a><span class="lineno">  992</span>              <a class="code hl_function" href="MooseError_8h.html#aa959168eed29caa7aaa85ffc1319a9ad">mooseError</a>(<span class="stringliteral">&quot;get_sub_elem_nodes: Invalid sub_elem: &quot;</span>, sub_elem);</div>
<div class="line"><a id="l00993" name="l00993"></a><span class="lineno">  993</span>          }</div>
<div class="line"><a id="l00994" name="l00994"></a><span class="lineno">  994</span>        <span class="keywordflow">case</span> QUAD9:</div>
<div class="line"><a id="l00995" name="l00995"></a><span class="lineno">  995</span>          <span class="keywordflow">switch</span> (sub_elem)</div>
<div class="line"><a id="l00996" name="l00996"></a><span class="lineno">  996</span>          {</div>
<div class="line"><a id="l00997" name="l00997"></a><span class="lineno">  997</span>            <span class="keywordflow">case</span> 0:</div>
<div class="line"><a id="l00998" name="l00998"></a><span class="lineno">  998</span>              <span class="keywordflow">return</span> {{0, 4, 8, 7}};</div>
<div class="line"><a id="l00999" name="l00999"></a><span class="lineno">  999</span>            <span class="keywordflow">case</span> 1:</div>
<div class="line"><a id="l01000" name="l01000"></a><span class="lineno"> 1000</span>              <span class="keywordflow">return</span> {{4, 1, 5, 8}};</div>
<div class="line"><a id="l01001" name="l01001"></a><span class="lineno"> 1001</span>            <span class="keywordflow">case</span> 2:</div>
<div class="line"><a id="l01002" name="l01002"></a><span class="lineno"> 1002</span>              <span class="keywordflow">return</span> {{8, 5, 2, 6}};</div>
<div class="line"><a id="l01003" name="l01003"></a><span class="lineno"> 1003</span>            <span class="keywordflow">case</span> 3:</div>
<div class="line"><a id="l01004" name="l01004"></a><span class="lineno"> 1004</span>              <span class="keywordflow">return</span> {{7, 8, 6, 3}};</div>
<div class="line"><a id="l01005" name="l01005"></a><span class="lineno"> 1005</span>            <span class="keywordflow">default</span>:</div>
<div class="line"><a id="l01006" name="l01006"></a><span class="lineno"> 1006</span>              <a class="code hl_function" href="MooseError_8h.html#aa959168eed29caa7aaa85ffc1319a9ad">mooseError</a>(<span class="stringliteral">&quot;get_sub_elem_nodes: Invalid sub_elem: &quot;</span>, sub_elem);</div>
<div class="line"><a id="l01007" name="l01007"></a><span class="lineno"> 1007</span>          }</div>
<div class="line"><a id="l01008" name="l01008"></a><span class="lineno"> 1008</span>        <span class="keywordflow">default</span>:</div>
<div class="line"><a id="l01009" name="l01009"></a><span class="lineno"> 1009</span>          <a class="code hl_function" href="MooseError_8h.html#aa959168eed29caa7aaa85ffc1319a9ad">mooseError</a>(<span class="stringliteral">&quot;get_sub_elem_inds: Face element type: &quot;</span>,</div>
<div class="line"><a id="l01010" name="l01010"></a><span class="lineno"> 1010</span>                     libMesh::Utility::enum_to_string&lt;ElemType&gt;(type),</div>
<div class="line"><a id="l01011" name="l01011"></a><span class="lineno"> 1011</span>                     <span class="stringliteral">&quot; invalid for 3D mortar&quot;</span>);</div>
<div class="line"><a id="l01012" name="l01012"></a><span class="lineno"> 1012</span>      }</div>
<div class="line"><a id="l01013" name="l01013"></a><span class="lineno"> 1013</span>    };</div>
<div class="line"><a id="l01014" name="l01014"></a><span class="lineno"> 1014</span> </div>
<div class="line"><a id="l01018" name="l01018"></a><span class="lineno"> 1018</span>    <span class="keywordflow">for</span> (MeshBase::const_element_iterator el = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.active_local_elements_begin(),</div>
<div class="line"><a id="l01019" name="l01019"></a><span class="lineno"> 1019</span>                                          end_el = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.active_local_elements_end();</div>
<div class="line"><a id="l01020" name="l01020"></a><span class="lineno"> 1020</span>         el != end_el;</div>
<div class="line"><a id="l01021" name="l01021"></a><span class="lineno"> 1021</span>         ++el)</div>
<div class="line"><a id="l01022" name="l01022"></a><span class="lineno"> 1022</span>    {</div>
<div class="line"><a id="l01023" name="l01023"></a><span class="lineno"> 1023</span>      <span class="keyword">const</span> Elem * secondary_side_elem = *el;</div>
<div class="line"><a id="l01024" name="l01024"></a><span class="lineno"> 1024</span> </div>
<div class="line"><a id="l01025" name="l01025"></a><span class="lineno"> 1025</span>      <span class="keyword">const</span> Real secondary_volume = secondary_side_elem-&gt;volume();</div>
<div class="line"><a id="l01026" name="l01026"></a><span class="lineno"> 1026</span> </div>
<div class="line"><a id="l01027" name="l01027"></a><span class="lineno"> 1027</span>      <span class="comment">// If this Elem is not in the current secondary subdomain, go on to the next one.</span></div>
<div class="line"><a id="l01028" name="l01028"></a><span class="lineno"> 1028</span>      <span class="keywordflow">if</span> (secondary_side_elem-&gt;subdomain_id() != secondary_subd_id)</div>
<div class="line"><a id="l01029" name="l01029"></a><span class="lineno"> 1029</span>        <span class="keywordflow">continue</span>;</div>
<div class="line"><a id="l01030" name="l01030"></a><span class="lineno"> 1030</span> </div>
<div class="line"><a id="l01031" name="l01031"></a><span class="lineno"> 1031</span>      <span class="keyword">auto</span> [secondary_elem_to_msm_map_it, insertion_happened] =</div>
<div class="line"><a id="l01032" name="l01032"></a><span class="lineno"> 1032</span>          <a class="code hl_variable" href="classAutomaticMortarGeneration.html#af0da3b7d9e404238718805e12452d74d">_secondary_elems_to_mortar_segments</a>.emplace(secondary_side_elem-&gt;id(),</div>
<div class="line"><a id="l01033" name="l01033"></a><span class="lineno"> 1033</span>                                                      std::set&lt;Elem *, CompareDofObjectsByID&gt;{});</div>
<div class="line"><a id="l01034" name="l01034"></a><span class="lineno"> 1034</span>      libmesh_ignore(insertion_happened);</div>
<div class="line"><a id="l01035" name="l01035"></a><span class="lineno"> 1035</span>      <span class="keyword">auto</span> &amp; secondary_to_msm_element_set = secondary_elem_to_msm_map_it-&gt;second;</div>
<div class="line"><a id="l01036" name="l01036"></a><span class="lineno"> 1036</span> </div>
<div class="line"><a id="l01037" name="l01037"></a><span class="lineno"> 1037</span>      std::vector&lt;std::unique_ptr&lt;MortarSegmentHelper&gt;&gt; mortar_segment_helper(</div>
<div class="line"><a id="l01038" name="l01038"></a><span class="lineno"> 1038</span>          secondary_side_elem-&gt;n_sub_elem());</div>
<div class="line"><a id="l01039" name="l01039"></a><span class="lineno"> 1039</span>      <span class="keyword">const</span> <span class="keyword">auto</span> nodal_normals = <a class="code hl_function" href="classAutomaticMortarGeneration.html#ae200397e9841242f1bc2438b2156f253">getNodalNormals</a>(*secondary_side_elem);</div>
<div class="line"><a id="l01040" name="l01040"></a><span class="lineno"> 1040</span> </div>
<div class="line"><a id="l01051" name="l01051"></a><span class="lineno"> 1051</span>      <span class="keywordflow">for</span> (<span class="keyword">auto</span> sel : make_range(secondary_side_elem-&gt;n_sub_elem()))</div>
<div class="line"><a id="l01052" name="l01052"></a><span class="lineno"> 1052</span>      {</div>
<div class="line"><a id="l01053" name="l01053"></a><span class="lineno"> 1053</span>        <span class="comment">// Get indices of sub-element nodes in element</span></div>
<div class="line"><a id="l01054" name="l01054"></a><span class="lineno"> 1054</span>        <span class="keyword">auto</span> sub_elem_nodes = get_sub_elem_nodes(secondary_side_elem-&gt;type(), sel);</div>
<div class="line"><a id="l01055" name="l01055"></a><span class="lineno"> 1055</span> </div>
<div class="line"><a id="l01056" name="l01056"></a><span class="lineno"> 1056</span>        <span class="comment">// Secondary sub-element center, normal, and nodes</span></div>
<div class="line"><a id="l01057" name="l01057"></a><span class="lineno"> 1057</span>        Point center;</div>
<div class="line"><a id="l01058" name="l01058"></a><span class="lineno"> 1058</span>        Point normal;</div>
<div class="line"><a id="l01059" name="l01059"></a><span class="lineno"> 1059</span>        std::vector&lt;Point&gt; nodes(sub_elem_nodes.size());</div>
<div class="line"><a id="l01060" name="l01060"></a><span class="lineno"> 1060</span> </div>
<div class="line"><a id="l01061" name="l01061"></a><span class="lineno"> 1061</span>        <span class="comment">// Loop through sub_element nodes, collect points and compute center and normal</span></div>
<div class="line"><a id="l01062" name="l01062"></a><span class="lineno"> 1062</span>        <span class="keywordflow">for</span> (<span class="keyword">auto</span> iv : make_range(sub_elem_nodes.size()))</div>
<div class="line"><a id="l01063" name="l01063"></a><span class="lineno"> 1063</span>        {</div>
<div class="line"><a id="l01064" name="l01064"></a><span class="lineno"> 1064</span>          <span class="keyword">const</span> <span class="keyword">auto</span> n = sub_elem_nodes[iv];</div>
<div class="line"><a id="l01065" name="l01065"></a><span class="lineno"> 1065</span>          nodes[iv] = secondary_side_elem-&gt;point(n);</div>
<div class="line"><a id="l01066" name="l01066"></a><span class="lineno"> 1066</span>          center += secondary_side_elem-&gt;point(n);</div>
<div class="line"><a id="l01067" name="l01067"></a><span class="lineno"> 1067</span>          normal += nodal_normals[n];</div>
<div class="line"><a id="l01068" name="l01068"></a><span class="lineno"> 1068</span>        }</div>
<div class="line"><a id="l01069" name="l01069"></a><span class="lineno"> 1069</span>        center /= sub_elem_nodes.size();</div>
<div class="line"><a id="l01070" name="l01070"></a><span class="lineno"> 1070</span>        normal = normal.unit();</div>
<div class="line"><a id="l01071" name="l01071"></a><span class="lineno"> 1071</span> </div>
<div class="line"><a id="l01072" name="l01072"></a><span class="lineno"> 1072</span>        <span class="comment">// Build and store linearized sub-elements for later use</span></div>
<div class="line"><a id="l01073" name="l01073"></a><span class="lineno"> 1073</span>        mortar_segment_helper[sel] = std::make_unique&lt;MortarSegmentHelper&gt;(nodes, center, normal);</div>
<div class="line"><a id="l01074" name="l01074"></a><span class="lineno"> 1074</span>      }</div>
<div class="line"><a id="l01075" name="l01075"></a><span class="lineno"> 1075</span> </div>
<div class="line"><a id="l01081" name="l01081"></a><span class="lineno"> 1081</span>      <span class="comment">// Search point for performing Nanoflann (k-d tree) searches.</span></div>
<div class="line"><a id="l01082" name="l01082"></a><span class="lineno"> 1082</span>      <span class="comment">// In each case we use the center point of the original element (not sub-elements for second</span></div>
<div class="line"><a id="l01083" name="l01083"></a><span class="lineno"> 1083</span>      <span class="comment">// order elements). This is to do search for all sub-elements simultaneously</span></div>
<div class="line"><a id="l01084" name="l01084"></a><span class="lineno"> 1084</span>      std::array&lt;Real, 3&gt; query_pt;</div>
<div class="line"><a id="l01085" name="l01085"></a><span class="lineno"> 1085</span>      Point center_point;</div>
<div class="line"><a id="l01086" name="l01086"></a><span class="lineno"> 1086</span>      <span class="keywordflow">switch</span> (secondary_side_elem-&gt;type())</div>
<div class="line"><a id="l01087" name="l01087"></a><span class="lineno"> 1087</span>      {</div>
<div class="line"><a id="l01088" name="l01088"></a><span class="lineno"> 1088</span>        <span class="keywordflow">case</span> TRI3:</div>
<div class="line"><a id="l01089" name="l01089"></a><span class="lineno"> 1089</span>        <span class="keywordflow">case</span> QUAD4:</div>
<div class="line"><a id="l01090" name="l01090"></a><span class="lineno"> 1090</span>          center_point = mortar_segment_helper[0]-&gt;center();</div>
<div class="line"><a id="l01091" name="l01091"></a><span class="lineno"> 1091</span>          query_pt = {{center_point(0), center_point(1), center_point(2)}};</div>
<div class="line"><a id="l01092" name="l01092"></a><span class="lineno"> 1092</span>          <span class="keywordflow">break</span>;</div>
<div class="line"><a id="l01093" name="l01093"></a><span class="lineno"> 1093</span>        <span class="keywordflow">case</span> TRI6:</div>
<div class="line"><a id="l01094" name="l01094"></a><span class="lineno"> 1094</span>        <span class="keywordflow">case</span> TRI7:</div>
<div class="line"><a id="l01095" name="l01095"></a><span class="lineno"> 1095</span>          center_point = mortar_segment_helper[1]-&gt;center();</div>
<div class="line"><a id="l01096" name="l01096"></a><span class="lineno"> 1096</span>          query_pt = {{center_point(0), center_point(1), center_point(2)}};</div>
<div class="line"><a id="l01097" name="l01097"></a><span class="lineno"> 1097</span>          <span class="keywordflow">break</span>;</div>
<div class="line"><a id="l01098" name="l01098"></a><span class="lineno"> 1098</span>        <span class="keywordflow">case</span> QUAD8:</div>
<div class="line"><a id="l01099" name="l01099"></a><span class="lineno"> 1099</span>          center_point = mortar_segment_helper[4]-&gt;center();</div>
<div class="line"><a id="l01100" name="l01100"></a><span class="lineno"> 1100</span>          query_pt = {{center_point(0), center_point(1), center_point(2)}};</div>
<div class="line"><a id="l01101" name="l01101"></a><span class="lineno"> 1101</span>          <span class="keywordflow">break</span>;</div>
<div class="line"><a id="l01102" name="l01102"></a><span class="lineno"> 1102</span>        <span class="keywordflow">case</span> QUAD9:</div>
<div class="line"><a id="l01103" name="l01103"></a><span class="lineno"> 1103</span>          center_point = secondary_side_elem-&gt;point(8);</div>
<div class="line"><a id="l01104" name="l01104"></a><span class="lineno"> 1104</span>          query_pt = {{center_point(0), center_point(1), center_point(2)}};</div>
<div class="line"><a id="l01105" name="l01105"></a><span class="lineno"> 1105</span>          <span class="keywordflow">break</span>;</div>
<div class="line"><a id="l01106" name="l01106"></a><span class="lineno"> 1106</span>        <span class="keywordflow">default</span>:</div>
<div class="line"><a id="l01107" name="l01107"></a><span class="lineno"> 1107</span>          <a class="code hl_function" href="MooseError_8h.html#aa959168eed29caa7aaa85ffc1319a9ad">mooseError</a>(</div>
<div class="line"><a id="l01108" name="l01108"></a><span class="lineno"> 1108</span>              <span class="stringliteral">&quot;Face element type: &quot;</span>, secondary_side_elem-&gt;type(), <span class="stringliteral">&quot;not supported for 3D mortar&quot;</span>);</div>
<div class="line"><a id="l01109" name="l01109"></a><span class="lineno"> 1109</span>      }</div>
<div class="line"><a id="l01110" name="l01110"></a><span class="lineno"> 1110</span> </div>
<div class="line"><a id="l01111" name="l01111"></a><span class="lineno"> 1111</span>      <span class="comment">// The number of results we want to get. These results will only be used to find</span></div>
<div class="line"><a id="l01112" name="l01112"></a><span class="lineno"> 1112</span>      <span class="comment">// a single element with non-trivial overlap, after an element is identified a breadth</span></div>
<div class="line"><a id="l01113" name="l01113"></a><span class="lineno"> 1113</span>      <span class="comment">// first search is done on neighbors</span></div>
<div class="line"><a id="l01114" name="l01114"></a><span class="lineno"> 1114</span>      <span class="keyword">const</span> std::size_t num_results = 3;</div>
<div class="line"><a id="l01115" name="l01115"></a><span class="lineno"> 1115</span> </div>
<div class="line"><a id="l01116" name="l01116"></a><span class="lineno"> 1116</span>      <span class="comment">// Initialize result_set and do the search.</span></div>
<div class="line"><a id="l01117" name="l01117"></a><span class="lineno"> 1117</span>      std::vector&lt;size_t&gt; ret_index(num_results);</div>
<div class="line"><a id="l01118" name="l01118"></a><span class="lineno"> 1118</span>      std::vector&lt;Real&gt; out_dist_sqr(num_results);</div>
<div class="line"><a id="l01119" name="l01119"></a><span class="lineno"> 1119</span>      nanoflann::KNNResultSet&lt;Real&gt; result_set(num_results);</div>
<div class="line"><a id="l01120" name="l01120"></a><span class="lineno"> 1120</span>      result_set.init(&amp;ret_index[0], &amp;out_dist_sqr[0]);</div>
<div class="line"><a id="l01121" name="l01121"></a><span class="lineno"> 1121</span>      kd_tree.findNeighbors(result_set, &amp;query_pt[0], <a class="code hl_typedef" href="namespacenanoflann.html#a7475277cf1d06434e352ade6f35de645">nanoflann::SearchParameters</a>());</div>
<div class="line"><a id="l01122" name="l01122"></a><span class="lineno"> 1122</span> </div>
<div class="line"><a id="l01123" name="l01123"></a><span class="lineno"> 1123</span>      <span class="comment">// Initialize list of processed primary elements, we don&#39;t want to revisit processed elements</span></div>
<div class="line"><a id="l01124" name="l01124"></a><span class="lineno"> 1124</span>      std::set&lt;const Elem *, CompareDofObjectsByID&gt; processed_primary_elems;</div>
<div class="line"><a id="l01125" name="l01125"></a><span class="lineno"> 1125</span> </div>
<div class="line"><a id="l01126" name="l01126"></a><span class="lineno"> 1126</span>      <span class="comment">// Initialize candidate set and flag for switching between coarse screening and breadth-first</span></div>
<div class="line"><a id="l01127" name="l01127"></a><span class="lineno"> 1127</span>      <span class="comment">// search</span></div>
<div class="line"><a id="l01128" name="l01128"></a><span class="lineno"> 1128</span>      <span class="keywordtype">bool</span> primary_elem_found = <span class="keyword">false</span>;</div>
<div class="line"><a id="l01129" name="l01129"></a><span class="lineno"> 1129</span>      std::set&lt;const Elem *, CompareDofObjectsByID&gt; primary_elem_candidates;</div>
<div class="line"><a id="l01130" name="l01130"></a><span class="lineno"> 1130</span> </div>
<div class="line"><a id="l01131" name="l01131"></a><span class="lineno"> 1131</span>      <span class="comment">// Loop candidate nodes (returned by Nanoflann) and add all adjoining elems to candidate set</span></div>
<div class="line"><a id="l01132" name="l01132"></a><span class="lineno"> 1132</span>      <span class="keywordflow">for</span> (<span class="keyword">auto</span> r : make_range(result_set.size()))</div>
<div class="line"><a id="l01133" name="l01133"></a><span class="lineno"> 1133</span>      {</div>
<div class="line"><a id="l01134" name="l01134"></a><span class="lineno"> 1134</span>        <span class="comment">// Verify that the squared distance we compute is the same as nanoflann&#39;s</span></div>
<div class="line"><a id="l01135" name="l01135"></a><span class="lineno"> 1135</span>        mooseAssert(std::abs((<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.point(ret_index[r]) - center_point).norm_sq() -</div>
<div class="line"><a id="l01136" name="l01136"></a><span class="lineno"> 1136</span>                             out_dist_sqr[r]) &lt;= TOLERANCE,</div>
<div class="line"><a id="l01137" name="l01137"></a><span class="lineno"> 1137</span>                    <span class="stringliteral">&quot;Lower-dimensional element squared distance verification failed.&quot;</span>);</div>
<div class="line"><a id="l01138" name="l01138"></a><span class="lineno"> 1138</span> </div>
<div class="line"><a id="l01139" name="l01139"></a><span class="lineno"> 1139</span>        <span class="comment">// Get list of elems connected to node</span></div>
<div class="line"><a id="l01140" name="l01140"></a><span class="lineno"> 1140</span>        std::vector&lt;const Elem *&gt; &amp; node_elems =</div>
<div class="line"><a id="l01141" name="l01141"></a><span class="lineno"> 1141</span>            this-&gt;<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a1ee9b6e4f8bd88603e22117085758f70">_nodes_to_primary_elem_map</a>.at(<span class="keyword">static_cast&lt;</span>dof_id_type<span class="keyword">&gt;</span>(ret_index[r]));</div>
<div class="line"><a id="l01142" name="l01142"></a><span class="lineno"> 1142</span> </div>
<div class="line"><a id="l01143" name="l01143"></a><span class="lineno"> 1143</span>        <span class="comment">// Uniquely add elems to candidate set</span></div>
<div class="line"><a id="l01144" name="l01144"></a><span class="lineno"> 1144</span>        <span class="keywordflow">for</span> (<span class="keyword">auto</span> elem : node_elems)</div>
<div class="line"><a id="l01145" name="l01145"></a><span class="lineno"> 1145</span>          primary_elem_candidates.insert(elem);</div>
<div class="line"><a id="l01146" name="l01146"></a><span class="lineno"> 1146</span>      }</div>
<div class="line"><a id="l01147" name="l01147"></a><span class="lineno"> 1147</span> </div>
<div class="line"><a id="l01155" name="l01155"></a><span class="lineno"> 1155</span>      <span class="keywordflow">while</span> (!primary_elem_candidates.empty())</div>
<div class="line"><a id="l01156" name="l01156"></a><span class="lineno"> 1156</span>      {</div>
<div class="line"><a id="l01157" name="l01157"></a><span class="lineno"> 1157</span>        <span class="keyword">const</span> Elem * primary_elem_candidate = *primary_elem_candidates.begin();</div>
<div class="line"><a id="l01158" name="l01158"></a><span class="lineno"> 1158</span> </div>
<div class="line"><a id="l01159" name="l01159"></a><span class="lineno"> 1159</span>        <span class="comment">// If we&#39;ve already processed this candidate, we don&#39;t need to check it again.</span></div>
<div class="line"><a id="l01160" name="l01160"></a><span class="lineno"> 1160</span>        <span class="keywordflow">if</span> (processed_primary_elems.count(primary_elem_candidate))</div>
<div class="line"><a id="l01161" name="l01161"></a><span class="lineno"> 1161</span>          <span class="keywordflow">continue</span>;</div>
<div class="line"><a id="l01162" name="l01162"></a><span class="lineno"> 1162</span> </div>
<div class="line"><a id="l01163" name="l01163"></a><span class="lineno"> 1163</span>        <span class="comment">// Initialize set of nodes used to construct mortar segment elements</span></div>
<div class="line"><a id="l01164" name="l01164"></a><span class="lineno"> 1164</span>        std::vector&lt;Point&gt; nodal_points;</div>
<div class="line"><a id="l01165" name="l01165"></a><span class="lineno"> 1165</span> </div>
<div class="line"><a id="l01166" name="l01166"></a><span class="lineno"> 1166</span>        <span class="comment">// Initialize map from mortar segment elements to nodes</span></div>
<div class="line"><a id="l01167" name="l01167"></a><span class="lineno"> 1167</span>        std::vector&lt;std::vector&lt;unsigned int&gt;&gt; elem_to_node_map;</div>
<div class="line"><a id="l01168" name="l01168"></a><span class="lineno"> 1168</span> </div>
<div class="line"><a id="l01169" name="l01169"></a><span class="lineno"> 1169</span>        <span class="comment">// Initialize list of secondary and primary sub-elements that formed each mortar segment</span></div>
<div class="line"><a id="l01170" name="l01170"></a><span class="lineno"> 1170</span>        std::vector&lt;std::pair&lt;unsigned int, unsigned int&gt;&gt; sub_elem_map;</div>
<div class="line"><a id="l01171" name="l01171"></a><span class="lineno"> 1171</span> </div>
<div class="line"><a id="l01176" name="l01176"></a><span class="lineno"> 1176</span>        <span class="keywordflow">for</span> (<span class="keyword">auto</span> p_el : make_range(primary_elem_candidate-&gt;n_sub_elem()))</div>
<div class="line"><a id="l01177" name="l01177"></a><span class="lineno"> 1177</span>        {</div>
<div class="line"><a id="l01178" name="l01178"></a><span class="lineno"> 1178</span>          <span class="comment">// Get nodes of primary sub-elements</span></div>
<div class="line"><a id="l01179" name="l01179"></a><span class="lineno"> 1179</span>          <span class="keyword">auto</span> sub_elem_nodes = get_sub_elem_nodes(primary_elem_candidate-&gt;type(), p_el);</div>
<div class="line"><a id="l01180" name="l01180"></a><span class="lineno"> 1180</span> </div>
<div class="line"><a id="l01181" name="l01181"></a><span class="lineno"> 1181</span>          <span class="comment">// Get list of primary sub-element vertex nodes</span></div>
<div class="line"><a id="l01182" name="l01182"></a><span class="lineno"> 1182</span>          std::vector&lt;Point&gt; primary_sub_elem(sub_elem_nodes.size());</div>
<div class="line"><a id="l01183" name="l01183"></a><span class="lineno"> 1183</span>          <span class="keywordflow">for</span> (<span class="keyword">auto</span> iv : make_range(sub_elem_nodes.size()))</div>
<div class="line"><a id="l01184" name="l01184"></a><span class="lineno"> 1184</span>          {</div>
<div class="line"><a id="l01185" name="l01185"></a><span class="lineno"> 1185</span>            <span class="keyword">const</span> <span class="keyword">auto</span> n = sub_elem_nodes[iv];</div>
<div class="line"><a id="l01186" name="l01186"></a><span class="lineno"> 1186</span>            primary_sub_elem[iv] = primary_elem_candidate-&gt;point(n);</div>
<div class="line"><a id="l01187" name="l01187"></a><span class="lineno"> 1187</span>          }</div>
<div class="line"><a id="l01188" name="l01188"></a><span class="lineno"> 1188</span> </div>
<div class="line"><a id="l01189" name="l01189"></a><span class="lineno"> 1189</span>          <span class="comment">// Loop through secondary sub-elements</span></div>
<div class="line"><a id="l01190" name="l01190"></a><span class="lineno"> 1190</span>          <span class="keywordflow">for</span> (<span class="keyword">auto</span> s_el : make_range(secondary_side_elem-&gt;n_sub_elem()))</div>
<div class="line"><a id="l01191" name="l01191"></a><span class="lineno"> 1191</span>          {</div>
<div class="line"><a id="l01192" name="l01192"></a><span class="lineno"> 1192</span>            <span class="comment">// Mortar segment helpers were defined for each secondary sub-element, they will:</span></div>
<div class="line"><a id="l01193" name="l01193"></a><span class="lineno"> 1193</span>            <span class="comment">//  1. Project primary sub-element onto linearized secondary sub-element</span></div>
<div class="line"><a id="l01194" name="l01194"></a><span class="lineno"> 1194</span>            <span class="comment">//  2. Clip projected primary sub-element against secondary sub-element</span></div>
<div class="line"><a id="l01195" name="l01195"></a><span class="lineno"> 1195</span>            <span class="comment">//  3. Triangulate clipped polygon to form mortar segments</span></div>
<div class="line"><a id="l01196" name="l01196"></a><span class="lineno"> 1196</span>            <span class="comment">//</span></div>
<div class="line"><a id="l01197" name="l01197"></a><span class="lineno"> 1197</span>            <span class="comment">// Mortar segment helpers append a list of mortar segment nodes and connectivities that</span></div>
<div class="line"><a id="l01198" name="l01198"></a><span class="lineno"> 1198</span>            <span class="comment">// can be directly used to build mortar segments</span></div>
<div class="line"><a id="l01199" name="l01199"></a><span class="lineno"> 1199</span>            mortar_segment_helper[s_el]-&gt;getMortarSegments(</div>
<div class="line"><a id="l01200" name="l01200"></a><span class="lineno"> 1200</span>                primary_sub_elem, nodal_points, elem_to_node_map);</div>
<div class="line"><a id="l01201" name="l01201"></a><span class="lineno"> 1201</span> </div>
<div class="line"><a id="l01202" name="l01202"></a><span class="lineno"> 1202</span>            <span class="comment">// Keep track of which secondary and primary sub-elements created segment</span></div>
<div class="line"><a id="l01203" name="l01203"></a><span class="lineno"> 1203</span>            <span class="keywordflow">for</span> (<span class="keyword">auto</span> i = sub_elem_map.size(); i &lt; elem_to_node_map.size(); ++i)</div>
<div class="line"><a id="l01204" name="l01204"></a><span class="lineno"> 1204</span>              sub_elem_map.push_back(std::make_pair(s_el, p_el));</div>
<div class="line"><a id="l01205" name="l01205"></a><span class="lineno"> 1205</span>          }</div>
<div class="line"><a id="l01206" name="l01206"></a><span class="lineno"> 1206</span>        }</div>
<div class="line"><a id="l01207" name="l01207"></a><span class="lineno"> 1207</span> </div>
<div class="line"><a id="l01208" name="l01208"></a><span class="lineno"> 1208</span>        <span class="comment">// Mark primary element as processed and remove from candidate list</span></div>
<div class="line"><a id="l01209" name="l01209"></a><span class="lineno"> 1209</span>        processed_primary_elems.insert(primary_elem_candidate);</div>
<div class="line"><a id="l01210" name="l01210"></a><span class="lineno"> 1210</span>        primary_elem_candidates.erase(primary_elem_candidate);</div>
<div class="line"><a id="l01211" name="l01211"></a><span class="lineno"> 1211</span> </div>
<div class="line"><a id="l01212" name="l01212"></a><span class="lineno"> 1212</span>        <span class="comment">// If overlap of polygons was non-trivial (created mortar segment elements)</span></div>
<div class="line"><a id="l01213" name="l01213"></a><span class="lineno"> 1213</span>        <span class="keywordflow">if</span> (!elem_to_node_map.empty())</div>
<div class="line"><a id="l01214" name="l01214"></a><span class="lineno"> 1214</span>        {</div>
<div class="line"><a id="l01215" name="l01215"></a><span class="lineno"> 1215</span>          <span class="comment">// If this is the first element with non-trivial overlap, set flag</span></div>
<div class="line"><a id="l01216" name="l01216"></a><span class="lineno"> 1216</span>          <span class="comment">// Candidates will now be neighbors of elements that had non-trivial overlap</span></div>
<div class="line"><a id="l01217" name="l01217"></a><span class="lineno"> 1217</span>          <span class="comment">// (i.e. we&#39;ll do a breadth first search now)</span></div>
<div class="line"><a id="l01218" name="l01218"></a><span class="lineno"> 1218</span>          <span class="keywordflow">if</span> (!primary_elem_found)</div>
<div class="line"><a id="l01219" name="l01219"></a><span class="lineno"> 1219</span>          {</div>
<div class="line"><a id="l01220" name="l01220"></a><span class="lineno"> 1220</span>            primary_elem_found = <span class="keyword">true</span>;</div>
<div class="line"><a id="l01221" name="l01221"></a><span class="lineno"> 1221</span>            primary_elem_candidates.clear();</div>
<div class="line"><a id="l01222" name="l01222"></a><span class="lineno"> 1222</span>          }</div>
<div class="line"><a id="l01223" name="l01223"></a><span class="lineno"> 1223</span> </div>
<div class="line"><a id="l01224" name="l01224"></a><span class="lineno"> 1224</span>          <span class="comment">// Add neighbors to candidate list</span></div>
<div class="line"><a id="l01225" name="l01225"></a><span class="lineno"> 1225</span>          <span class="keywordflow">for</span> (<span class="keyword">auto</span> neighbor : primary_elem_candidate-&gt;neighbor_ptr_range())</div>
<div class="line"><a id="l01226" name="l01226"></a><span class="lineno"> 1226</span>          {</div>
<div class="line"><a id="l01227" name="l01227"></a><span class="lineno"> 1227</span>            <span class="comment">// If not valid or not on lower dimensional secondary subdomain, skip</span></div>
<div class="line"><a id="l01228" name="l01228"></a><span class="lineno"> 1228</span>            <span class="keywordflow">if</span> (neighbor == <span class="keyword">nullptr</span> || neighbor-&gt;subdomain_id() != primary_subd_id)</div>
<div class="line"><a id="l01229" name="l01229"></a><span class="lineno"> 1229</span>              <span class="keywordflow">continue</span>;</div>
<div class="line"><a id="l01230" name="l01230"></a><span class="lineno"> 1230</span>            <span class="comment">// If already processed, skip</span></div>
<div class="line"><a id="l01231" name="l01231"></a><span class="lineno"> 1231</span>            <span class="keywordflow">if</span> (processed_primary_elems.count(neighbor))</div>
<div class="line"><a id="l01232" name="l01232"></a><span class="lineno"> 1232</span>              <span class="keywordflow">continue</span>;</div>
<div class="line"><a id="l01233" name="l01233"></a><span class="lineno"> 1233</span>            <span class="comment">// Otherwise, add to candidates</span></div>
<div class="line"><a id="l01234" name="l01234"></a><span class="lineno"> 1234</span>            primary_elem_candidates.insert(neighbor);</div>
<div class="line"><a id="l01235" name="l01235"></a><span class="lineno"> 1235</span>          }</div>
<div class="line"><a id="l01236" name="l01236"></a><span class="lineno"> 1236</span> </div>
<div class="line"><a id="l01240" name="l01240"></a><span class="lineno"> 1240</span>          std::vector&lt;Node *&gt; new_nodes;</div>
<div class="line"><a id="l01241" name="l01241"></a><span class="lineno"> 1241</span>          <span class="keywordflow">for</span> (<span class="keyword">auto</span> pt : nodal_points)</div>
<div class="line"><a id="l01242" name="l01242"></a><span class="lineno"> 1242</span>            new_nodes.push_back(<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;add_point(</div>
<div class="line"><a id="l01243" name="l01243"></a><span class="lineno"> 1243</span>                pt, <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;max_node_id(), secondary_side_elem-&gt;processor_id()));</div>
<div class="line"><a id="l01244" name="l01244"></a><span class="lineno"> 1244</span> </div>
<div class="line"><a id="l01245" name="l01245"></a><span class="lineno"> 1245</span>          <span class="comment">// Loop through triangular elements in map</span></div>
<div class="line"><a id="l01246" name="l01246"></a><span class="lineno"> 1246</span>          <span class="keywordflow">for</span> (<span class="keyword">auto</span> el : index_range(elem_to_node_map))</div>
<div class="line"><a id="l01247" name="l01247"></a><span class="lineno"> 1247</span>          {</div>
<div class="line"><a id="l01248" name="l01248"></a><span class="lineno"> 1248</span>            <span class="comment">// Create new triangular element</span></div>
<div class="line"><a id="l01249" name="l01249"></a><span class="lineno"> 1249</span>            std::unique_ptr&lt;Elem&gt; new_elem;</div>
<div class="line"><a id="l01250" name="l01250"></a><span class="lineno"> 1250</span>            <span class="keywordflow">if</span> (elem_to_node_map[el].size() == 3)</div>
<div class="line"><a id="l01251" name="l01251"></a><span class="lineno"> 1251</span>              new_elem = std::make_unique&lt;Tri3&gt;();</div>
<div class="line"><a id="l01252" name="l01252"></a><span class="lineno"> 1252</span>            <span class="keywordflow">else</span></div>
<div class="line"><a id="l01253" name="l01253"></a><span class="lineno"> 1253</span>              <a class="code hl_function" href="MooseError_8h.html#aa959168eed29caa7aaa85ffc1319a9ad">mooseError</a>(<span class="stringliteral">&quot;Active mortar segments only supports TRI elements, 3 nodes expected &quot;</span></div>
<div class="line"><a id="l01254" name="l01254"></a><span class="lineno"> 1254</span>                         <span class="stringliteral">&quot;but: &quot;</span>,</div>
<div class="line"><a id="l01255" name="l01255"></a><span class="lineno"> 1255</span>                         elem_to_node_map[el].size(),</div>
<div class="line"><a id="l01256" name="l01256"></a><span class="lineno"> 1256</span>                         <span class="stringliteral">&quot; provided.&quot;</span>);</div>
<div class="line"><a id="l01257" name="l01257"></a><span class="lineno"> 1257</span> </div>
<div class="line"><a id="l01258" name="l01258"></a><span class="lineno"> 1258</span>            new_elem-&gt;processor_id() = secondary_side_elem-&gt;processor_id();</div>
<div class="line"><a id="l01259" name="l01259"></a><span class="lineno"> 1259</span>            new_elem-&gt;subdomain_id() = secondary_side_elem-&gt;subdomain_id();</div>
<div class="line"><a id="l01260" name="l01260"></a><span class="lineno"> 1260</span>            new_elem-&gt;set_id(local_id_index++);</div>
<div class="line"><a id="l01261" name="l01261"></a><span class="lineno"> 1261</span> </div>
<div class="line"><a id="l01262" name="l01262"></a><span class="lineno"> 1262</span>            <span class="comment">// Attach newly created nodes</span></div>
<div class="line"><a id="l01263" name="l01263"></a><span class="lineno"> 1263</span>            <span class="keywordflow">for</span> (<span class="keyword">auto</span> i : index_range(elem_to_node_map[el]))</div>
<div class="line"><a id="l01264" name="l01264"></a><span class="lineno"> 1264</span>              new_elem-&gt;set_node(i) = new_nodes[elem_to_node_map[el][i]];</div>
<div class="line"><a id="l01265" name="l01265"></a><span class="lineno"> 1265</span> </div>
<div class="line"><a id="l01266" name="l01266"></a><span class="lineno"> 1266</span>            <span class="comment">// If element is smaller than tolerance, don&#39;t add to msm</span></div>
<div class="line"><a id="l01267" name="l01267"></a><span class="lineno"> 1267</span>            <span class="keywordflow">if</span> (new_elem-&gt;volume() / secondary_volume &lt; TOLERANCE)</div>
<div class="line"><a id="l01268" name="l01268"></a><span class="lineno"> 1268</span>              <span class="keywordflow">continue</span>;</div>
<div class="line"><a id="l01269" name="l01269"></a><span class="lineno"> 1269</span> </div>
<div class="line"><a id="l01270" name="l01270"></a><span class="lineno"> 1270</span>            <span class="comment">// Add elements to mortar segment mesh</span></div>
<div class="line"><a id="l01271" name="l01271"></a><span class="lineno"> 1271</span>            Elem * msm_new_elem = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;add_elem(new_elem.release());</div>
<div class="line"><a id="l01272" name="l01272"></a><span class="lineno"> 1272</span> </div>
<div class="line"><a id="l01273" name="l01273"></a><span class="lineno"> 1273</span>            msm_new_elem-&gt;set_extra_integer(secondary_sub_elem, sub_elem_map[el].first);</div>
<div class="line"><a id="l01274" name="l01274"></a><span class="lineno"> 1274</span>            msm_new_elem-&gt;set_extra_integer(primary_sub_elem, sub_elem_map[el].second);</div>
<div class="line"><a id="l01275" name="l01275"></a><span class="lineno"> 1275</span> </div>
<div class="line"><a id="l01276" name="l01276"></a><span class="lineno"> 1276</span>            <span class="comment">// Fill out mortar segment info</span></div>
<div class="line"><a id="l01277" name="l01277"></a><span class="lineno"> 1277</span>            <a class="code hl_struct" href="structMortarSegmentInfo.html">MortarSegmentInfo</a> msinfo;</div>
<div class="line"><a id="l01278" name="l01278"></a><span class="lineno"> 1278</span>            msinfo.<a class="code hl_variable" href="structMortarSegmentInfo.html#afa8c2918a473f0dad90d5c68dad00eb4">secondary_elem</a> = secondary_side_elem;</div>
<div class="line"><a id="l01279" name="l01279"></a><span class="lineno"> 1279</span>            msinfo.<a class="code hl_variable" href="structMortarSegmentInfo.html#a3316fbff8584e06e3c973d3f3e6ff05f">primary_elem</a> = primary_elem_candidate;</div>
<div class="line"><a id="l01280" name="l01280"></a><span class="lineno"> 1280</span> </div>
<div class="line"><a id="l01281" name="l01281"></a><span class="lineno"> 1281</span>            <span class="comment">// Associate this MSM elem with the MortarSegmentInfo.</span></div>
<div class="line"><a id="l01282" name="l01282"></a><span class="lineno"> 1282</span>            <a class="code hl_variable" href="classAutomaticMortarGeneration.html#abbd91d3cf8bef528976fe6f932622d2d">_msm_elem_to_info</a>.emplace(msm_new_elem, msinfo);</div>
<div class="line"><a id="l01283" name="l01283"></a><span class="lineno"> 1283</span> </div>
<div class="line"><a id="l01284" name="l01284"></a><span class="lineno"> 1284</span>            <span class="comment">// Add this mortar segment to the secondary elem to mortar segment map</span></div>
<div class="line"><a id="l01285" name="l01285"></a><span class="lineno"> 1285</span>            secondary_to_msm_element_set.insert(msm_new_elem);</div>
<div class="line"><a id="l01286" name="l01286"></a><span class="lineno"> 1286</span> </div>
<div class="line"><a id="l01287" name="l01287"></a><span class="lineno"> 1287</span>            <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a7254faea651acd63b60b408ab560a0e5">_secondary_ip_sub_ids</a>.insert(msinfo.<a class="code hl_variable" href="structMortarSegmentInfo.html#afa8c2918a473f0dad90d5c68dad00eb4">secondary_elem</a>-&gt;interior_parent()-&gt;subdomain_id());</div>
<div class="line"><a id="l01288" name="l01288"></a><span class="lineno"> 1288</span>            <span class="comment">// Unlike for 2D, we always have a primary when building the mortar mesh so we don&#39;t</span></div>
<div class="line"><a id="l01289" name="l01289"></a><span class="lineno"> 1289</span>            <span class="comment">// have to check for null</span></div>
<div class="line"><a id="l01290" name="l01290"></a><span class="lineno"> 1290</span>            <a class="code hl_variable" href="classAutomaticMortarGeneration.html#ac99e408cefd4da80efa2649ef1d32e93">_primary_ip_sub_ids</a>.insert(msinfo.<a class="code hl_variable" href="structMortarSegmentInfo.html#a3316fbff8584e06e3c973d3f3e6ff05f">primary_elem</a>-&gt;interior_parent()-&gt;subdomain_id());</div>
<div class="line"><a id="l01291" name="l01291"></a><span class="lineno"> 1291</span>          }</div>
<div class="line"><a id="l01292" name="l01292"></a><span class="lineno"> 1292</span>        }</div>
<div class="line"><a id="l01293" name="l01293"></a><span class="lineno"> 1293</span>        <span class="comment">// End loop through primary element candidates</span></div>
<div class="line"><a id="l01294" name="l01294"></a><span class="lineno"> 1294</span>      }</div>
<div class="line"><a id="l01295" name="l01295"></a><span class="lineno"> 1295</span> </div>
<div class="line"><a id="l01296" name="l01296"></a><span class="lineno"> 1296</span>      <span class="keywordflow">for</span> (<span class="keyword">auto</span> sel : make_range(secondary_side_elem-&gt;n_sub_elem()))</div>
<div class="line"><a id="l01297" name="l01297"></a><span class="lineno"> 1297</span>      {</div>
<div class="line"><a id="l01298" name="l01298"></a><span class="lineno"> 1298</span>        <span class="comment">// Check if any segments failed to project</span></div>
<div class="line"><a id="l01299" name="l01299"></a><span class="lineno"> 1299</span>        <span class="keywordflow">if</span> (mortar_segment_helper[sel]-&gt;remainder() == 1.0)</div>
<div class="line"><a id="l01300" name="l01300"></a><span class="lineno"> 1300</span>          mooseDoOnce(</div>
<div class="line"><a id="l01301" name="l01301"></a><span class="lineno"> 1301</span>              <a class="code hl_function" href="MooseError_8h.html#a3d351254665674621ecbd38f57bb28ae">mooseWarning</a>(<span class="stringliteral">&quot;Some secondary elements on mortar interface were unable to identify&quot;</span></div>
<div class="line"><a id="l01302" name="l01302"></a><span class="lineno"> 1302</span>                           <span class="stringliteral">&quot; a corresponding primary element; this may be expected depending on&quot;</span></div>
<div class="line"><a id="l01303" name="l01303"></a><span class="lineno"> 1303</span>                           <span class="stringliteral">&quot; problem geometry but may indicate a failure of the element search&quot;</span></div>
<div class="line"><a id="l01304" name="l01304"></a><span class="lineno"> 1304</span>                           <span class="stringliteral">&quot; or projection&quot;</span>));</div>
<div class="line"><a id="l01305" name="l01305"></a><span class="lineno"> 1305</span>      }</div>
<div class="line"><a id="l01306" name="l01306"></a><span class="lineno"> 1306</span> </div>
<div class="line"><a id="l01307" name="l01307"></a><span class="lineno"> 1307</span>      <span class="keywordflow">if</span> (secondary_to_msm_element_set.empty())</div>
<div class="line"><a id="l01308" name="l01308"></a><span class="lineno"> 1308</span>        <a class="code hl_variable" href="classAutomaticMortarGeneration.html#af0da3b7d9e404238718805e12452d74d">_secondary_elems_to_mortar_segments</a>.erase(secondary_elem_to_msm_map_it);</div>
<div class="line"><a id="l01309" name="l01309"></a><span class="lineno"> 1309</span>    } <span class="comment">// End loop through secondary elements</span></div>
<div class="line"><a id="l01310" name="l01310"></a><span class="lineno"> 1310</span>  }   <span class="comment">// End loop through mortar constraint pairs</span></div>
<div class="line"><a id="l01311" name="l01311"></a><span class="lineno"> 1311</span> </div>
<div class="line"><a id="l01312" name="l01312"></a><span class="lineno"> 1312</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;cache_elem_data();</div>
<div class="line"><a id="l01313" name="l01313"></a><span class="lineno"> 1313</span> </div>
<div class="line"><a id="l01314" name="l01314"></a><span class="lineno"> 1314</span>  <span class="comment">// Output mortar segment mesh</span></div>
<div class="line"><a id="l01315" name="l01315"></a><span class="lineno"> 1315</span>  <span class="keywordflow">if</span> (<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a958de5b754ec676f463c50d2f16b5d0c">_debug</a>)</div>
<div class="line"><a id="l01316" name="l01316"></a><span class="lineno"> 1316</span>  {</div>
<div class="line"><a id="l01317" name="l01317"></a><span class="lineno"> 1317</span>    <span class="comment">// If element is not triangular, increment subdomain id</span></div>
<div class="line"><a id="l01318" name="l01318"></a><span class="lineno"> 1318</span>    <span class="comment">// (ExodusII does not support mixed element types in a single subdomain)</span></div>
<div class="line"><a id="l01319" name="l01319"></a><span class="lineno"> 1319</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> msm_el : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;active_local_element_ptr_range())</div>
<div class="line"><a id="l01320" name="l01320"></a><span class="lineno"> 1320</span>      <span class="keywordflow">if</span> (msm_el-&gt;type() != TRI3)</div>
<div class="line"><a id="l01321" name="l01321"></a><span class="lineno"> 1321</span>        msm_el-&gt;subdomain_id()++;</div>
<div class="line"><a id="l01322" name="l01322"></a><span class="lineno"> 1322</span> </div>
<div class="line"><a id="l01323" name="l01323"></a><span class="lineno"> 1323</span>    ExodusII_IO mortar_segment_mesh_writer(*<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>);</div>
<div class="line"><a id="l01324" name="l01324"></a><span class="lineno"> 1324</span> </div>
<div class="line"><a id="l01325" name="l01325"></a><span class="lineno"> 1325</span>    <span class="comment">// Default to non-HDF5 output for wider compatibility</span></div>
<div class="line"><a id="l01326" name="l01326"></a><span class="lineno"> 1326</span>    mortar_segment_mesh_writer.set_hdf5_writing(<span class="keyword">false</span>);</div>
<div class="line"><a id="l01327" name="l01327"></a><span class="lineno"> 1327</span> </div>
<div class="line"><a id="l01328" name="l01328"></a><span class="lineno"> 1328</span>    mortar_segment_mesh_writer.write(<span class="stringliteral">&quot;mortar_segment_mesh.e&quot;</span>);</div>
<div class="line"><a id="l01329" name="l01329"></a><span class="lineno"> 1329</span> </div>
<div class="line"><a id="l01330" name="l01330"></a><span class="lineno"> 1330</span>    <span class="comment">// Undo increment</span></div>
<div class="line"><a id="l01331" name="l01331"></a><span class="lineno"> 1331</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> msm_el : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;active_local_element_ptr_range())</div>
<div class="line"><a id="l01332" name="l01332"></a><span class="lineno"> 1332</span>      <span class="keywordflow">if</span> (msm_el-&gt;type() != TRI3)</div>
<div class="line"><a id="l01333" name="l01333"></a><span class="lineno"> 1333</span>        msm_el-&gt;subdomain_id()--;</div>
<div class="line"><a id="l01334" name="l01334"></a><span class="lineno"> 1334</span>  }</div>
<div class="line"><a id="l01335" name="l01335"></a><span class="lineno"> 1335</span> </div>
<div class="line"><a id="l01336" name="l01336"></a><span class="lineno"> 1336</span>  <a class="code hl_function" href="classAutomaticMortarGeneration.html#a6dfaa66a5dc83c679a3c4dd7aa0bf1ab">buildCouplingInformation</a>();</div>
<div class="line"><a id="l01337" name="l01337"></a><span class="lineno"> 1337</span> </div>
<div class="line"><a id="l01338" name="l01338"></a><span class="lineno"> 1338</span>  <span class="comment">// Print mortar segment mesh statistics</span></div>
<div class="line"><a id="l01339" name="l01339"></a><span class="lineno"> 1339</span>  <span class="keywordflow">if</span> (<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a958de5b754ec676f463c50d2f16b5d0c">_debug</a>)</div>
<div class="line"><a id="l01340" name="l01340"></a><span class="lineno"> 1340</span>  {</div>
<div class="line"><a id="l01341" name="l01341"></a><span class="lineno"> 1341</span>    <span class="keywordflow">if</span> (<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.n_processors() == 1)</div>
<div class="line"><a id="l01342" name="l01342"></a><span class="lineno"> 1342</span>      <a class="code hl_function" href="classAutomaticMortarGeneration.html#a345cd37f09eebfb0b829c15f7fd4a441">msmStatistics</a>();</div>
<div class="line"><a id="l01343" name="l01343"></a><span class="lineno"> 1343</span>    <span class="keywordflow">else</span></div>
<div class="line"><a id="l01344" name="l01344"></a><span class="lineno"> 1344</span>      <a class="code hl_function" href="MooseError_8h.html#a3d351254665674621ecbd38f57bb28ae">mooseWarning</a>(<span class="stringliteral">&quot;Mortar segment mesh statistics intended for debugging purposes in serial only, &quot;</span></div>
<div class="line"><a id="l01345" name="l01345"></a><span class="lineno"> 1345</span>                   <span class="stringliteral">&quot;parallel will only provide statistics for local mortar segment mesh.&quot;</span>);</div>
<div class="line"><a id="l01346" name="l01346"></a><span class="lineno"> 1346</span>  }</div>
<div class="line"><a id="l01347" name="l01347"></a><span class="lineno"> 1347</span>}</div>
<div class="line"><a id="l01348" name="l01348"></a><span class="lineno"> 1348</span> </div>
<div class="line"><a id="l01349" name="l01349"></a><span class="lineno"> 1349</span><span class="keywordtype">void</span></div>
<div class="line"><a id="l01350" name="l01350"></a><span class="lineno"><a class="line" href="classAutomaticMortarGeneration.html#a6dfaa66a5dc83c679a3c4dd7aa0bf1ab"> 1350</a></span><a class="code hl_function" href="classAutomaticMortarGeneration.html#a6dfaa66a5dc83c679a3c4dd7aa0bf1ab">AutomaticMortarGeneration::buildCouplingInformation</a>()</div>
<div class="line"><a id="l01351" name="l01351"></a><span class="lineno"> 1351</span>{</div>
<div class="line"><a id="l01352" name="l01352"></a><span class="lineno"> 1352</span>  std::unordered_map&lt;processor_id_type, std::vector&lt;std::pair&lt;dof_id_type, dof_id_type&gt;&gt;&gt;</div>
<div class="line"><a id="l01353" name="l01353"></a><span class="lineno"> 1353</span>      coupling_info;</div>
<div class="line"><a id="l01354" name="l01354"></a><span class="lineno"> 1354</span> </div>
<div class="line"><a id="l01355" name="l01355"></a><span class="lineno"> 1355</span>  <span class="comment">// Loop over the msm_elem_to_info object and build a bi-directional</span></div>
<div class="line"><a id="l01356" name="l01356"></a><span class="lineno"> 1356</span>  <span class="comment">// multimap from secondary elements to the primary Elems which they are</span></div>
<div class="line"><a id="l01357" name="l01357"></a><span class="lineno"> 1357</span>  <span class="comment">// coupled to and vice-versa. This is used in the</span></div>
<div class="line"><a id="l01358" name="l01358"></a><span class="lineno"> 1358</span>  <span class="comment">// AugmentSparsityOnInterface functor to determine whether a given</span></div>
<div class="line"><a id="l01359" name="l01359"></a><span class="lineno"> 1359</span>  <span class="comment">// secondary Elem is coupled across the mortar interface to a primary</span></div>
<div class="line"><a id="l01360" name="l01360"></a><span class="lineno"> 1360</span>  <span class="comment">// element.</span></div>
<div class="line"><a id="l01361" name="l01361"></a><span class="lineno"> 1361</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; pr : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#abbd91d3cf8bef528976fe6f932622d2d">_msm_elem_to_info</a>)</div>
<div class="line"><a id="l01362" name="l01362"></a><span class="lineno"> 1362</span>  {</div>
<div class="line"><a id="l01363" name="l01363"></a><span class="lineno"> 1363</span>    <span class="keyword">const</span> Elem * secondary_elem = pr.second.secondary_elem;</div>
<div class="line"><a id="l01364" name="l01364"></a><span class="lineno"> 1364</span>    <span class="keyword">const</span> Elem * primary_elem = pr.second.primary_elem;</div>
<div class="line"><a id="l01365" name="l01365"></a><span class="lineno"> 1365</span> </div>
<div class="line"><a id="l01366" name="l01366"></a><span class="lineno"> 1366</span>    <span class="comment">// LowerSecondary</span></div>
<div class="line"><a id="l01367" name="l01367"></a><span class="lineno"> 1367</span>    coupling_info[secondary_elem-&gt;processor_id()].emplace_back(</div>
<div class="line"><a id="l01368" name="l01368"></a><span class="lineno"> 1368</span>        secondary_elem-&gt;id(), secondary_elem-&gt;interior_parent()-&gt;id());</div>
<div class="line"><a id="l01369" name="l01369"></a><span class="lineno"> 1369</span>    <span class="keywordflow">if</span> (secondary_elem-&gt;processor_id() != <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.processor_id())</div>
<div class="line"><a id="l01370" name="l01370"></a><span class="lineno"> 1370</span>      <span class="comment">// We want to keep information for nonlocal lower-dimensional secondary element point</span></div>
<div class="line"><a id="l01371" name="l01371"></a><span class="lineno"> 1371</span>      <span class="comment">// neighbors for mortar nodal aux kernels</span></div>
<div class="line"><a id="l01372" name="l01372"></a><span class="lineno"> 1372</span>      <a class="code hl_variable" href="classAutomaticMortarGeneration.html#ab2357a3aacfa2cae90078e3b6293bf26">_mortar_interface_coupling</a>[secondary_elem-&gt;id()].insert(</div>
<div class="line"><a id="l01373" name="l01373"></a><span class="lineno"> 1373</span>          secondary_elem-&gt;interior_parent()-&gt;id());</div>
<div class="line"><a id="l01374" name="l01374"></a><span class="lineno"> 1374</span> </div>
<div class="line"><a id="l01375" name="l01375"></a><span class="lineno"> 1375</span>    <span class="comment">// LowerPrimary</span></div>
<div class="line"><a id="l01376" name="l01376"></a><span class="lineno"> 1376</span>    coupling_info[secondary_elem-&gt;processor_id()].emplace_back(</div>
<div class="line"><a id="l01377" name="l01377"></a><span class="lineno"> 1377</span>        secondary_elem-&gt;id(), primary_elem-&gt;interior_parent()-&gt;id());</div>
<div class="line"><a id="l01378" name="l01378"></a><span class="lineno"> 1378</span>    <span class="keywordflow">if</span> (secondary_elem-&gt;processor_id() != <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.processor_id())</div>
<div class="line"><a id="l01379" name="l01379"></a><span class="lineno"> 1379</span>      <span class="comment">// We want to keep information for nonlocal lower-dimensional secondary element point</span></div>
<div class="line"><a id="l01380" name="l01380"></a><span class="lineno"> 1380</span>      <span class="comment">// neighbors for mortar nodal aux kernels</span></div>
<div class="line"><a id="l01381" name="l01381"></a><span class="lineno"> 1381</span>      <a class="code hl_variable" href="classAutomaticMortarGeneration.html#ab2357a3aacfa2cae90078e3b6293bf26">_mortar_interface_coupling</a>[secondary_elem-&gt;id()].insert(</div>
<div class="line"><a id="l01382" name="l01382"></a><span class="lineno"> 1382</span>          primary_elem-&gt;interior_parent()-&gt;id());</div>
<div class="line"><a id="l01383" name="l01383"></a><span class="lineno"> 1383</span> </div>
<div class="line"><a id="l01384" name="l01384"></a><span class="lineno"> 1384</span>    <span class="comment">// Lower-LowerDimensionalPrimary</span></div>
<div class="line"><a id="l01385" name="l01385"></a><span class="lineno"> 1385</span>    coupling_info[secondary_elem-&gt;processor_id()].emplace_back(secondary_elem-&gt;id(),</div>
<div class="line"><a id="l01386" name="l01386"></a><span class="lineno"> 1386</span>                                                               primary_elem-&gt;id());</div>
<div class="line"><a id="l01387" name="l01387"></a><span class="lineno"> 1387</span>    <span class="keywordflow">if</span> (secondary_elem-&gt;processor_id() != <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.processor_id())</div>
<div class="line"><a id="l01388" name="l01388"></a><span class="lineno"> 1388</span>      <span class="comment">// We want to keep information for nonlocal lower-dimensional secondary element point</span></div>
<div class="line"><a id="l01389" name="l01389"></a><span class="lineno"> 1389</span>      <span class="comment">// neighbors for mortar nodal aux kernels</span></div>
<div class="line"><a id="l01390" name="l01390"></a><span class="lineno"> 1390</span>      <a class="code hl_variable" href="classAutomaticMortarGeneration.html#ab2357a3aacfa2cae90078e3b6293bf26">_mortar_interface_coupling</a>[secondary_elem-&gt;id()].insert(primary_elem-&gt;id());</div>
<div class="line"><a id="l01391" name="l01391"></a><span class="lineno"> 1391</span> </div>
<div class="line"><a id="l01392" name="l01392"></a><span class="lineno"> 1392</span>    <span class="comment">// SecondaryLower</span></div>
<div class="line"><a id="l01393" name="l01393"></a><span class="lineno"> 1393</span>    coupling_info[secondary_elem-&gt;interior_parent()-&gt;processor_id()].emplace_back(</div>
<div class="line"><a id="l01394" name="l01394"></a><span class="lineno"> 1394</span>        secondary_elem-&gt;interior_parent()-&gt;id(), secondary_elem-&gt;id());</div>
<div class="line"><a id="l01395" name="l01395"></a><span class="lineno"> 1395</span> </div>
<div class="line"><a id="l01396" name="l01396"></a><span class="lineno"> 1396</span>    <span class="comment">// SecondaryPrimary</span></div>
<div class="line"><a id="l01397" name="l01397"></a><span class="lineno"> 1397</span>    coupling_info[secondary_elem-&gt;interior_parent()-&gt;processor_id()].emplace_back(</div>
<div class="line"><a id="l01398" name="l01398"></a><span class="lineno"> 1398</span>        secondary_elem-&gt;interior_parent()-&gt;id(), primary_elem-&gt;interior_parent()-&gt;id());</div>
<div class="line"><a id="l01399" name="l01399"></a><span class="lineno"> 1399</span> </div>
<div class="line"><a id="l01400" name="l01400"></a><span class="lineno"> 1400</span>    <span class="comment">// PrimaryLower</span></div>
<div class="line"><a id="l01401" name="l01401"></a><span class="lineno"> 1401</span>    coupling_info[primary_elem-&gt;interior_parent()-&gt;processor_id()].emplace_back(</div>
<div class="line"><a id="l01402" name="l01402"></a><span class="lineno"> 1402</span>        primary_elem-&gt;interior_parent()-&gt;id(), secondary_elem-&gt;id());</div>
<div class="line"><a id="l01403" name="l01403"></a><span class="lineno"> 1403</span> </div>
<div class="line"><a id="l01404" name="l01404"></a><span class="lineno"> 1404</span>    <span class="comment">// PrimarySecondary</span></div>
<div class="line"><a id="l01405" name="l01405"></a><span class="lineno"> 1405</span>    coupling_info[primary_elem-&gt;interior_parent()-&gt;processor_id()].emplace_back(</div>
<div class="line"><a id="l01406" name="l01406"></a><span class="lineno"> 1406</span>        primary_elem-&gt;interior_parent()-&gt;id(), secondary_elem-&gt;interior_parent()-&gt;id());</div>
<div class="line"><a id="l01407" name="l01407"></a><span class="lineno"> 1407</span>  }</div>
<div class="line"><a id="l01408" name="l01408"></a><span class="lineno"> 1408</span> </div>
<div class="line"><a id="l01409" name="l01409"></a><span class="lineno"> 1409</span>  <span class="comment">// Push the coupling information</span></div>
<div class="line"><a id="l01410" name="l01410"></a><span class="lineno"> 1410</span>  <span class="keyword">auto</span> action_functor =</div>
<div class="line"><a id="l01411" name="l01411"></a><span class="lineno"> 1411</span>      [<span class="keyword">this</span>](processor_id_type,</div>
<div class="line"><a id="l01412" name="l01412"></a><span class="lineno"> 1412</span>             <span class="keyword">const</span> std::vector&lt;std::pair&lt;dof_id_type, dof_id_type&gt;&gt; &amp; coupling_info)</div>
<div class="line"><a id="l01413" name="l01413"></a><span class="lineno"> 1413</span>  {</div>
<div class="line"><a id="l01414" name="l01414"></a><span class="lineno"> 1414</span>    <span class="keywordflow">for</span> (<span class="keyword">auto</span> [i, j] : coupling_info)</div>
<div class="line"><a id="l01415" name="l01415"></a><span class="lineno"> 1415</span>      <a class="code hl_variable" href="classAutomaticMortarGeneration.html#ab2357a3aacfa2cae90078e3b6293bf26">_mortar_interface_coupling</a>[i].insert(j);</div>
<div class="line"><a id="l01416" name="l01416"></a><span class="lineno"> 1416</span>  };</div>
<div class="line"><a id="l01417" name="l01417"></a><span class="lineno"> 1417</span>  TIMPI::push_parallel_vector_data(<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.comm(), coupling_info, action_functor);</div>
<div class="line"><a id="l01418" name="l01418"></a><span class="lineno"> 1418</span>}</div>
<div class="line"><a id="l01419" name="l01419"></a><span class="lineno"> 1419</span> </div>
<div class="line"><a id="l01420" name="l01420"></a><span class="lineno"> 1420</span><span class="keywordtype">void</span></div>
<div class="line"><a id="l01421" name="l01421"></a><span class="lineno"><a class="line" href="classAutomaticMortarGeneration.html#a345cd37f09eebfb0b829c15f7fd4a441"> 1421</a></span><a class="code hl_function" href="classAutomaticMortarGeneration.html#a345cd37f09eebfb0b829c15f7fd4a441">AutomaticMortarGeneration::msmStatistics</a>()</div>
<div class="line"><a id="l01422" name="l01422"></a><span class="lineno"> 1422</span>{</div>
<div class="line"><a id="l01423" name="l01423"></a><span class="lineno"> 1423</span>  <span class="comment">// Print boundary pairs</span></div>
<div class="line"><a id="l01424" name="l01424"></a><span class="lineno"> 1424</span>  Moose::out &lt;&lt; <span class="stringliteral">&quot;Mortar Interface Statistics:&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a id="l01425" name="l01425"></a><span class="lineno"> 1425</span> </div>
<div class="line"><a id="l01426" name="l01426"></a><span class="lineno"> 1426</span>  <span class="comment">// Count number of elements on primary and secondary sides</span></div>
<div class="line"><a id="l01427" name="l01427"></a><span class="lineno"> 1427</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; pr : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a969d4ab038fc8d447e966cd1e1600091">_primary_secondary_subdomain_id_pairs</a>)</div>
<div class="line"><a id="l01428" name="l01428"></a><span class="lineno"> 1428</span>  {</div>
<div class="line"><a id="l01429" name="l01429"></a><span class="lineno"> 1429</span>    <span class="keyword">const</span> <span class="keyword">auto</span> primary_subd_id = pr.first;</div>
<div class="line"><a id="l01430" name="l01430"></a><span class="lineno"> 1430</span>    <span class="keyword">const</span> <span class="keyword">auto</span> secondary_subd_id = pr.second;</div>
<div class="line"><a id="l01431" name="l01431"></a><span class="lineno"> 1431</span> </div>
<div class="line"><a id="l01432" name="l01432"></a><span class="lineno"> 1432</span>    <span class="comment">// Allocate statistics vectors for primary lower, secondary lower, and msm meshes</span></div>
<div class="line"><a id="l01433" name="l01433"></a><span class="lineno"> 1433</span>    StatisticsVector&lt;Real&gt; primary;   <span class="comment">// primary.reserve(mesh.n_elem());</span></div>
<div class="line"><a id="l01434" name="l01434"></a><span class="lineno"> 1434</span>    StatisticsVector&lt;Real&gt; secondary; <span class="comment">// secondary.reserve(mesh.n_elem());</span></div>
<div class="line"><a id="l01435" name="l01435"></a><span class="lineno"> 1435</span>    StatisticsVector&lt;Real&gt; msm;       <span class="comment">// msm.reserve(mortar_segment_mesh-&gt;n_elem());</span></div>
<div class="line"><a id="l01436" name="l01436"></a><span class="lineno"> 1436</span> </div>
<div class="line"><a id="l01437" name="l01437"></a><span class="lineno"> 1437</span>    <span class="keywordflow">for</span> (<span class="keyword">auto</span> * el : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.active_element_ptr_range())</div>
<div class="line"><a id="l01438" name="l01438"></a><span class="lineno"> 1438</span>    {</div>
<div class="line"><a id="l01439" name="l01439"></a><span class="lineno"> 1439</span>      <span class="comment">// Add secondary and primary elem volumes to statistics vector</span></div>
<div class="line"><a id="l01440" name="l01440"></a><span class="lineno"> 1440</span>      <span class="keywordflow">if</span> (el-&gt;subdomain_id() == secondary_subd_id)</div>
<div class="line"><a id="l01441" name="l01441"></a><span class="lineno"> 1441</span>        secondary.push_back(el-&gt;volume());</div>
<div class="line"><a id="l01442" name="l01442"></a><span class="lineno"> 1442</span>      <span class="keywordflow">else</span> <span class="keywordflow">if</span> (el-&gt;subdomain_id() == primary_subd_id)</div>
<div class="line"><a id="l01443" name="l01443"></a><span class="lineno"> 1443</span>        primary.push_back(el-&gt;volume());</div>
<div class="line"><a id="l01444" name="l01444"></a><span class="lineno"> 1444</span>    }</div>
<div class="line"><a id="l01445" name="l01445"></a><span class="lineno"> 1445</span> </div>
<div class="line"><a id="l01446" name="l01446"></a><span class="lineno"> 1446</span>    <span class="comment">// Note: when we allow more than one primary secondary pair will need to make</span></div>
<div class="line"><a id="l01447" name="l01447"></a><span class="lineno"> 1447</span>    <span class="comment">// separate mortar segment mesh for each</span></div>
<div class="line"><a id="l01448" name="l01448"></a><span class="lineno"> 1448</span>    <span class="keywordflow">for</span> (<span class="keyword">auto</span> msm_elem : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;active_local_element_ptr_range())</div>
<div class="line"><a id="l01449" name="l01449"></a><span class="lineno"> 1449</span>    {</div>
<div class="line"><a id="l01450" name="l01450"></a><span class="lineno"> 1450</span>      <span class="comment">// Add msm elem volume to statistic vector</span></div>
<div class="line"><a id="l01451" name="l01451"></a><span class="lineno"> 1451</span>      msm.push_back(msm_elem-&gt;volume());</div>
<div class="line"><a id="l01452" name="l01452"></a><span class="lineno"> 1452</span>    }</div>
<div class="line"><a id="l01453" name="l01453"></a><span class="lineno"> 1453</span> </div>
<div class="line"><a id="l01454" name="l01454"></a><span class="lineno"> 1454</span>    <span class="comment">// Create table</span></div>
<div class="line"><a id="l01455" name="l01455"></a><span class="lineno"> 1455</span>    std::vector&lt;std::string&gt; col_names = {<span class="stringliteral">&quot;mesh&quot;</span>, <span class="stringliteral">&quot;n_elems&quot;</span>, <span class="stringliteral">&quot;max&quot;</span>, <span class="stringliteral">&quot;min&quot;</span>, <span class="stringliteral">&quot;median&quot;</span>};</div>
<div class="line"><a id="l01456" name="l01456"></a><span class="lineno"> 1456</span>    std::vector&lt;std::string&gt; subds = {<span class="stringliteral">&quot;secondary_lower&quot;</span>, <span class="stringliteral">&quot;primary_lower&quot;</span>, <span class="stringliteral">&quot;mortar_segment&quot;</span>};</div>
<div class="line"><a id="l01457" name="l01457"></a><span class="lineno"> 1457</span>    std::vector&lt;size_t&gt; n_elems = {secondary.size(), primary.size(), msm.size()};</div>
<div class="line"><a id="l01458" name="l01458"></a><span class="lineno"> 1458</span>    std::vector&lt;Real&gt; maxs = {secondary.maximum(), primary.maximum(), msm.maximum()};</div>
<div class="line"><a id="l01459" name="l01459"></a><span class="lineno"> 1459</span>    std::vector&lt;Real&gt; mins = {secondary.minimum(), primary.minimum(), msm.minimum()};</div>
<div class="line"><a id="l01460" name="l01460"></a><span class="lineno"> 1460</span>    std::vector&lt;Real&gt; medians = {secondary.median(), primary.median(), msm.median()};</div>
<div class="line"><a id="l01461" name="l01461"></a><span class="lineno"> 1461</span> </div>
<div class="line"><a id="l01462" name="l01462"></a><span class="lineno"> 1462</span>    <a class="code hl_class" href="classFormattedTable.html">FormattedTable</a> table;</div>
<div class="line"><a id="l01463" name="l01463"></a><span class="lineno"> 1463</span>    table.<a class="code hl_function" href="classFormattedTable.html#a17854e65f279e180420146fa570ed36a">clear</a>();</div>
<div class="line"><a id="l01464" name="l01464"></a><span class="lineno"> 1464</span>    <span class="keywordflow">for</span> (<span class="keyword">auto</span> i : index_range(subds))</div>
<div class="line"><a id="l01465" name="l01465"></a><span class="lineno"> 1465</span>    {</div>
<div class="line"><a id="l01466" name="l01466"></a><span class="lineno"> 1466</span>      table.<a class="code hl_function" href="classFormattedTable.html#ad88c8d5f300a569a9bc4844223d39612">addRow</a>(i);</div>
<div class="line"><a id="l01467" name="l01467"></a><span class="lineno"> 1467</span>      table.<a class="code hl_function" href="classFormattedTable.html#aa3a67ad3a70d2ac160f76b605a415853">addData</a>&lt;std::string&gt;(col_names[0], subds[i]);</div>
<div class="line"><a id="l01468" name="l01468"></a><span class="lineno"> 1468</span>      table.<a class="code hl_function" href="classFormattedTable.html#aa3a67ad3a70d2ac160f76b605a415853">addData</a>&lt;<span class="keywordtype">size_t</span>&gt;(col_names[1], n_elems[i]);</div>
<div class="line"><a id="l01469" name="l01469"></a><span class="lineno"> 1469</span>      table.<a class="code hl_function" href="classFormattedTable.html#aa3a67ad3a70d2ac160f76b605a415853">addData</a>&lt;Real&gt;(col_names[2], maxs[i]);</div>
<div class="line"><a id="l01470" name="l01470"></a><span class="lineno"> 1470</span>      table.<a class="code hl_function" href="classFormattedTable.html#aa3a67ad3a70d2ac160f76b605a415853">addData</a>&lt;Real&gt;(col_names[3], mins[i]);</div>
<div class="line"><a id="l01471" name="l01471"></a><span class="lineno"> 1471</span>      table.<a class="code hl_function" href="classFormattedTable.html#aa3a67ad3a70d2ac160f76b605a415853">addData</a>&lt;Real&gt;(col_names[4], medians[i]);</div>
<div class="line"><a id="l01472" name="l01472"></a><span class="lineno"> 1472</span>    }</div>
<div class="line"><a id="l01473" name="l01473"></a><span class="lineno"> 1473</span> </div>
<div class="line"><a id="l01474" name="l01474"></a><span class="lineno"> 1474</span>    Moose::out &lt;&lt; <span class="stringliteral">&quot;secondary subdomain: &quot;</span> &lt;&lt; secondary_subd_id</div>
<div class="line"><a id="l01475" name="l01475"></a><span class="lineno"> 1475</span>               &lt;&lt; <span class="stringliteral">&quot; \tprimary subdomain: &quot;</span> &lt;&lt; primary_subd_id &lt;&lt; std::endl;</div>
<div class="line"><a id="l01476" name="l01476"></a><span class="lineno"> 1476</span>    table.<a class="code hl_function" href="classFormattedTable.html#a69a8eb1233d213541c3e74d5de3cd882">printTable</a>(Moose::out, subds.size());</div>
<div class="line"><a id="l01477" name="l01477"></a><span class="lineno"> 1477</span>  }</div>
<div class="line"><a id="l01478" name="l01478"></a><span class="lineno"> 1478</span>}</div>
<div class="line"><a id="l01479" name="l01479"></a><span class="lineno"> 1479</span> </div>
<div class="line"><a id="l01480" name="l01480"></a><span class="lineno"> 1480</span><span class="comment">// The blocks marked with **** are for regressing edge dropping treatment and should be removed</span></div>
<div class="line"><a id="l01481" name="l01481"></a><span class="lineno"> 1481</span><span class="comment">// eventually.</span></div>
<div class="line"><a id="l01482" name="l01482"></a><span class="lineno"> 1482</span><span class="comment">//****</span></div>
<div class="line"><a id="l01483" name="l01483"></a><span class="lineno"> 1483</span><span class="comment">// Compute inactve nodes when the old (incorrect) edge dropping treatemnt is enabled</span></div>
<div class="line"><a id="l01484" name="l01484"></a><span class="lineno"> 1484</span><span class="keywordtype">void</span></div>
<div class="line"><a id="l01485" name="l01485"></a><span class="lineno"><a class="line" href="classAutomaticMortarGeneration.html#ac36806c971038a5d13d2e5ea2c9e7f54"> 1485</a></span><a class="code hl_function" href="classAutomaticMortarGeneration.html#ac36806c971038a5d13d2e5ea2c9e7f54">AutomaticMortarGeneration::computeIncorrectEdgeDroppingInactiveLMNodes</a>()</div>
<div class="line"><a id="l01486" name="l01486"></a><span class="lineno"> 1486</span>{</div>
<div class="line"><a id="l01487" name="l01487"></a><span class="lineno"> 1487</span>  <span class="comment">// Note that in 3D our trick to check whether an element has edge dropping needs loose tolerances</span></div>
<div class="line"><a id="l01488" name="l01488"></a><span class="lineno"> 1488</span>  <span class="comment">// since the mortar segments are on the linearized element and comparing the volume of the</span></div>
<div class="line"><a id="l01489" name="l01489"></a><span class="lineno"> 1489</span>  <span class="comment">// linearized element does not have the same volume as the warped element</span></div>
<div class="line"><a id="l01490" name="l01490"></a><span class="lineno"> 1490</span>  <span class="keyword">const</span> Real tol = (<a class="code hl_function" href="classAutomaticMortarGeneration.html#ad0031e96df8f32e5c456a98532509404">dim</a>() == 3) ? 0.1 : TOLERANCE;</div>
<div class="line"><a id="l01491" name="l01491"></a><span class="lineno"> 1491</span> </div>
<div class="line"><a id="l01492" name="l01492"></a><span class="lineno"> 1492</span>  std::unordered_map&lt;processor_id_type, std::set&lt;dof_id_type&gt;&gt; proc_to_inactive_nodes_set;</div>
<div class="line"><a id="l01493" name="l01493"></a><span class="lineno"> 1493</span>  <span class="keyword">const</span> <span class="keyword">auto</span> my_pid = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.processor_id();</div>
<div class="line"><a id="l01494" name="l01494"></a><span class="lineno"> 1494</span> </div>
<div class="line"><a id="l01495" name="l01495"></a><span class="lineno"> 1495</span>  <span class="comment">// List of inactive nodes on local secondary elements</span></div>
<div class="line"><a id="l01496" name="l01496"></a><span class="lineno"> 1496</span>  std::unordered_set&lt;dof_id_type&gt; inactive_node_ids;</div>
<div class="line"><a id="l01497" name="l01497"></a><span class="lineno"> 1497</span> </div>
<div class="line"><a id="l01498" name="l01498"></a><span class="lineno"> 1498</span>  std::unordered_map&lt;const Elem *, Real&gt; active_volume{};</div>
<div class="line"><a id="l01499" name="l01499"></a><span class="lineno"> 1499</span> </div>
<div class="line"><a id="l01500" name="l01500"></a><span class="lineno"> 1500</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; pr : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a969d4ab038fc8d447e966cd1e1600091">_primary_secondary_subdomain_id_pairs</a>)</div>
<div class="line"><a id="l01501" name="l01501"></a><span class="lineno"> 1501</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> el : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.active_subdomain_elements_ptr_range(pr.second))</div>
<div class="line"><a id="l01502" name="l01502"></a><span class="lineno"> 1502</span>      active_volume[el] = 0.;</div>
<div class="line"><a id="l01503" name="l01503"></a><span class="lineno"> 1503</span> </div>
<div class="line"><a id="l01504" name="l01504"></a><span class="lineno"> 1504</span>  <span class="comment">// Compute fraction of elements with corresponding primary elements</span></div>
<div class="line"><a id="l01505" name="l01505"></a><span class="lineno"> 1505</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> msm_elem : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;active_local_element_ptr_range())</div>
<div class="line"><a id="l01506" name="l01506"></a><span class="lineno"> 1506</span>  {</div>
<div class="line"><a id="l01507" name="l01507"></a><span class="lineno"> 1507</span>    <span class="keyword">const</span> <a class="code hl_struct" href="structMortarSegmentInfo.html">MortarSegmentInfo</a> &amp; msinfo = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#abbd91d3cf8bef528976fe6f932622d2d">_msm_elem_to_info</a>.at(msm_elem);</div>
<div class="line"><a id="l01508" name="l01508"></a><span class="lineno"> 1508</span>    <span class="keyword">const</span> Elem * secondary_elem = msinfo.<a class="code hl_variable" href="structMortarSegmentInfo.html#afa8c2918a473f0dad90d5c68dad00eb4">secondary_elem</a>;</div>
<div class="line"><a id="l01509" name="l01509"></a><span class="lineno"> 1509</span> </div>
<div class="line"><a id="l01510" name="l01510"></a><span class="lineno"> 1510</span>    active_volume[secondary_elem] += msm_elem-&gt;volume();</div>
<div class="line"><a id="l01511" name="l01511"></a><span class="lineno"> 1511</span>  }</div>
<div class="line"><a id="l01512" name="l01512"></a><span class="lineno"> 1512</span> </div>
<div class="line"><a id="l01513" name="l01513"></a><span class="lineno"> 1513</span>  <span class="comment">// Mark all inactive local nodes</span></div>
<div class="line"><a id="l01514" name="l01514"></a><span class="lineno"> 1514</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; pr : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a969d4ab038fc8d447e966cd1e1600091">_primary_secondary_subdomain_id_pairs</a>)</div>
<div class="line"><a id="l01515" name="l01515"></a><span class="lineno"> 1515</span>    <span class="comment">// Loop through all elements on my processor</span></div>
<div class="line"><a id="l01516" name="l01516"></a><span class="lineno"> 1516</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> el : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.active_local_subdomain_elements_ptr_range(pr.second))</div>
<div class="line"><a id="l01517" name="l01517"></a><span class="lineno"> 1517</span>      <span class="comment">// If elem fully or partially dropped</span></div>
<div class="line"><a id="l01518" name="l01518"></a><span class="lineno"> 1518</span>      <span class="keywordflow">if</span> (std::abs(active_volume[el] / el-&gt;volume() - 1.0) &gt; tol)</div>
<div class="line"><a id="l01519" name="l01519"></a><span class="lineno"> 1519</span>      {</div>
<div class="line"><a id="l01520" name="l01520"></a><span class="lineno"> 1520</span>        <span class="comment">// Add all nodes to list of inactive</span></div>
<div class="line"><a id="l01521" name="l01521"></a><span class="lineno"> 1521</span>        <span class="keywordflow">for</span> (<span class="keyword">auto</span> n : make_range(el-&gt;n_nodes()))</div>
<div class="line"><a id="l01522" name="l01522"></a><span class="lineno"> 1522</span>          inactive_node_ids.insert(el-&gt;node_id(n));</div>
<div class="line"><a id="l01523" name="l01523"></a><span class="lineno"> 1523</span>      }</div>
<div class="line"><a id="l01524" name="l01524"></a><span class="lineno"> 1524</span> </div>
<div class="line"><a id="l01525" name="l01525"></a><span class="lineno"> 1525</span>  <span class="comment">// Assemble list of procs that nodes contribute to</span></div>
<div class="line"><a id="l01526" name="l01526"></a><span class="lineno"> 1526</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; pr : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a969d4ab038fc8d447e966cd1e1600091">_primary_secondary_subdomain_id_pairs</a>)</div>
<div class="line"><a id="l01527" name="l01527"></a><span class="lineno"> 1527</span>  {</div>
<div class="line"><a id="l01528" name="l01528"></a><span class="lineno"> 1528</span>    <span class="keyword">const</span> <span class="keyword">auto</span> secondary_subd_id = pr.second;</div>
<div class="line"><a id="l01529" name="l01529"></a><span class="lineno"> 1529</span> </div>
<div class="line"><a id="l01530" name="l01530"></a><span class="lineno"> 1530</span>    <span class="comment">// Loop through all elements not on my processor</span></div>
<div class="line"><a id="l01531" name="l01531"></a><span class="lineno"> 1531</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> el : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.active_subdomain_elements_ptr_range(secondary_subd_id))</div>
<div class="line"><a id="l01532" name="l01532"></a><span class="lineno"> 1532</span>    {</div>
<div class="line"><a id="l01533" name="l01533"></a><span class="lineno"> 1533</span>      <span class="comment">// Get processor_id</span></div>
<div class="line"><a id="l01534" name="l01534"></a><span class="lineno"> 1534</span>      <span class="keyword">const</span> <span class="keyword">auto</span> pid = el-&gt;processor_id();</div>
<div class="line"><a id="l01535" name="l01535"></a><span class="lineno"> 1535</span> </div>
<div class="line"><a id="l01536" name="l01536"></a><span class="lineno"> 1536</span>      <span class="comment">// If element is in my subdomain, skip</span></div>
<div class="line"><a id="l01537" name="l01537"></a><span class="lineno"> 1537</span>      <span class="keywordflow">if</span> (pid == my_pid)</div>
<div class="line"><a id="l01538" name="l01538"></a><span class="lineno"> 1538</span>        <span class="keywordflow">continue</span>;</div>
<div class="line"><a id="l01539" name="l01539"></a><span class="lineno"> 1539</span> </div>
<div class="line"><a id="l01540" name="l01540"></a><span class="lineno"> 1540</span>      <span class="comment">// If element on proc pid shares any of my inactive nodes, mark to send</span></div>
<div class="line"><a id="l01541" name="l01541"></a><span class="lineno"> 1541</span>      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> n : make_range(el-&gt;n_nodes()))</div>
<div class="line"><a id="l01542" name="l01542"></a><span class="lineno"> 1542</span>      {</div>
<div class="line"><a id="l01543" name="l01543"></a><span class="lineno"> 1543</span>        <span class="keyword">const</span> <span class="keyword">auto</span> node_id = el-&gt;node_id(n);</div>
<div class="line"><a id="l01544" name="l01544"></a><span class="lineno"> 1544</span>        <span class="keywordflow">if</span> (inactive_node_ids.find(node_id) != inactive_node_ids.end())</div>
<div class="line"><a id="l01545" name="l01545"></a><span class="lineno"> 1545</span>          proc_to_inactive_nodes_set[pid].insert(node_id);</div>
<div class="line"><a id="l01546" name="l01546"></a><span class="lineno"> 1546</span>      }</div>
<div class="line"><a id="l01547" name="l01547"></a><span class="lineno"> 1547</span>    }</div>
<div class="line"><a id="l01548" name="l01548"></a><span class="lineno"> 1548</span>  }</div>
<div class="line"><a id="l01549" name="l01549"></a><span class="lineno"> 1549</span> </div>
<div class="line"><a id="l01550" name="l01550"></a><span class="lineno"> 1550</span>  <span class="comment">// Send list of inactive nodes</span></div>
<div class="line"><a id="l01551" name="l01551"></a><span class="lineno"> 1551</span>  {</div>
<div class="line"><a id="l01552" name="l01552"></a><span class="lineno"> 1552</span>    <span class="comment">// Pack set into vector for sending (push_parallel_vector_data doesn&#39;t like sets)</span></div>
<div class="line"><a id="l01553" name="l01553"></a><span class="lineno"> 1553</span>    std::unordered_map&lt;processor_id_type, std::vector&lt;dof_id_type&gt;&gt; proc_to_inactive_nodes_vector;</div>
<div class="line"><a id="l01554" name="l01554"></a><span class="lineno"> 1554</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; proc_set : proc_to_inactive_nodes_set)</div>
<div class="line"><a id="l01555" name="l01555"></a><span class="lineno"> 1555</span>      proc_to_inactive_nodes_vector[proc_set.first].insert(</div>
<div class="line"><a id="l01556" name="l01556"></a><span class="lineno"> 1556</span>          proc_to_inactive_nodes_vector[proc_set.first].end(),</div>
<div class="line"><a id="l01557" name="l01557"></a><span class="lineno"> 1557</span>          proc_set.second.begin(),</div>
<div class="line"><a id="l01558" name="l01558"></a><span class="lineno"> 1558</span>          proc_set.second.end());</div>
<div class="line"><a id="l01559" name="l01559"></a><span class="lineno"> 1559</span> </div>
<div class="line"><a id="l01560" name="l01560"></a><span class="lineno"> 1560</span>    <span class="comment">// First push data</span></div>
<div class="line"><a id="l01561" name="l01561"></a><span class="lineno"> 1561</span>    <span class="keyword">auto</span> action_functor = [<span class="keyword">this</span>, &amp;inactive_node_ids](<span class="keyword">const</span> processor_id_type pid,</div>
<div class="line"><a id="l01562" name="l01562"></a><span class="lineno"> 1562</span>                                                     <span class="keyword">const</span> std::vector&lt;dof_id_type&gt; &amp; sent_data)</div>
<div class="line"><a id="l01563" name="l01563"></a><span class="lineno"> 1563</span>    {</div>
<div class="line"><a id="l01564" name="l01564"></a><span class="lineno"> 1564</span>      <span class="keywordflow">if</span> (pid == <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.processor_id())</div>
<div class="line"><a id="l01565" name="l01565"></a><span class="lineno"> 1565</span>        <a class="code hl_function" href="MooseError_8h.html#aa959168eed29caa7aaa85ffc1319a9ad">mooseError</a>(<span class="stringliteral">&quot;Should not be communicating with self.&quot;</span>);</div>
<div class="line"><a id="l01566" name="l01566"></a><span class="lineno"> 1566</span>      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> pr : sent_data)</div>
<div class="line"><a id="l01567" name="l01567"></a><span class="lineno"> 1567</span>        inactive_node_ids.insert(pr);</div>
<div class="line"><a id="l01568" name="l01568"></a><span class="lineno"> 1568</span>    };</div>
<div class="line"><a id="l01569" name="l01569"></a><span class="lineno"> 1569</span>    TIMPI::push_parallel_vector_data(<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.comm(), proc_to_inactive_nodes_vector, action_functor);</div>
<div class="line"><a id="l01570" name="l01570"></a><span class="lineno"> 1570</span>  }</div>
<div class="line"><a id="l01571" name="l01571"></a><span class="lineno"> 1571</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a3c757e0025c7dbfb78485e79067fb138">_inactive_local_lm_nodes</a>.clear();</div>
<div class="line"><a id="l01572" name="l01572"></a><span class="lineno"> 1572</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> node_id : inactive_node_ids)</div>
<div class="line"><a id="l01573" name="l01573"></a><span class="lineno"> 1573</span>    <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a3c757e0025c7dbfb78485e79067fb138">_inactive_local_lm_nodes</a>.insert(<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.node_ptr(node_id));</div>
<div class="line"><a id="l01574" name="l01574"></a><span class="lineno"> 1574</span>}</div>
<div class="line"><a id="l01575" name="l01575"></a><span class="lineno"> 1575</span> </div>
<div class="line"><a id="l01576" name="l01576"></a><span class="lineno"> 1576</span><span class="keywordtype">void</span></div>
<div class="line"><a id="l01577" name="l01577"></a><span class="lineno"><a class="line" href="classAutomaticMortarGeneration.html#af55157330468f97bbf6905ffbb92fbea"> 1577</a></span><a class="code hl_function" href="classAutomaticMortarGeneration.html#af55157330468f97bbf6905ffbb92fbea">AutomaticMortarGeneration::computeInactiveLMNodes</a>()</div>
<div class="line"><a id="l01578" name="l01578"></a><span class="lineno"> 1578</span>{</div>
<div class="line"><a id="l01579" name="l01579"></a><span class="lineno"> 1579</span>  <span class="keywordflow">if</span> (!<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a689b49e6bae35fa2ba975b844c4ec82e">_correct_edge_dropping</a>)</div>
<div class="line"><a id="l01580" name="l01580"></a><span class="lineno"> 1580</span>  {</div>
<div class="line"><a id="l01581" name="l01581"></a><span class="lineno"> 1581</span>    <a class="code hl_function" href="classAutomaticMortarGeneration.html#ac36806c971038a5d13d2e5ea2c9e7f54">computeIncorrectEdgeDroppingInactiveLMNodes</a>();</div>
<div class="line"><a id="l01582" name="l01582"></a><span class="lineno"> 1582</span>    <span class="keywordflow">return</span>;</div>
<div class="line"><a id="l01583" name="l01583"></a><span class="lineno"> 1583</span>  }</div>
<div class="line"><a id="l01584" name="l01584"></a><span class="lineno"> 1584</span> </div>
<div class="line"><a id="l01585" name="l01585"></a><span class="lineno"> 1585</span>  std::unordered_map&lt;processor_id_type, std::set&lt;dof_id_type&gt;&gt; proc_to_active_nodes_set;</div>
<div class="line"><a id="l01586" name="l01586"></a><span class="lineno"> 1586</span>  <span class="keyword">const</span> <span class="keyword">auto</span> my_pid = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.processor_id();</div>
<div class="line"><a id="l01587" name="l01587"></a><span class="lineno"> 1587</span> </div>
<div class="line"><a id="l01588" name="l01588"></a><span class="lineno"> 1588</span>  <span class="comment">// List of active nodes on local secondary elements</span></div>
<div class="line"><a id="l01589" name="l01589"></a><span class="lineno"> 1589</span>  std::unordered_set&lt;dof_id_type&gt; active_local_nodes;</div>
<div class="line"><a id="l01590" name="l01590"></a><span class="lineno"> 1590</span> </div>
<div class="line"><a id="l01591" name="l01591"></a><span class="lineno"> 1591</span>  <span class="comment">// Mark all active local nodes</span></div>
<div class="line"><a id="l01592" name="l01592"></a><span class="lineno"> 1592</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> msm_elem : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;active_local_element_ptr_range())</div>
<div class="line"><a id="l01593" name="l01593"></a><span class="lineno"> 1593</span>  {</div>
<div class="line"><a id="l01594" name="l01594"></a><span class="lineno"> 1594</span>    <span class="keyword">const</span> <a class="code hl_struct" href="structMortarSegmentInfo.html">MortarSegmentInfo</a> &amp; msinfo = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#abbd91d3cf8bef528976fe6f932622d2d">_msm_elem_to_info</a>.at(msm_elem);</div>
<div class="line"><a id="l01595" name="l01595"></a><span class="lineno"> 1595</span>    <span class="keyword">const</span> Elem * secondary_elem = msinfo.<a class="code hl_variable" href="structMortarSegmentInfo.html#afa8c2918a473f0dad90d5c68dad00eb4">secondary_elem</a>;</div>
<div class="line"><a id="l01596" name="l01596"></a><span class="lineno"> 1596</span> </div>
<div class="line"><a id="l01597" name="l01597"></a><span class="lineno"> 1597</span>    <span class="keywordflow">for</span> (<span class="keyword">auto</span> n : make_range(secondary_elem-&gt;n_nodes()))</div>
<div class="line"><a id="l01598" name="l01598"></a><span class="lineno"> 1598</span>      active_local_nodes.insert(secondary_elem-&gt;node_id(n));</div>
<div class="line"><a id="l01599" name="l01599"></a><span class="lineno"> 1599</span>  }</div>
<div class="line"><a id="l01600" name="l01600"></a><span class="lineno"> 1600</span> </div>
<div class="line"><a id="l01601" name="l01601"></a><span class="lineno"> 1601</span>  <span class="comment">// Assemble list of procs that nodes contribute to</span></div>
<div class="line"><a id="l01602" name="l01602"></a><span class="lineno"> 1602</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; pr : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a969d4ab038fc8d447e966cd1e1600091">_primary_secondary_subdomain_id_pairs</a>)</div>
<div class="line"><a id="l01603" name="l01603"></a><span class="lineno"> 1603</span>  {</div>
<div class="line"><a id="l01604" name="l01604"></a><span class="lineno"> 1604</span>    <span class="keyword">const</span> <span class="keyword">auto</span> secondary_subd_id = pr.second;</div>
<div class="line"><a id="l01605" name="l01605"></a><span class="lineno"> 1605</span> </div>
<div class="line"><a id="l01606" name="l01606"></a><span class="lineno"> 1606</span>    <span class="comment">// Loop through all elements not on my processor</span></div>
<div class="line"><a id="l01607" name="l01607"></a><span class="lineno"> 1607</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> el : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.active_subdomain_elements_ptr_range(secondary_subd_id))</div>
<div class="line"><a id="l01608" name="l01608"></a><span class="lineno"> 1608</span>    {</div>
<div class="line"><a id="l01609" name="l01609"></a><span class="lineno"> 1609</span>      <span class="comment">// Get processor_id</span></div>
<div class="line"><a id="l01610" name="l01610"></a><span class="lineno"> 1610</span>      <span class="keyword">const</span> <span class="keyword">auto</span> pid = el-&gt;processor_id();</div>
<div class="line"><a id="l01611" name="l01611"></a><span class="lineno"> 1611</span> </div>
<div class="line"><a id="l01612" name="l01612"></a><span class="lineno"> 1612</span>      <span class="comment">// If element is in my subdomain, skip</span></div>
<div class="line"><a id="l01613" name="l01613"></a><span class="lineno"> 1613</span>      <span class="keywordflow">if</span> (pid == my_pid)</div>
<div class="line"><a id="l01614" name="l01614"></a><span class="lineno"> 1614</span>        <span class="keywordflow">continue</span>;</div>
<div class="line"><a id="l01615" name="l01615"></a><span class="lineno"> 1615</span> </div>
<div class="line"><a id="l01616" name="l01616"></a><span class="lineno"> 1616</span>      <span class="comment">// If element on proc pid shares any of my active nodes, mark to send</span></div>
<div class="line"><a id="l01617" name="l01617"></a><span class="lineno"> 1617</span>      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> n : make_range(el-&gt;n_nodes()))</div>
<div class="line"><a id="l01618" name="l01618"></a><span class="lineno"> 1618</span>      {</div>
<div class="line"><a id="l01619" name="l01619"></a><span class="lineno"> 1619</span>        <span class="keyword">const</span> <span class="keyword">auto</span> node_id = el-&gt;node_id(n);</div>
<div class="line"><a id="l01620" name="l01620"></a><span class="lineno"> 1620</span>        <span class="keywordflow">if</span> (active_local_nodes.find(node_id) != active_local_nodes.end())</div>
<div class="line"><a id="l01621" name="l01621"></a><span class="lineno"> 1621</span>          proc_to_active_nodes_set[pid].insert(node_id);</div>
<div class="line"><a id="l01622" name="l01622"></a><span class="lineno"> 1622</span>      }</div>
<div class="line"><a id="l01623" name="l01623"></a><span class="lineno"> 1623</span>    }</div>
<div class="line"><a id="l01624" name="l01624"></a><span class="lineno"> 1624</span>  }</div>
<div class="line"><a id="l01625" name="l01625"></a><span class="lineno"> 1625</span> </div>
<div class="line"><a id="l01626" name="l01626"></a><span class="lineno"> 1626</span>  <span class="comment">// Send list of active nodes</span></div>
<div class="line"><a id="l01627" name="l01627"></a><span class="lineno"> 1627</span>  {</div>
<div class="line"><a id="l01628" name="l01628"></a><span class="lineno"> 1628</span>    <span class="comment">// Pack set into vector for sending (push_parallel_vector_data doesn&#39;t like sets)</span></div>
<div class="line"><a id="l01629" name="l01629"></a><span class="lineno"> 1629</span>    std::unordered_map&lt;processor_id_type, std::vector&lt;dof_id_type&gt;&gt; proc_to_active_nodes_vector;</div>
<div class="line"><a id="l01630" name="l01630"></a><span class="lineno"> 1630</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; proc_set : proc_to_active_nodes_set)</div>
<div class="line"><a id="l01631" name="l01631"></a><span class="lineno"> 1631</span>    {</div>
<div class="line"><a id="l01632" name="l01632"></a><span class="lineno"> 1632</span>      proc_to_active_nodes_vector[proc_set.first].reserve(proc_to_active_nodes_set.size());</div>
<div class="line"><a id="l01633" name="l01633"></a><span class="lineno"> 1633</span>      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> node_id : proc_set.second)</div>
<div class="line"><a id="l01634" name="l01634"></a><span class="lineno"> 1634</span>        proc_to_active_nodes_vector[proc_set.first].push_back(node_id);</div>
<div class="line"><a id="l01635" name="l01635"></a><span class="lineno"> 1635</span>    }</div>
<div class="line"><a id="l01636" name="l01636"></a><span class="lineno"> 1636</span> </div>
<div class="line"><a id="l01637" name="l01637"></a><span class="lineno"> 1637</span>    <span class="comment">// First push data</span></div>
<div class="line"><a id="l01638" name="l01638"></a><span class="lineno"> 1638</span>    <span class="keyword">auto</span> action_functor = [<span class="keyword">this</span>, &amp;active_local_nodes](<span class="keyword">const</span> processor_id_type pid,</div>
<div class="line"><a id="l01639" name="l01639"></a><span class="lineno"> 1639</span>                                                      <span class="keyword">const</span> std::vector&lt;dof_id_type&gt; &amp; sent_data)</div>
<div class="line"><a id="l01640" name="l01640"></a><span class="lineno"> 1640</span>    {</div>
<div class="line"><a id="l01641" name="l01641"></a><span class="lineno"> 1641</span>      <span class="keywordflow">if</span> (pid == <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.processor_id())</div>
<div class="line"><a id="l01642" name="l01642"></a><span class="lineno"> 1642</span>        <a class="code hl_function" href="MooseError_8h.html#aa959168eed29caa7aaa85ffc1319a9ad">mooseError</a>(<span class="stringliteral">&quot;Should not be communicating with self.&quot;</span>);</div>
<div class="line"><a id="l01643" name="l01643"></a><span class="lineno"> 1643</span>      active_local_nodes.insert(sent_data.begin(), sent_data.end());</div>
<div class="line"><a id="l01644" name="l01644"></a><span class="lineno"> 1644</span>    };</div>
<div class="line"><a id="l01645" name="l01645"></a><span class="lineno"> 1645</span>    TIMPI::push_parallel_vector_data(<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.comm(), proc_to_active_nodes_vector, action_functor);</div>
<div class="line"><a id="l01646" name="l01646"></a><span class="lineno"> 1646</span>  }</div>
<div class="line"><a id="l01647" name="l01647"></a><span class="lineno"> 1647</span> </div>
<div class="line"><a id="l01648" name="l01648"></a><span class="lineno"> 1648</span>  <span class="comment">// Every proc has correct list of active local nodes, now take complement (list of inactive nodes)</span></div>
<div class="line"><a id="l01649" name="l01649"></a><span class="lineno"> 1649</span>  <span class="comment">// and store to use later to zero LM DoFs on inactive nodes</span></div>
<div class="line"><a id="l01650" name="l01650"></a><span class="lineno"> 1650</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a3c757e0025c7dbfb78485e79067fb138">_inactive_local_lm_nodes</a>.clear();</div>
<div class="line"><a id="l01651" name="l01651"></a><span class="lineno"> 1651</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; pr : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a969d4ab038fc8d447e966cd1e1600091">_primary_secondary_subdomain_id_pairs</a>)</div>
<div class="line"><a id="l01652" name="l01652"></a><span class="lineno"> 1652</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> el : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.active_local_subdomain_elements_ptr_range(</div>
<div class="line"><a id="l01653" name="l01653"></a><span class="lineno"> 1653</span>             <span class="comment">/*secondary_subd_id*/</span> pr.second))</div>
<div class="line"><a id="l01654" name="l01654"></a><span class="lineno"> 1654</span>      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> n : make_range(el-&gt;n_nodes()))</div>
<div class="line"><a id="l01655" name="l01655"></a><span class="lineno"> 1655</span>        <span class="keywordflow">if</span> (active_local_nodes.find(el-&gt;node_id(n)) == active_local_nodes.end())</div>
<div class="line"><a id="l01656" name="l01656"></a><span class="lineno"> 1656</span>          <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a3c757e0025c7dbfb78485e79067fb138">_inactive_local_lm_nodes</a>.insert(el-&gt;node_ptr(n));</div>
<div class="line"><a id="l01657" name="l01657"></a><span class="lineno"> 1657</span>}</div>
<div class="line"><a id="l01658" name="l01658"></a><span class="lineno"> 1658</span> </div>
<div class="line"><a id="l01659" name="l01659"></a><span class="lineno"> 1659</span><span class="comment">// Note: could be combined with previous routine, keeping separate for clarity (for now)</span></div>
<div class="line"><a id="l01660" name="l01660"></a><span class="lineno"> 1660</span><span class="keywordtype">void</span></div>
<div class="line"><a id="l01661" name="l01661"></a><span class="lineno"><a class="line" href="classAutomaticMortarGeneration.html#a545496202789a72da1ffc639dedf322a"> 1661</a></span><a class="code hl_function" href="classAutomaticMortarGeneration.html#a545496202789a72da1ffc639dedf322a">AutomaticMortarGeneration::computeInactiveLMElems</a>()</div>
<div class="line"><a id="l01662" name="l01662"></a><span class="lineno"> 1662</span>{</div>
<div class="line"><a id="l01663" name="l01663"></a><span class="lineno"> 1663</span>  <span class="comment">// Mark all active secondary elements</span></div>
<div class="line"><a id="l01664" name="l01664"></a><span class="lineno"> 1664</span>  std::unordered_set&lt;const Elem *&gt; active_local_elems;</div>
<div class="line"><a id="l01665" name="l01665"></a><span class="lineno"> 1665</span> </div>
<div class="line"><a id="l01666" name="l01666"></a><span class="lineno"> 1666</span>  <span class="comment">//****</span></div>
<div class="line"><a id="l01667" name="l01667"></a><span class="lineno"> 1667</span>  <span class="comment">// Note that in 3D our trick to check whether an element has edge dropping needs loose tolerances</span></div>
<div class="line"><a id="l01668" name="l01668"></a><span class="lineno"> 1668</span>  <span class="comment">// since the mortar segments are on the linearized element and comparing the volume of the</span></div>
<div class="line"><a id="l01669" name="l01669"></a><span class="lineno"> 1669</span>  <span class="comment">// linearized element does not have the same volume as the warped element</span></div>
<div class="line"><a id="l01670" name="l01670"></a><span class="lineno"> 1670</span>  <span class="keyword">const</span> Real tol = (<a class="code hl_function" href="classAutomaticMortarGeneration.html#ad0031e96df8f32e5c456a98532509404">dim</a>() == 3) ? 0.1 : TOLERANCE;</div>
<div class="line"><a id="l01671" name="l01671"></a><span class="lineno"> 1671</span> </div>
<div class="line"><a id="l01672" name="l01672"></a><span class="lineno"> 1672</span>  std::unordered_map&lt;const Elem *, Real&gt; active_volume;</div>
<div class="line"><a id="l01673" name="l01673"></a><span class="lineno"> 1673</span> </div>
<div class="line"><a id="l01674" name="l01674"></a><span class="lineno"> 1674</span>  <span class="comment">// Compute fraction of elements with corresponding primary elements</span></div>
<div class="line"><a id="l01675" name="l01675"></a><span class="lineno"> 1675</span>  <span class="keywordflow">if</span> (!<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a689b49e6bae35fa2ba975b844c4ec82e">_correct_edge_dropping</a>)</div>
<div class="line"><a id="l01676" name="l01676"></a><span class="lineno"> 1676</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> msm_elem : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;active_local_element_ptr_range())</div>
<div class="line"><a id="l01677" name="l01677"></a><span class="lineno"> 1677</span>    {</div>
<div class="line"><a id="l01678" name="l01678"></a><span class="lineno"> 1678</span>      <span class="keyword">const</span> <a class="code hl_struct" href="structMortarSegmentInfo.html">MortarSegmentInfo</a> &amp; msinfo = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#abbd91d3cf8bef528976fe6f932622d2d">_msm_elem_to_info</a>.at(msm_elem);</div>
<div class="line"><a id="l01679" name="l01679"></a><span class="lineno"> 1679</span>      <span class="keyword">const</span> Elem * secondary_elem = msinfo.<a class="code hl_variable" href="structMortarSegmentInfo.html#afa8c2918a473f0dad90d5c68dad00eb4">secondary_elem</a>;</div>
<div class="line"><a id="l01680" name="l01680"></a><span class="lineno"> 1680</span> </div>
<div class="line"><a id="l01681" name="l01681"></a><span class="lineno"> 1681</span>      active_volume[secondary_elem] += msm_elem-&gt;volume();</div>
<div class="line"><a id="l01682" name="l01682"></a><span class="lineno"> 1682</span>    }</div>
<div class="line"><a id="l01683" name="l01683"></a><span class="lineno"> 1683</span>  <span class="comment">//****</span></div>
<div class="line"><a id="l01684" name="l01684"></a><span class="lineno"> 1684</span> </div>
<div class="line"><a id="l01685" name="l01685"></a><span class="lineno"> 1685</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> msm_elem : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">_mortar_segment_mesh</a>-&gt;active_local_element_ptr_range())</div>
<div class="line"><a id="l01686" name="l01686"></a><span class="lineno"> 1686</span>  {</div>
<div class="line"><a id="l01687" name="l01687"></a><span class="lineno"> 1687</span>    <span class="keyword">const</span> <a class="code hl_struct" href="structMortarSegmentInfo.html">MortarSegmentInfo</a> &amp; msinfo = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#abbd91d3cf8bef528976fe6f932622d2d">_msm_elem_to_info</a>.at(msm_elem);</div>
<div class="line"><a id="l01688" name="l01688"></a><span class="lineno"> 1688</span>    <span class="keyword">const</span> Elem * secondary_elem = msinfo.<a class="code hl_variable" href="structMortarSegmentInfo.html#afa8c2918a473f0dad90d5c68dad00eb4">secondary_elem</a>;</div>
<div class="line"><a id="l01689" name="l01689"></a><span class="lineno"> 1689</span> </div>
<div class="line"><a id="l01690" name="l01690"></a><span class="lineno"> 1690</span>    <span class="comment">//****</span></div>
<div class="line"><a id="l01691" name="l01691"></a><span class="lineno"> 1691</span>    <span class="keywordflow">if</span> (!<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a689b49e6bae35fa2ba975b844c4ec82e">_correct_edge_dropping</a>)</div>
<div class="line"><a id="l01692" name="l01692"></a><span class="lineno"> 1692</span>      <span class="keywordflow">if</span> (std::abs(active_volume[secondary_elem] / secondary_elem-&gt;volume() - 1.0) &gt; tol)</div>
<div class="line"><a id="l01693" name="l01693"></a><span class="lineno"> 1693</span>        <span class="keywordflow">continue</span>;</div>
<div class="line"><a id="l01694" name="l01694"></a><span class="lineno"> 1694</span>    <span class="comment">//****</span></div>
<div class="line"><a id="l01695" name="l01695"></a><span class="lineno"> 1695</span> </div>
<div class="line"><a id="l01696" name="l01696"></a><span class="lineno"> 1696</span>    active_local_elems.insert(secondary_elem);</div>
<div class="line"><a id="l01697" name="l01697"></a><span class="lineno"> 1697</span>  }</div>
<div class="line"><a id="l01698" name="l01698"></a><span class="lineno"> 1698</span> </div>
<div class="line"><a id="l01699" name="l01699"></a><span class="lineno"> 1699</span>  <span class="comment">// Take complement of active elements in active local subdomain to get inactive local elements</span></div>
<div class="line"><a id="l01700" name="l01700"></a><span class="lineno"> 1700</span>  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#ac3445ab0b94ce0dc9c01a1234321ebaa">_inactive_local_lm_elems</a>.clear();</div>
<div class="line"><a id="l01701" name="l01701"></a><span class="lineno"> 1701</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; pr : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a969d4ab038fc8d447e966cd1e1600091">_primary_secondary_subdomain_id_pairs</a>)</div>
<div class="line"><a id="l01702" name="l01702"></a><span class="lineno"> 1702</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> el : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.active_local_subdomain_elements_ptr_range(</div>
<div class="line"><a id="l01703" name="l01703"></a><span class="lineno"> 1703</span>             <span class="comment">/*secondary_subd_id*/</span> pr.second))</div>
<div class="line"><a id="l01704" name="l01704"></a><span class="lineno"> 1704</span>      <span class="keywordflow">if</span> (active_local_elems.find(el) == active_local_elems.end())</div>
<div class="line"><a id="l01705" name="l01705"></a><span class="lineno"> 1705</span>        <a class="code hl_variable" href="classAutomaticMortarGeneration.html#ac3445ab0b94ce0dc9c01a1234321ebaa">_inactive_local_lm_elems</a>.insert(el);</div>
<div class="line"><a id="l01706" name="l01706"></a><span class="lineno"> 1706</span>}</div>
<div class="line"><a id="l01707" name="l01707"></a><span class="lineno"> 1707</span> </div>
<div class="line"><a id="l01708" name="l01708"></a><span class="lineno"> 1708</span><span class="keywordtype">void</span></div>
<div class="line"><a id="l01709" name="l01709"></a><span class="lineno"><a class="line" href="classAutomaticMortarGeneration.html#a2d9c7320cc6d9a995eaee8bd021397b7"> 1709</a></span><a class="code hl_function" href="classAutomaticMortarGeneration.html#a2d9c7320cc6d9a995eaee8bd021397b7">AutomaticMortarGeneration::computeNodalGeometry</a>()</div>
<div class="line"><a id="l01710" name="l01710"></a><span class="lineno"> 1710</span>{</div>
<div class="line"><a id="l01711" name="l01711"></a><span class="lineno"> 1711</span>  <span class="comment">// The dimension according to Mesh::mesh_dimension().</span></div>
<div class="line"><a id="l01712" name="l01712"></a><span class="lineno"> 1712</span>  <span class="keyword">const</span> <span class="keyword">auto</span> <a class="code hl_function" href="classAutomaticMortarGeneration.html#ad0031e96df8f32e5c456a98532509404">dim</a> = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.mesh_dimension();</div>
<div class="line"><a id="l01713" name="l01713"></a><span class="lineno"> 1713</span> </div>
<div class="line"><a id="l01714" name="l01714"></a><span class="lineno"> 1714</span>  <span class="comment">// A nodal lower-dimensional nodal quadrature rule to be used on faces.</span></div>
<div class="line"><a id="l01715" name="l01715"></a><span class="lineno"> 1715</span>  QNodal qface(<a class="code hl_function" href="classAutomaticMortarGeneration.html#ad0031e96df8f32e5c456a98532509404">dim</a> - 1);</div>
<div class="line"><a id="l01716" name="l01716"></a><span class="lineno"> 1716</span> </div>
<div class="line"><a id="l01717" name="l01717"></a><span class="lineno"> 1717</span>  <span class="comment">// A map from the node id to the attached elemental normals/weights evaluated at the node. Th</span></div>
<div class="line"><a id="l01718" name="l01718"></a><span class="lineno"> 1718</span>  <span class="comment">// length of the vector will correspond to the number of elements attached to the node. If it is a</span></div>
<div class="line"><a id="l01719" name="l01719"></a><span class="lineno"> 1719</span>  <span class="comment">// vertex node, for a 1D mortar mesh, the vector length will be two. If it is an interior node,</span></div>
<div class="line"><a id="l01720" name="l01720"></a><span class="lineno"> 1720</span>  <span class="comment">// the vector will be length 1. The first member of the pair is that element&#39;s normal at the node.</span></div>
<div class="line"><a id="l01721" name="l01721"></a><span class="lineno"> 1721</span>  <span class="comment">// The second member is that element&#39;s JxW at the node</span></div>
<div class="line"><a id="l01722" name="l01722"></a><span class="lineno"> 1722</span>  std::map&lt;dof_id_type, std::vector&lt;std::pair&lt;Point, Real&gt;&gt;&gt; node_to_normals_map;</div>
<div class="line"><a id="l01723" name="l01723"></a><span class="lineno"> 1723</span> </div>
<div class="line"><a id="l01725" name="l01725"></a><span class="lineno"> 1725</span>  Real sign = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a509e5164f1c4cd0f981eaa901c37c632">_periodic</a> ? -1 : 1;</div>
<div class="line"><a id="l01726" name="l01726"></a><span class="lineno"> 1726</span> </div>
<div class="line"><a id="l01727" name="l01727"></a><span class="lineno"> 1727</span>  <span class="comment">// First loop over lower-dimensional secondary side elements and compute/save the outward normal</span></div>
<div class="line"><a id="l01728" name="l01728"></a><span class="lineno"> 1728</span>  <span class="comment">// for each one. We loop over all active elements currently, but this procedure could be</span></div>
<div class="line"><a id="l01729" name="l01729"></a><span class="lineno"> 1729</span>  <span class="comment">// parallelized as well.</span></div>
<div class="line"><a id="l01730" name="l01730"></a><span class="lineno"> 1730</span>  <span class="keywordflow">for</span> (MeshBase::const_element_iterator el = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.active_elements_begin(),</div>
<div class="line"><a id="l01731" name="l01731"></a><span class="lineno"> 1731</span>                                        end_el = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.active_elements_end();</div>
<div class="line"><a id="l01732" name="l01732"></a><span class="lineno"> 1732</span>       el != end_el;</div>
<div class="line"><a id="l01733" name="l01733"></a><span class="lineno"> 1733</span>       ++el)</div>
<div class="line"><a id="l01734" name="l01734"></a><span class="lineno"> 1734</span>  {</div>
<div class="line"><a id="l01735" name="l01735"></a><span class="lineno"> 1735</span>    <span class="keyword">const</span> Elem * secondary_elem = *el;</div>
<div class="line"><a id="l01736" name="l01736"></a><span class="lineno"> 1736</span> </div>
<div class="line"><a id="l01737" name="l01737"></a><span class="lineno"> 1737</span>    <span class="comment">// If this is not one of the lower-dimensional secondary side elements, go on to the next one.</span></div>
<div class="line"><a id="l01738" name="l01738"></a><span class="lineno"> 1738</span>    <span class="keywordflow">if</span> (!<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a59c6fd297125023195e7bfb3714846c5">_secondary_boundary_subdomain_ids</a>.count(secondary_elem-&gt;subdomain_id()))</div>
<div class="line"><a id="l01739" name="l01739"></a><span class="lineno"> 1739</span>      <span class="keywordflow">continue</span>;</div>
<div class="line"><a id="l01740" name="l01740"></a><span class="lineno"> 1740</span> </div>
<div class="line"><a id="l01741" name="l01741"></a><span class="lineno"> 1741</span>    <span class="comment">// We will create an FE object and attach the nodal quadrature rule such that we can get out the</span></div>
<div class="line"><a id="l01742" name="l01742"></a><span class="lineno"> 1742</span>    <span class="comment">// normals at the element nodes</span></div>
<div class="line"><a id="l01743" name="l01743"></a><span class="lineno"> 1743</span>    FEType nnx_fe_type(secondary_elem-&gt;default_order(), LAGRANGE);</div>
<div class="line"><a id="l01744" name="l01744"></a><span class="lineno"> 1744</span>    std::unique_ptr&lt;FEBase&gt; nnx_fe_face(FEBase::build(<a class="code hl_function" href="classAutomaticMortarGeneration.html#ad0031e96df8f32e5c456a98532509404">dim</a>, nnx_fe_type));</div>
<div class="line"><a id="l01745" name="l01745"></a><span class="lineno"> 1745</span>    nnx_fe_face-&gt;attach_quadrature_rule(&amp;qface);</div>
<div class="line"><a id="l01746" name="l01746"></a><span class="lineno"> 1746</span>    <span class="keyword">const</span> std::vector&lt;Point&gt; &amp; face_normals = nnx_fe_face-&gt;get_normals();</div>
<div class="line"><a id="l01747" name="l01747"></a><span class="lineno"> 1747</span> </div>
<div class="line"><a id="l01748" name="l01748"></a><span class="lineno"> 1748</span>    <span class="keyword">const</span> <span class="keyword">auto</span> &amp; JxW = nnx_fe_face-&gt;get_JxW();</div>
<div class="line"><a id="l01749" name="l01749"></a><span class="lineno"> 1749</span> </div>
<div class="line"><a id="l01750" name="l01750"></a><span class="lineno"> 1750</span>    <span class="comment">// Which side of the parent are we? We need to know this to know</span></div>
<div class="line"><a id="l01751" name="l01751"></a><span class="lineno"> 1751</span>    <span class="comment">// which side to reinit.</span></div>
<div class="line"><a id="l01752" name="l01752"></a><span class="lineno"> 1752</span>    <span class="keyword">const</span> Elem * interior_parent = secondary_elem-&gt;interior_parent();</div>
<div class="line"><a id="l01753" name="l01753"></a><span class="lineno"> 1753</span>    mooseAssert(interior_parent,</div>
<div class="line"><a id="l01754" name="l01754"></a><span class="lineno"> 1754</span>                <span class="stringliteral">&quot;No interior parent exists for element &quot;</span></div>
<div class="line"><a id="l01755" name="l01755"></a><span class="lineno"> 1755</span>                    &lt;&lt; secondary_elem-&gt;id()</div>
<div class="line"><a id="l01756" name="l01756"></a><span class="lineno"> 1756</span>                    &lt;&lt; <span class="stringliteral">&quot;. There may be a problem with your sideset set-up.&quot;</span>);</div>
<div class="line"><a id="l01757" name="l01757"></a><span class="lineno"> 1757</span> </div>
<div class="line"><a id="l01758" name="l01758"></a><span class="lineno"> 1758</span>    <span class="comment">// Map to get lower dimensional element from interior parent on secondary surface</span></div>
<div class="line"><a id="l01759" name="l01759"></a><span class="lineno"> 1759</span>    <span class="comment">// This map can be used to provide a handle to methods in this class that need to</span></div>
<div class="line"><a id="l01760" name="l01760"></a><span class="lineno"> 1760</span>    <span class="comment">// operate on lower dimensional elements.</span></div>
<div class="line"><a id="l01761" name="l01761"></a><span class="lineno"> 1761</span>    <a class="code hl_variable" href="classAutomaticMortarGeneration.html#acb676f79ae207404fb5d224ac768df42">_secondary_element_to_secondary_lowerd_element</a>.emplace(interior_parent-&gt;id(), secondary_elem);</div>
<div class="line"><a id="l01762" name="l01762"></a><span class="lineno"> 1762</span> </div>
<div class="line"><a id="l01763" name="l01763"></a><span class="lineno"> 1763</span>    <span class="comment">// Look up which side of the interior parent secondary_elem is.</span></div>
<div class="line"><a id="l01764" name="l01764"></a><span class="lineno"> 1764</span>    <span class="keyword">auto</span> s = interior_parent-&gt;which_side_am_i(secondary_elem);</div>
<div class="line"><a id="l01765" name="l01765"></a><span class="lineno"> 1765</span> </div>
<div class="line"><a id="l01766" name="l01766"></a><span class="lineno"> 1766</span>    <span class="comment">// Reinit the face FE object on side s.</span></div>
<div class="line"><a id="l01767" name="l01767"></a><span class="lineno"> 1767</span>    nnx_fe_face-&gt;reinit(interior_parent, s);</div>
<div class="line"><a id="l01768" name="l01768"></a><span class="lineno"> 1768</span> </div>
<div class="line"><a id="l01769" name="l01769"></a><span class="lineno"> 1769</span>    <span class="keywordflow">for</span> (MooseIndex(secondary_elem-&gt;n_nodes()) n = 0; n &lt; secondary_elem-&gt;n_nodes(); ++n)</div>
<div class="line"><a id="l01770" name="l01770"></a><span class="lineno"> 1770</span>    {</div>
<div class="line"><a id="l01771" name="l01771"></a><span class="lineno"> 1771</span>      <span class="keyword">auto</span> &amp; normals_and_weights_vec = node_to_normals_map[secondary_elem-&gt;node_id(n)];</div>
<div class="line"><a id="l01772" name="l01772"></a><span class="lineno"> 1772</span>      normals_and_weights_vec.push_back(std::make_pair(sign * face_normals[n], JxW[n]));</div>
<div class="line"><a id="l01773" name="l01773"></a><span class="lineno"> 1773</span>    }</div>
<div class="line"><a id="l01774" name="l01774"></a><span class="lineno"> 1774</span>  }</div>
<div class="line"><a id="l01775" name="l01775"></a><span class="lineno"> 1775</span> </div>
<div class="line"><a id="l01776" name="l01776"></a><span class="lineno"> 1776</span>  <span class="comment">// Note that contrary to the Bin Yang dissertation, we are not weighting by the face element</span></div>
<div class="line"><a id="l01777" name="l01777"></a><span class="lineno"> 1777</span>  <span class="comment">// lengths/volumes. It&#39;s not clear to me that this type of weighting is a good algorithm for cases</span></div>
<div class="line"><a id="l01778" name="l01778"></a><span class="lineno"> 1778</span>  <span class="comment">// where the face can be curved</span></div>
<div class="line"><a id="l01779" name="l01779"></a><span class="lineno"> 1779</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; pr : node_to_normals_map)</div>
<div class="line"><a id="l01780" name="l01780"></a><span class="lineno"> 1780</span>  {</div>
<div class="line"><a id="l01781" name="l01781"></a><span class="lineno"> 1781</span>    <span class="comment">// Compute normal vector</span></div>
<div class="line"><a id="l01782" name="l01782"></a><span class="lineno"> 1782</span>    <span class="keyword">const</span> <span class="keyword">auto</span> &amp; node_id = pr.first;</div>
<div class="line"><a id="l01783" name="l01783"></a><span class="lineno"> 1783</span>    <span class="keyword">const</span> <span class="keyword">auto</span> &amp; normals_and_weights_vec = pr.second;</div>
<div class="line"><a id="l01784" name="l01784"></a><span class="lineno"> 1784</span> </div>
<div class="line"><a id="l01785" name="l01785"></a><span class="lineno"> 1785</span>    Point nodal_normal;</div>
<div class="line"><a id="l01786" name="l01786"></a><span class="lineno"> 1786</span>    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; norm_and_weight : normals_and_weights_vec)</div>
<div class="line"><a id="l01787" name="l01787"></a><span class="lineno"> 1787</span>      nodal_normal += norm_and_weight.first * norm_and_weight.second;</div>
<div class="line"><a id="l01788" name="l01788"></a><span class="lineno"> 1788</span>    nodal_normal = nodal_normal.unit();</div>
<div class="line"><a id="l01789" name="l01789"></a><span class="lineno"> 1789</span> </div>
<div class="line"><a id="l01790" name="l01790"></a><span class="lineno"> 1790</span>    <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a06fb539aea2e63f3b48a6e1d41a2f568">_secondary_node_to_nodal_normal</a>[<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.node_ptr(node_id)] = nodal_normal;</div>
<div class="line"><a id="l01791" name="l01791"></a><span class="lineno"> 1791</span> </div>
<div class="line"><a id="l01792" name="l01792"></a><span class="lineno"> 1792</span>    Point nodal_tangent_one;</div>
<div class="line"><a id="l01793" name="l01793"></a><span class="lineno"> 1793</span>    Point nodal_tangent_two;</div>
<div class="line"><a id="l01794" name="l01794"></a><span class="lineno"> 1794</span>    <a class="code hl_function" href="classAutomaticMortarGeneration.html#a71119b033756571f4345f912300b182d">householderOrthogolization</a>(nodal_normal, nodal_tangent_one, nodal_tangent_two);</div>
<div class="line"><a id="l01795" name="l01795"></a><span class="lineno"> 1795</span> </div>
<div class="line"><a id="l01796" name="l01796"></a><span class="lineno"> 1796</span>    <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a8120c89f18fdff39621fa512087a2da3">_secondary_node_to_hh_nodal_tangents</a>[<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.node_ptr(node_id)][0] = nodal_tangent_one;</div>
<div class="line"><a id="l01797" name="l01797"></a><span class="lineno"> 1797</span>    <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a8120c89f18fdff39621fa512087a2da3">_secondary_node_to_hh_nodal_tangents</a>[<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.node_ptr(node_id)][1] = nodal_tangent_two;</div>
<div class="line"><a id="l01798" name="l01798"></a><span class="lineno"> 1798</span>  }</div>
<div class="line"><a id="l01799" name="l01799"></a><span class="lineno"> 1799</span>}</div>
<div class="line"><a id="l01800" name="l01800"></a><span class="lineno"> 1800</span> </div>
<div class="line"><a id="l01801" name="l01801"></a><span class="lineno"> 1801</span><span class="keywordtype">void</span></div>
<div class="line"><a id="l01802" name="l01802"></a><span class="lineno"><a class="line" href="classAutomaticMortarGeneration.html#a71119b033756571f4345f912300b182d"> 1802</a></span><a class="code hl_function" href="classAutomaticMortarGeneration.html#a71119b033756571f4345f912300b182d">AutomaticMortarGeneration::householderOrthogolization</a>(<span class="keyword">const</span> Point &amp; nodal_normal,</div>
<div class="line"><a id="l01803" name="l01803"></a><span class="lineno"> 1803</span>                                                      Point &amp; nodal_tangent_one,</div>
<div class="line"><a id="l01804" name="l01804"></a><span class="lineno"> 1804</span>                                                      Point &amp; nodal_tangent_two)<span class="keyword"> const</span></div>
<div class="line"><a id="l01805" name="l01805"></a><span class="lineno"> 1805</span><span class="keyword"></span>{</div>
<div class="line"><a id="l01806" name="l01806"></a><span class="lineno"> 1806</span>  mooseAssert(<a class="code hl_function" href="namespaceMooseUtils.html#ad9865895ce5bb2c18722efa26d5c7693">MooseUtils::absoluteFuzzyEqual</a>(nodal_normal.norm(), 1),</div>
<div class="line"><a id="l01807" name="l01807"></a><span class="lineno"> 1807</span>              <span class="stringliteral">&quot;The input nodal normal should have unity norm&quot;</span>);</div>
<div class="line"><a id="l01808" name="l01808"></a><span class="lineno"> 1808</span> </div>
<div class="line"><a id="l01809" name="l01809"></a><span class="lineno"> 1809</span>  <span class="keyword">const</span> Real nx = nodal_normal(0);</div>
<div class="line"><a id="l01810" name="l01810"></a><span class="lineno"> 1810</span>  <span class="keyword">const</span> Real ny = nodal_normal(1);</div>
<div class="line"><a id="l01811" name="l01811"></a><span class="lineno"> 1811</span>  <span class="keyword">const</span> Real nz = nodal_normal(2);</div>
<div class="line"><a id="l01812" name="l01812"></a><span class="lineno"> 1812</span> </div>
<div class="line"><a id="l01813" name="l01813"></a><span class="lineno"> 1813</span>  <span class="comment">// See Lopes DS, Silva MT, Ambrosio JA. Tangent vectors to a 3-D surface normal: A geometric tool</span></div>
<div class="line"><a id="l01814" name="l01814"></a><span class="lineno"> 1814</span>  <span class="comment">// to find orthogonal vectors based on the Householder transformation. Computer-Aided Design. 2013</span></div>
<div class="line"><a id="l01815" name="l01815"></a><span class="lineno"> 1815</span>  <span class="comment">// Mar 1;45(3):683-94. We choose one definition of h_vector and deal with special case.</span></div>
<div class="line"><a id="l01816" name="l01816"></a><span class="lineno"> 1816</span>  <span class="keyword">const</span> Point h_vector(nx + 1.0, ny, nz);</div>
<div class="line"><a id="l01817" name="l01817"></a><span class="lineno"> 1817</span> </div>
<div class="line"><a id="l01818" name="l01818"></a><span class="lineno"> 1818</span>  <span class="comment">// Avoid singularity of the equations at the end of routine by providing the solution to</span></div>
<div class="line"><a id="l01819" name="l01819"></a><span class="lineno"> 1819</span>  <span class="comment">// (nx,ny,nz)=(-1,0,0) Normal/tangent fields can be visualized by outputting nodal geometry mesh</span></div>
<div class="line"><a id="l01820" name="l01820"></a><span class="lineno"> 1820</span>  <span class="comment">// on a spherical problem.</span></div>
<div class="line"><a id="l01821" name="l01821"></a><span class="lineno"> 1821</span>  <span class="keywordflow">if</span> (std::abs(h_vector(0)) &lt; TOLERANCE)</div>
<div class="line"><a id="l01822" name="l01822"></a><span class="lineno"> 1822</span>  {</div>
<div class="line"><a id="l01823" name="l01823"></a><span class="lineno"> 1823</span>    nodal_tangent_one(0) = 0;</div>
<div class="line"><a id="l01824" name="l01824"></a><span class="lineno"> 1824</span>    nodal_tangent_one(1) = 1;</div>
<div class="line"><a id="l01825" name="l01825"></a><span class="lineno"> 1825</span>    nodal_tangent_one(2) = 0;</div>
<div class="line"><a id="l01826" name="l01826"></a><span class="lineno"> 1826</span> </div>
<div class="line"><a id="l01827" name="l01827"></a><span class="lineno"> 1827</span>    nodal_tangent_two(0) = 0;</div>
<div class="line"><a id="l01828" name="l01828"></a><span class="lineno"> 1828</span>    nodal_tangent_two(1) = 0;</div>
<div class="line"><a id="l01829" name="l01829"></a><span class="lineno"> 1829</span>    nodal_tangent_two(2) = -1;</div>
<div class="line"><a id="l01830" name="l01830"></a><span class="lineno"> 1830</span> </div>
<div class="line"><a id="l01831" name="l01831"></a><span class="lineno"> 1831</span>    <span class="keywordflow">return</span>;</div>
<div class="line"><a id="l01832" name="l01832"></a><span class="lineno"> 1832</span>  }</div>
<div class="line"><a id="l01833" name="l01833"></a><span class="lineno"> 1833</span> </div>
<div class="line"><a id="l01834" name="l01834"></a><span class="lineno"> 1834</span>  <span class="keyword">const</span> Real h = h_vector.norm();</div>
<div class="line"><a id="l01835" name="l01835"></a><span class="lineno"> 1835</span> </div>
<div class="line"><a id="l01836" name="l01836"></a><span class="lineno"> 1836</span>  nodal_tangent_one(0) = -2.0 * h_vector(0) * h_vector(1) / (h * h);</div>
<div class="line"><a id="l01837" name="l01837"></a><span class="lineno"> 1837</span>  nodal_tangent_one(1) = 1.0 - 2.0 * h_vector(1) * h_vector(1) / (h * h);</div>
<div class="line"><a id="l01838" name="l01838"></a><span class="lineno"> 1838</span>  nodal_tangent_one(2) = -2.0 * h_vector(1) * h_vector(2) / (h * h);</div>
<div class="line"><a id="l01839" name="l01839"></a><span class="lineno"> 1839</span> </div>
<div class="line"><a id="l01840" name="l01840"></a><span class="lineno"> 1840</span>  nodal_tangent_two(0) = -2.0 * h_vector(0) * h_vector(2) / (h * h);</div>
<div class="line"><a id="l01841" name="l01841"></a><span class="lineno"> 1841</span>  nodal_tangent_two(1) = -2.0 * h_vector(1) * h_vector(2) / (h * h);</div>
<div class="line"><a id="l01842" name="l01842"></a><span class="lineno"> 1842</span>  nodal_tangent_two(2) = 1.0 - 2.0 * h_vector(2) * h_vector(2) / (h * h);</div>
<div class="line"><a id="l01843" name="l01843"></a><span class="lineno"> 1843</span>}</div>
<div class="line"><a id="l01844" name="l01844"></a><span class="lineno"> 1844</span> </div>
<div class="line"><a id="l01845" name="l01845"></a><span class="lineno"> 1845</span><span class="comment">// Project secondary nodes onto their corresponding primary elements for each primary/secondary</span></div>
<div class="line"><a id="l01846" name="l01846"></a><span class="lineno"> 1846</span><span class="comment">// pair.</span></div>
<div class="line"><a id="l01847" name="l01847"></a><span class="lineno"> 1847</span><span class="keywordtype">void</span></div>
<div class="line"><a id="l01848" name="l01848"></a><span class="lineno"><a class="line" href="classAutomaticMortarGeneration.html#a51ac6050a6f320045d286c92bffba156"> 1848</a></span><a class="code hl_function" href="classAutomaticMortarGeneration.html#a51ac6050a6f320045d286c92bffba156">AutomaticMortarGeneration::projectSecondaryNodes</a>()</div>
<div class="line"><a id="l01849" name="l01849"></a><span class="lineno"> 1849</span>{</div>
<div class="line"><a id="l01850" name="l01850"></a><span class="lineno"> 1850</span>  <span class="comment">// For each primary/secondary boundary id pair, call the</span></div>
<div class="line"><a id="l01851" name="l01851"></a><span class="lineno"> 1851</span>  <span class="comment">// project_secondary_nodes_single_pair() helper function.</span></div>
<div class="line"><a id="l01852" name="l01852"></a><span class="lineno"> 1852</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; pr : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a969d4ab038fc8d447e966cd1e1600091">_primary_secondary_subdomain_id_pairs</a>)</div>
<div class="line"><a id="l01853" name="l01853"></a><span class="lineno"> 1853</span>    <a class="code hl_function" href="classAutomaticMortarGeneration.html#a8aa99d7524d7b1ae972fe152fd0dc61e">projectSecondaryNodesSinglePair</a>(pr.first, pr.second);</div>
<div class="line"><a id="l01854" name="l01854"></a><span class="lineno"> 1854</span>}</div>
<div class="line"><a id="l01855" name="l01855"></a><span class="lineno"> 1855</span> </div>
<div class="line"><a id="l01856" name="l01856"></a><span class="lineno"> 1856</span><span class="keywordtype">void</span></div>
<div class="line"><a id="l01857" name="l01857"></a><span class="lineno"><a class="line" href="classAutomaticMortarGeneration.html#a8aa99d7524d7b1ae972fe152fd0dc61e"> 1857</a></span><a class="code hl_function" href="classAutomaticMortarGeneration.html#a8aa99d7524d7b1ae972fe152fd0dc61e">AutomaticMortarGeneration::projectSecondaryNodesSinglePair</a>(</div>
<div class="line"><a id="l01858" name="l01858"></a><span class="lineno"> 1858</span>    <a class="code hl_typedef" href="AutomaticMortarGeneration_8h.html#afb1ef82fea6170b578d48ad9cd793486">SubdomainID</a> lower_dimensional_primary_subdomain_id,</div>
<div class="line"><a id="l01859" name="l01859"></a><span class="lineno"> 1859</span>    <a class="code hl_typedef" href="AutomaticMortarGeneration_8h.html#afb1ef82fea6170b578d48ad9cd793486">SubdomainID</a> lower_dimensional_secondary_subdomain_id)</div>
<div class="line"><a id="l01860" name="l01860"></a><span class="lineno"> 1860</span>{</div>
<div class="line"><a id="l01861" name="l01861"></a><span class="lineno"> 1861</span>  <span class="comment">// Build the &quot;subdomain&quot; adaptor based KD Tree.</span></div>
<div class="line"><a id="l01862" name="l01862"></a><span class="lineno"> 1862</span>  <a class="code hl_class" href="classNanoflannMeshSubdomainAdaptor.html">NanoflannMeshSubdomainAdaptor&lt;3&gt;</a> mesh_adaptor(<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>, lower_dimensional_primary_subdomain_id);</div>
<div class="line"><a id="l01863" name="l01863"></a><span class="lineno"> 1863</span>  <a class="code hl_typedef" href="NanoflannMeshAdaptor_8h.html#a3a70df33047194961ce21a0133717038">subdomain_kd_tree_t</a> kd_tree(</div>
<div class="line"><a id="l01864" name="l01864"></a><span class="lineno"> 1864</span>      3, mesh_adaptor, nanoflann::KDTreeSingleIndexAdaptorParams(<span class="comment">/*max leaf=*/</span>10));</div>
<div class="line"><a id="l01865" name="l01865"></a><span class="lineno"> 1865</span> </div>
<div class="line"><a id="l01866" name="l01866"></a><span class="lineno"> 1866</span>  <span class="comment">// Construct the KD tree.</span></div>
<div class="line"><a id="l01867" name="l01867"></a><span class="lineno"> 1867</span>  kd_tree.buildIndex();</div>
<div class="line"><a id="l01868" name="l01868"></a><span class="lineno"> 1868</span> </div>
<div class="line"><a id="l01869" name="l01869"></a><span class="lineno"> 1869</span>  <span class="keywordflow">for</span> (MeshBase::const_element_iterator el = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.active_elements_begin(),</div>
<div class="line"><a id="l01870" name="l01870"></a><span class="lineno"> 1870</span>                                        end_el = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.active_elements_end();</div>
<div class="line"><a id="l01871" name="l01871"></a><span class="lineno"> 1871</span>       el != end_el;</div>
<div class="line"><a id="l01872" name="l01872"></a><span class="lineno"> 1872</span>       ++el)</div>
<div class="line"><a id="l01873" name="l01873"></a><span class="lineno"> 1873</span>  {</div>
<div class="line"><a id="l01874" name="l01874"></a><span class="lineno"> 1874</span>    <span class="keyword">const</span> Elem * secondary_side_elem = *el;</div>
<div class="line"><a id="l01875" name="l01875"></a><span class="lineno"> 1875</span> </div>
<div class="line"><a id="l01876" name="l01876"></a><span class="lineno"> 1876</span>    <span class="comment">// If this Elem is not in the current secondary subdomain, go on to the next one.</span></div>
<div class="line"><a id="l01877" name="l01877"></a><span class="lineno"> 1877</span>    <span class="keywordflow">if</span> (secondary_side_elem-&gt;subdomain_id() != lower_dimensional_secondary_subdomain_id)</div>
<div class="line"><a id="l01878" name="l01878"></a><span class="lineno"> 1878</span>      <span class="keywordflow">continue</span>;</div>
<div class="line"><a id="l01879" name="l01879"></a><span class="lineno"> 1879</span> </div>
<div class="line"><a id="l01880" name="l01880"></a><span class="lineno"> 1880</span>    <span class="comment">// For each node on the lower-dimensional element, find the nearest</span></div>
<div class="line"><a id="l01881" name="l01881"></a><span class="lineno"> 1881</span>    <span class="comment">// node on the primary side using the KDTree, then</span></div>
<div class="line"><a id="l01882" name="l01882"></a><span class="lineno"> 1882</span>    <span class="comment">// search in nearby elements for where it projects</span></div>
<div class="line"><a id="l01883" name="l01883"></a><span class="lineno"> 1883</span>    <span class="comment">// along the nodal normal direction.</span></div>
<div class="line"><a id="l01884" name="l01884"></a><span class="lineno"> 1884</span>    <span class="keywordflow">for</span> (MooseIndex(secondary_side_elem-&gt;n_vertices()) n = 0; n &lt; secondary_side_elem-&gt;n_vertices();</div>
<div class="line"><a id="l01885" name="l01885"></a><span class="lineno"> 1885</span>         ++n)</div>
<div class="line"><a id="l01886" name="l01886"></a><span class="lineno"> 1886</span>    {</div>
<div class="line"><a id="l01887" name="l01887"></a><span class="lineno"> 1887</span>      <span class="keyword">const</span> Node * secondary_node = secondary_side_elem-&gt;node_ptr(n);</div>
<div class="line"><a id="l01888" name="l01888"></a><span class="lineno"> 1888</span> </div>
<div class="line"><a id="l01889" name="l01889"></a><span class="lineno"> 1889</span>      <span class="comment">// Get the nodal neighbors for secondary_node, so we can check whether we&#39;ve</span></div>
<div class="line"><a id="l01890" name="l01890"></a><span class="lineno"> 1890</span>      <span class="comment">// already successfully projected it.</span></div>
<div class="line"><a id="l01891" name="l01891"></a><span class="lineno"> 1891</span>      <span class="keyword">const</span> std::vector&lt;const Elem *&gt; &amp; secondary_node_neighbors =</div>
<div class="line"><a id="l01892" name="l01892"></a><span class="lineno"> 1892</span>          this-&gt;<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a1ad443aa196d2c81d195b29ddeee1d5e">_nodes_to_secondary_elem_map</a>.at(secondary_node-&gt;id());</div>
<div class="line"><a id="l01893" name="l01893"></a><span class="lineno"> 1893</span> </div>
<div class="line"><a id="l01894" name="l01894"></a><span class="lineno"> 1894</span>      <span class="comment">// Check whether we&#39;ve already mapped this secondary node</span></div>
<div class="line"><a id="l01895" name="l01895"></a><span class="lineno"> 1895</span>      <span class="comment">// successfully for all of its nodal neighbors.</span></div>
<div class="line"><a id="l01896" name="l01896"></a><span class="lineno"> 1896</span>      <span class="keywordtype">bool</span> is_mapped = <span class="keyword">true</span>;</div>
<div class="line"><a id="l01897" name="l01897"></a><span class="lineno"> 1897</span>      <span class="keywordflow">for</span> (MooseIndex(secondary_node_neighbors) snn = 0; snn &lt; secondary_node_neighbors.size();</div>
<div class="line"><a id="l01898" name="l01898"></a><span class="lineno"> 1898</span>           ++snn)</div>
<div class="line"><a id="l01899" name="l01899"></a><span class="lineno"> 1899</span>      {</div>
<div class="line"><a id="l01900" name="l01900"></a><span class="lineno"> 1900</span>        <span class="keyword">auto</span> secondary_key = std::make_pair(secondary_node, secondary_node_neighbors[snn]);</div>
<div class="line"><a id="l01901" name="l01901"></a><span class="lineno"> 1901</span>        <span class="keywordflow">if</span> (!<a class="code hl_variable" href="classAutomaticMortarGeneration.html#abb4cc3e3102675e52675a95347ad8e95">_secondary_node_and_elem_to_xi2_primary_elem</a>.count(secondary_key))</div>
<div class="line"><a id="l01902" name="l01902"></a><span class="lineno"> 1902</span>        {</div>
<div class="line"><a id="l01903" name="l01903"></a><span class="lineno"> 1903</span>          is_mapped = <span class="keyword">false</span>;</div>
<div class="line"><a id="l01904" name="l01904"></a><span class="lineno"> 1904</span>          <span class="keywordflow">break</span>;</div>
<div class="line"><a id="l01905" name="l01905"></a><span class="lineno"> 1905</span>        }</div>
<div class="line"><a id="l01906" name="l01906"></a><span class="lineno"> 1906</span>      }</div>
<div class="line"><a id="l01907" name="l01907"></a><span class="lineno"> 1907</span> </div>
<div class="line"><a id="l01908" name="l01908"></a><span class="lineno"> 1908</span>      <span class="comment">// Go to the next node if this one has already been mapped.</span></div>
<div class="line"><a id="l01909" name="l01909"></a><span class="lineno"> 1909</span>      <span class="keywordflow">if</span> (is_mapped)</div>
<div class="line"><a id="l01910" name="l01910"></a><span class="lineno"> 1910</span>        <span class="keywordflow">continue</span>;</div>
<div class="line"><a id="l01911" name="l01911"></a><span class="lineno"> 1911</span> </div>
<div class="line"><a id="l01912" name="l01912"></a><span class="lineno"> 1912</span>      <span class="comment">// Look up the new nodal normal value in the local storage, error if not found.</span></div>
<div class="line"><a id="l01913" name="l01913"></a><span class="lineno"> 1913</span>      Point nodal_normal = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a06fb539aea2e63f3b48a6e1d41a2f568">_secondary_node_to_nodal_normal</a>.at(secondary_node);</div>
<div class="line"><a id="l01914" name="l01914"></a><span class="lineno"> 1914</span> </div>
<div class="line"><a id="l01915" name="l01915"></a><span class="lineno"> 1915</span>      <span class="comment">// Data structure for performing Nanoflann searches.</span></div>
<div class="line"><a id="l01916" name="l01916"></a><span class="lineno"> 1916</span>      std::array&lt;Real, 3&gt; query_pt = {</div>
<div class="line"><a id="l01917" name="l01917"></a><span class="lineno"> 1917</span>          {(*secondary_node)(0), (*secondary_node)(1), (*secondary_node)(2)}};</div>
<div class="line"><a id="l01918" name="l01918"></a><span class="lineno"> 1918</span> </div>
<div class="line"><a id="l01919" name="l01919"></a><span class="lineno"> 1919</span>      <span class="comment">// The number of results we want to get.  We&#39;ll look for a</span></div>
<div class="line"><a id="l01920" name="l01920"></a><span class="lineno"> 1920</span>      <span class="comment">// &quot;few&quot; nearest nodes, hopefully that is enough to let us</span></div>
<div class="line"><a id="l01921" name="l01921"></a><span class="lineno"> 1921</span>      <span class="comment">// figure out which lower-dimensional Elem on the primary</span></div>
<div class="line"><a id="l01922" name="l01922"></a><span class="lineno"> 1922</span>      <span class="comment">// side we are across from.</span></div>
<div class="line"><a id="l01923" name="l01923"></a><span class="lineno"> 1923</span>      <span class="keyword">const</span> std::size_t num_results = 3;</div>
<div class="line"><a id="l01924" name="l01924"></a><span class="lineno"> 1924</span> </div>
<div class="line"><a id="l01925" name="l01925"></a><span class="lineno"> 1925</span>      <span class="comment">// Initialize result_set and do the search.</span></div>
<div class="line"><a id="l01926" name="l01926"></a><span class="lineno"> 1926</span>      std::vector&lt;size_t&gt; ret_index(num_results);</div>
<div class="line"><a id="l01927" name="l01927"></a><span class="lineno"> 1927</span>      std::vector&lt;Real&gt; out_dist_sqr(num_results);</div>
<div class="line"><a id="l01928" name="l01928"></a><span class="lineno"> 1928</span>      nanoflann::KNNResultSet&lt;Real&gt; result_set(num_results);</div>
<div class="line"><a id="l01929" name="l01929"></a><span class="lineno"> 1929</span>      result_set.init(&amp;ret_index[0], &amp;out_dist_sqr[0]);</div>
<div class="line"><a id="l01930" name="l01930"></a><span class="lineno"> 1930</span>      kd_tree.findNeighbors(result_set, &amp;query_pt[0], <a class="code hl_typedef" href="namespacenanoflann.html#a7475277cf1d06434e352ade6f35de645">nanoflann::SearchParameters</a>());</div>
<div class="line"><a id="l01931" name="l01931"></a><span class="lineno"> 1931</span> </div>
<div class="line"><a id="l01932" name="l01932"></a><span class="lineno"> 1932</span>      <span class="comment">// If this flag gets set in the loop below, we can break out of the outer r-loop as well.</span></div>
<div class="line"><a id="l01933" name="l01933"></a><span class="lineno"> 1933</span>      <span class="keywordtype">bool</span> projection_succeeded = <span class="keyword">false</span>;</div>
<div class="line"><a id="l01934" name="l01934"></a><span class="lineno"> 1934</span> </div>
<div class="line"><a id="l01935" name="l01935"></a><span class="lineno"> 1935</span>      <span class="comment">// Once we&#39;ve rejected a candidate for a given secondary_node,</span></div>
<div class="line"><a id="l01936" name="l01936"></a><span class="lineno"> 1936</span>      <span class="comment">// there&#39;s no reason to check it again.</span></div>
<div class="line"><a id="l01937" name="l01937"></a><span class="lineno"> 1937</span>      std::set&lt;const Elem *&gt; rejected_primary_elem_candidates;</div>
<div class="line"><a id="l01938" name="l01938"></a><span class="lineno"> 1938</span> </div>
<div class="line"><a id="l01939" name="l01939"></a><span class="lineno"> 1939</span>      <span class="comment">// Loop over the closest nodes, check whether</span></div>
<div class="line"><a id="l01940" name="l01940"></a><span class="lineno"> 1940</span>      <span class="comment">// the secondary node successfully projects into</span></div>
<div class="line"><a id="l01941" name="l01941"></a><span class="lineno"> 1941</span>      <span class="comment">// either of the closest neighbors, stop when</span></div>
<div class="line"><a id="l01942" name="l01942"></a><span class="lineno"> 1942</span>      <span class="comment">// the projection succeeds.</span></div>
<div class="line"><a id="l01943" name="l01943"></a><span class="lineno"> 1943</span>      <span class="keywordflow">for</span> (MooseIndex(result_set) r = 0; r &lt; result_set.size(); ++r)</div>
<div class="line"><a id="l01944" name="l01944"></a><span class="lineno"> 1944</span>      {</div>
<div class="line"><a id="l01945" name="l01945"></a><span class="lineno"> 1945</span>        <span class="comment">// Verify that the squared distance we compute is the same as nanoflann&#39;sFss</span></div>
<div class="line"><a id="l01946" name="l01946"></a><span class="lineno"> 1946</span>        mooseAssert(std::abs((<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.point(ret_index[r]) - *secondary_node).norm_sq() -</div>
<div class="line"><a id="l01947" name="l01947"></a><span class="lineno"> 1947</span>                             out_dist_sqr[r]) &lt;= TOLERANCE,</div>
<div class="line"><a id="l01948" name="l01948"></a><span class="lineno"> 1948</span>                    <span class="stringliteral">&quot;Lower-dimensional element squared distance verification failed.&quot;</span>);</div>
<div class="line"><a id="l01949" name="l01949"></a><span class="lineno"> 1949</span> </div>
<div class="line"><a id="l01950" name="l01950"></a><span class="lineno"> 1950</span>        <span class="comment">// Get a reference to the vector of lower dimensional elements from the</span></div>
<div class="line"><a id="l01951" name="l01951"></a><span class="lineno"> 1951</span>        <span class="comment">// nodes_to_primary_elem_map.</span></div>
<div class="line"><a id="l01952" name="l01952"></a><span class="lineno"> 1952</span>        std::vector&lt;const Elem *&gt; &amp; primary_elem_candidates =</div>
<div class="line"><a id="l01953" name="l01953"></a><span class="lineno"> 1953</span>            this-&gt;<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a1ee9b6e4f8bd88603e22117085758f70">_nodes_to_primary_elem_map</a>.at(<span class="keyword">static_cast&lt;</span>dof_id_type<span class="keyword">&gt;</span>(ret_index[r]));</div>
<div class="line"><a id="l01954" name="l01954"></a><span class="lineno"> 1954</span> </div>
<div class="line"><a id="l01955" name="l01955"></a><span class="lineno"> 1955</span>        <span class="comment">// Search the Elems connected to this node on the primary mesh side.</span></div>
<div class="line"><a id="l01956" name="l01956"></a><span class="lineno"> 1956</span>        <span class="keywordflow">for</span> (MooseIndex(primary_elem_candidates) e = 0; e &lt; primary_elem_candidates.size(); ++e)</div>
<div class="line"><a id="l01957" name="l01957"></a><span class="lineno"> 1957</span>        {</div>
<div class="line"><a id="l01958" name="l01958"></a><span class="lineno"> 1958</span>          <span class="keyword">const</span> Elem * primary_elem_candidate = primary_elem_candidates[e];</div>
<div class="line"><a id="l01959" name="l01959"></a><span class="lineno"> 1959</span> </div>
<div class="line"><a id="l01960" name="l01960"></a><span class="lineno"> 1960</span>          <span class="comment">// If we&#39;ve already rejected this candidate, we don&#39;t need to check it again.</span></div>
<div class="line"><a id="l01961" name="l01961"></a><span class="lineno"> 1961</span>          <span class="keywordflow">if</span> (rejected_primary_elem_candidates.count(primary_elem_candidate))</div>
<div class="line"><a id="l01962" name="l01962"></a><span class="lineno"> 1962</span>            <span class="keywordflow">continue</span>;</div>
<div class="line"><a id="l01963" name="l01963"></a><span class="lineno"> 1963</span> </div>
<div class="line"><a id="l01964" name="l01964"></a><span class="lineno"> 1964</span>          <span class="comment">// Now generically solve for xi2</span></div>
<div class="line"><a id="l01965" name="l01965"></a><span class="lineno"> 1965</span>          <span class="keyword">auto</span> &amp;&amp; order = primary_elem_candidate-&gt;default_order();</div>
<div class="line"><a id="l01966" name="l01966"></a><span class="lineno"> 1966</span>          <a class="code hl_class" href="classMetaPhysicL_1_1DualNumber.html">DualNumber&lt;Real&gt;</a> xi2_dn{0, 1};</div>
<div class="line"><a id="l01967" name="l01967"></a><span class="lineno"> 1967</span>          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> current_iterate = 0, max_iterates = 10;</div>
<div class="line"><a id="l01968" name="l01968"></a><span class="lineno"> 1968</span> </div>
<div class="line"><a id="l01969" name="l01969"></a><span class="lineno"> 1969</span>          <span class="comment">// Newton loop</span></div>
<div class="line"><a id="l01970" name="l01970"></a><span class="lineno"> 1970</span>          <span class="keywordflow">do</span></div>
<div class="line"><a id="l01971" name="l01971"></a><span class="lineno"> 1971</span>          {</div>
<div class="line"><a id="l01972" name="l01972"></a><span class="lineno"> 1972</span>            <a class="code hl_class" href="classlibMesh_1_1VectorValue.html">VectorValue&lt;DualNumber&lt;Real&gt;</a>&gt; x2(0);</div>
<div class="line"><a id="l01973" name="l01973"></a><span class="lineno"> 1973</span>            <span class="keywordflow">for</span> (MooseIndex(primary_elem_candidate-&gt;n_nodes()) n = 0;</div>
<div class="line"><a id="l01974" name="l01974"></a><span class="lineno"> 1974</span>                 n &lt; primary_elem_candidate-&gt;n_nodes();</div>
<div class="line"><a id="l01975" name="l01975"></a><span class="lineno"> 1975</span>                 ++n)</div>
<div class="line"><a id="l01976" name="l01976"></a><span class="lineno"> 1976</span>              x2 +=</div>
<div class="line"><a id="l01977" name="l01977"></a><span class="lineno"> 1977</span>                  <a class="code hl_function" href="namespaceMoose.html#a9ed3373b5072c07f1f010afb75ac20c9">Moose::fe_lagrange_1D_shape</a>(order, n, xi2_dn) * primary_elem_candidate-&gt;point(n);</div>
<div class="line"><a id="l01978" name="l01978"></a><span class="lineno"> 1978</span>            <span class="keyword">const</span> <span class="keyword">auto</span> u = x2 - (*secondary_node);</div>
<div class="line"><a id="l01979" name="l01979"></a><span class="lineno"> 1979</span>            <span class="keyword">const</span> <span class="keyword">auto</span> F = u(0) * nodal_normal(1) - u(1) * nodal_normal(0);</div>
<div class="line"><a id="l01980" name="l01980"></a><span class="lineno"> 1980</span> </div>
<div class="line"><a id="l01981" name="l01981"></a><span class="lineno"> 1981</span>            <span class="keywordflow">if</span> (std::abs(F) &lt; <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a04e775677691747d25e1a5f05496fa5a">_newton_tolerance</a>)</div>
<div class="line"><a id="l01982" name="l01982"></a><span class="lineno"> 1982</span>              <span class="keywordflow">break</span>;</div>
<div class="line"><a id="l01983" name="l01983"></a><span class="lineno"> 1983</span> </div>
<div class="line"><a id="l01984" name="l01984"></a><span class="lineno"> 1984</span>            <span class="keywordflow">if</span> (F.derivatives())</div>
<div class="line"><a id="l01985" name="l01985"></a><span class="lineno"> 1985</span>            {</div>
<div class="line"><a id="l01986" name="l01986"></a><span class="lineno"> 1986</span>              Real dxi2 = -F.value() / F.derivatives();</div>
<div class="line"><a id="l01987" name="l01987"></a><span class="lineno"> 1987</span> </div>
<div class="line"><a id="l01988" name="l01988"></a><span class="lineno"> 1988</span>              xi2_dn += dxi2;</div>
<div class="line"><a id="l01989" name="l01989"></a><span class="lineno"> 1989</span>            }</div>
<div class="line"><a id="l01990" name="l01990"></a><span class="lineno"> 1990</span>            <span class="keywordflow">else</span></div>
<div class="line"><a id="l01991" name="l01991"></a><span class="lineno"> 1991</span>              <span class="comment">// It&#39;s possible that the secondary surface nodal normal is completely orthogonal to</span></div>
<div class="line"><a id="l01992" name="l01992"></a><span class="lineno"> 1992</span>              <span class="comment">// the primary surface normal, in which case the derivative is 0. We know in this case</span></div>
<div class="line"><a id="l01993" name="l01993"></a><span class="lineno"> 1993</span>              <span class="comment">// that the projection should be a failure</span></div>
<div class="line"><a id="l01994" name="l01994"></a><span class="lineno"> 1994</span>              current_iterate = max_iterates;</div>
<div class="line"><a id="l01995" name="l01995"></a><span class="lineno"> 1995</span>          } <span class="keywordflow">while</span> (++current_iterate &lt; max_iterates);</div>
<div class="line"><a id="l01996" name="l01996"></a><span class="lineno"> 1996</span> </div>
<div class="line"><a id="l01997" name="l01997"></a><span class="lineno"> 1997</span>          Real xi2 = xi2_dn.value();</div>
<div class="line"><a id="l01998" name="l01998"></a><span class="lineno"> 1998</span> </div>
<div class="line"><a id="l01999" name="l01999"></a><span class="lineno"> 1999</span>          <span class="comment">// Check whether the projection worked. The last condition checks for obliqueness of the</span></div>
<div class="line"><a id="l02000" name="l02000"></a><span class="lineno"> 2000</span>          <span class="comment">// projection</span></div>
<div class="line"><a id="l02001" name="l02001"></a><span class="lineno"> 2001</span>          <span class="keywordflow">if</span> ((current_iterate &lt; max_iterates) &amp;&amp; (std::abs(xi2) &lt;= 1. + <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a25f6f147b1b0a4b00e7c6739dd17b98c">_xi_tolerance</a>) &amp;&amp;</div>
<div class="line"><a id="l02002" name="l02002"></a><span class="lineno"> 2002</span>              (std::abs(</div>
<div class="line"><a id="l02003" name="l02003"></a><span class="lineno"> 2003</span>                   (primary_elem_candidate-&gt;point(0) - primary_elem_candidate-&gt;point(1)).unit() *</div>
<div class="line"><a id="l02004" name="l02004"></a><span class="lineno"> 2004</span>                   nodal_normal) &lt; std::cos(<a class="code hl_variable" href="classAutomaticMortarGeneration.html#af5ca257dd4090b3a8d801a439dcae0ca">_minimum_projection_angle</a> * libMesh::pi / 180)))</div>
<div class="line"><a id="l02005" name="l02005"></a><span class="lineno"> 2005</span>          {</div>
<div class="line"><a id="l02006" name="l02006"></a><span class="lineno"> 2006</span>            <span class="comment">// If xi2 == +1 or -1 then this secondary node mapped directly to a node on the primary</span></div>
<div class="line"><a id="l02007" name="l02007"></a><span class="lineno"> 2007</span>            <span class="comment">// surface. This isn&#39;t as unlikely as you might think, it will happen if the meshes</span></div>
<div class="line"><a id="l02008" name="l02008"></a><span class="lineno"> 2008</span>            <span class="comment">// on the interface start off being perfectly aligned. In this situation, we need to</span></div>
<div class="line"><a id="l02009" name="l02009"></a><span class="lineno"> 2009</span>            <span class="comment">// associate the secondary node with two different elements (and two corresponding</span></div>
<div class="line"><a id="l02010" name="l02010"></a><span class="lineno"> 2010</span>            <span class="comment">// xi^(2) values.</span></div>
<div class="line"><a id="l02011" name="l02011"></a><span class="lineno"> 2011</span> </div>
<div class="line"><a id="l02012" name="l02012"></a><span class="lineno"> 2012</span>            <span class="comment">// We are projecting on one side first and the other side second. If we make the</span></div>
<div class="line"><a id="l02013" name="l02013"></a><span class="lineno"> 2013</span>            <span class="comment">// tolerance bigger and remove the (5) factor we are going to continue to miss the</span></div>
<div class="line"><a id="l02014" name="l02014"></a><span class="lineno"> 2014</span>            <span class="comment">// second projection and fall into the exception message in</span></div>
<div class="line"><a id="l02015" name="l02015"></a><span class="lineno"> 2015</span>            <span class="comment">// projectPrimaryNodesSinglePair. What makes this modification to not fall in the</span></div>
<div class="line"><a id="l02016" name="l02016"></a><span class="lineno"> 2016</span>            <span class="comment">// exception is that we are projecting on one side more xi than in the other. There</span></div>
<div class="line"><a id="l02017" name="l02017"></a><span class="lineno"> 2017</span>            <span class="comment">// should be a better way of doing this by using actual distances and not parametric</span></div>
<div class="line"><a id="l02018" name="l02018"></a><span class="lineno"> 2018</span>            <span class="comment">// coordinates. But I believe making the tolerance uniformly larger or smaller won&#39;t do</span></div>
<div class="line"><a id="l02019" name="l02019"></a><span class="lineno"> 2019</span>            <span class="comment">// the trick here.</span></div>
<div class="line"><a id="l02020" name="l02020"></a><span class="lineno"> 2020</span>            <span class="keywordflow">if</span> (std::abs(std::abs(xi2) - 1.) &lt; <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a25f6f147b1b0a4b00e7c6739dd17b98c">_xi_tolerance</a> * 5.0)</div>
<div class="line"><a id="l02021" name="l02021"></a><span class="lineno"> 2021</span>            {</div>
<div class="line"><a id="l02022" name="l02022"></a><span class="lineno"> 2022</span>              <span class="keyword">const</span> Node * primary_node = (xi2 &lt; 0) ? primary_elem_candidate-&gt;node_ptr(0)</div>
<div class="line"><a id="l02023" name="l02023"></a><span class="lineno"> 2023</span>                                                    : primary_elem_candidate-&gt;node_ptr(1);</div>
<div class="line"><a id="l02024" name="l02024"></a><span class="lineno"> 2024</span> </div>
<div class="line"><a id="l02025" name="l02025"></a><span class="lineno"> 2025</span>              <span class="keyword">const</span> std::vector&lt;const Elem *&gt; &amp; primary_node_neighbors =</div>
<div class="line"><a id="l02026" name="l02026"></a><span class="lineno"> 2026</span>                  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a1ee9b6e4f8bd88603e22117085758f70">_nodes_to_primary_elem_map</a>.at(primary_node-&gt;id());</div>
<div class="line"><a id="l02027" name="l02027"></a><span class="lineno"> 2027</span> </div>
<div class="line"><a id="l02028" name="l02028"></a><span class="lineno"> 2028</span>              std::vector&lt;bool&gt; primary_elems_mapped(primary_node_neighbors.size(), <span class="keyword">false</span>);</div>
<div class="line"><a id="l02029" name="l02029"></a><span class="lineno"> 2029</span> </div>
<div class="line"><a id="l02030" name="l02030"></a><span class="lineno"> 2030</span>              <span class="comment">// Add entries to secondary_node_and_elem_to_xi2_primary_elem container.</span></div>
<div class="line"><a id="l02031" name="l02031"></a><span class="lineno"> 2031</span>              <span class="comment">//</span></div>
<div class="line"><a id="l02032" name="l02032"></a><span class="lineno"> 2032</span>              <span class="comment">// First, determine &quot;on left&quot; vs. &quot;on right&quot; orientation of the nodal neighbors.</span></div>
<div class="line"><a id="l02033" name="l02033"></a><span class="lineno"> 2033</span>              <span class="comment">// There can be a max of 2 nodal neighbors, and we want to make sure that the</span></div>
<div class="line"><a id="l02034" name="l02034"></a><span class="lineno"> 2034</span>              <span class="comment">// secondary nodal neighbor on the &quot;left&quot; is associated with the primary nodal</span></div>
<div class="line"><a id="l02035" name="l02035"></a><span class="lineno"> 2035</span>              <span class="comment">// neighbor on the &quot;left&quot; and similarly for the &quot;right&quot;.</span></div>
<div class="line"><a id="l02036" name="l02036"></a><span class="lineno"> 2036</span>              std::vector&lt;Real&gt; secondary_node_neighbor_cps(2), primary_node_neighbor_cps(2);</div>
<div class="line"><a id="l02037" name="l02037"></a><span class="lineno"> 2037</span> </div>
<div class="line"><a id="l02038" name="l02038"></a><span class="lineno"> 2038</span>              <span class="comment">// Figure out which secondary side neighbor is on the &quot;left&quot; and which is on the</span></div>
<div class="line"><a id="l02039" name="l02039"></a><span class="lineno"> 2039</span>              <span class="comment">// &quot;right&quot;.</span></div>
<div class="line"><a id="l02040" name="l02040"></a><span class="lineno"> 2040</span>              <span class="keywordflow">for</span> (MooseIndex(secondary_node_neighbors) nn = 0;</div>
<div class="line"><a id="l02041" name="l02041"></a><span class="lineno"> 2041</span>                   nn &lt; secondary_node_neighbors.size();</div>
<div class="line"><a id="l02042" name="l02042"></a><span class="lineno"> 2042</span>                   ++nn)</div>
<div class="line"><a id="l02043" name="l02043"></a><span class="lineno"> 2043</span>              {</div>
<div class="line"><a id="l02044" name="l02044"></a><span class="lineno"> 2044</span>                <span class="keyword">const</span> Elem * secondary_neigh = secondary_node_neighbors[nn];</div>
<div class="line"><a id="l02045" name="l02045"></a><span class="lineno"> 2045</span>                Point opposite = (secondary_neigh-&gt;node_ptr(0) == secondary_node)</div>
<div class="line"><a id="l02046" name="l02046"></a><span class="lineno"> 2046</span>                                     ? secondary_neigh-&gt;point(1)</div>
<div class="line"><a id="l02047" name="l02047"></a><span class="lineno"> 2047</span>                                     : secondary_neigh-&gt;point(0);</div>
<div class="line"><a id="l02048" name="l02048"></a><span class="lineno"> 2048</span>                Point cp = nodal_normal.cross(opposite - *secondary_node);</div>
<div class="line"><a id="l02049" name="l02049"></a><span class="lineno"> 2049</span>                secondary_node_neighbor_cps[nn] = cp(2);</div>
<div class="line"><a id="l02050" name="l02050"></a><span class="lineno"> 2050</span>              }</div>
<div class="line"><a id="l02051" name="l02051"></a><span class="lineno"> 2051</span> </div>
<div class="line"><a id="l02052" name="l02052"></a><span class="lineno"> 2052</span>              <span class="comment">// Figure out which primary side neighbor is on the &quot;left&quot; and which is on the</span></div>
<div class="line"><a id="l02053" name="l02053"></a><span class="lineno"> 2053</span>              <span class="comment">// &quot;right&quot;.</span></div>
<div class="line"><a id="l02054" name="l02054"></a><span class="lineno"> 2054</span>              <span class="keywordflow">for</span> (MooseIndex(primary_node_neighbors) nn = 0; nn &lt; primary_node_neighbors.size();</div>
<div class="line"><a id="l02055" name="l02055"></a><span class="lineno"> 2055</span>                   ++nn)</div>
<div class="line"><a id="l02056" name="l02056"></a><span class="lineno"> 2056</span>              {</div>
<div class="line"><a id="l02057" name="l02057"></a><span class="lineno"> 2057</span>                <span class="keyword">const</span> Elem * primary_neigh = primary_node_neighbors[nn];</div>
<div class="line"><a id="l02058" name="l02058"></a><span class="lineno"> 2058</span>                Point opposite = (primary_neigh-&gt;node_ptr(0) == primary_node)</div>
<div class="line"><a id="l02059" name="l02059"></a><span class="lineno"> 2059</span>                                     ? primary_neigh-&gt;point(1)</div>
<div class="line"><a id="l02060" name="l02060"></a><span class="lineno"> 2060</span>                                     : primary_neigh-&gt;point(0);</div>
<div class="line"><a id="l02061" name="l02061"></a><span class="lineno"> 2061</span>                Point cp = nodal_normal.cross(opposite - *secondary_node);</div>
<div class="line"><a id="l02062" name="l02062"></a><span class="lineno"> 2062</span>                primary_node_neighbor_cps[nn] = cp(2);</div>
<div class="line"><a id="l02063" name="l02063"></a><span class="lineno"> 2063</span>              }</div>
<div class="line"><a id="l02064" name="l02064"></a><span class="lineno"> 2064</span> </div>
<div class="line"><a id="l02065" name="l02065"></a><span class="lineno"> 2065</span>              <span class="comment">// Associate secondary/primary elems on matching sides.</span></div>
<div class="line"><a id="l02066" name="l02066"></a><span class="lineno"> 2066</span>              <span class="keywordtype">bool</span> found_match = <span class="keyword">false</span>;</div>
<div class="line"><a id="l02067" name="l02067"></a><span class="lineno"> 2067</span>              <span class="keywordflow">for</span> (MooseIndex(secondary_node_neighbors) snn = 0;</div>
<div class="line"><a id="l02068" name="l02068"></a><span class="lineno"> 2068</span>                   snn &lt; secondary_node_neighbors.size();</div>
<div class="line"><a id="l02069" name="l02069"></a><span class="lineno"> 2069</span>                   ++snn)</div>
<div class="line"><a id="l02070" name="l02070"></a><span class="lineno"> 2070</span>                <span class="keywordflow">for</span> (MooseIndex(primary_node_neighbors) mnn = 0;</div>
<div class="line"><a id="l02071" name="l02071"></a><span class="lineno"> 2071</span>                     mnn &lt; primary_node_neighbors.size();</div>
<div class="line"><a id="l02072" name="l02072"></a><span class="lineno"> 2072</span>                     ++mnn)</div>
<div class="line"><a id="l02073" name="l02073"></a><span class="lineno"> 2073</span>                  <span class="keywordflow">if</span> (secondary_node_neighbor_cps[snn] * primary_node_neighbor_cps[mnn] &gt; 0)</div>
<div class="line"><a id="l02074" name="l02074"></a><span class="lineno"> 2074</span>                  {</div>
<div class="line"><a id="l02075" name="l02075"></a><span class="lineno"> 2075</span>                    found_match = <span class="keyword">true</span>;</div>
<div class="line"><a id="l02076" name="l02076"></a><span class="lineno"> 2076</span>                    primary_elems_mapped[mnn] = <span class="keyword">true</span>;</div>
<div class="line"><a id="l02077" name="l02077"></a><span class="lineno"> 2077</span> </div>
<div class="line"><a id="l02078" name="l02078"></a><span class="lineno"> 2078</span>                    <span class="comment">// Figure out xi^(2) value by looking at which node primary_node is</span></div>
<div class="line"><a id="l02079" name="l02079"></a><span class="lineno"> 2079</span>                    <span class="comment">// of the current primary node neighbor.</span></div>
<div class="line"><a id="l02080" name="l02080"></a><span class="lineno"> 2080</span>                    Real xi2 = (primary_node == primary_node_neighbors[mnn]-&gt;node_ptr(0)) ? -1 : +1;</div>
<div class="line"><a id="l02081" name="l02081"></a><span class="lineno"> 2081</span>                    <span class="keyword">auto</span> secondary_key =</div>
<div class="line"><a id="l02082" name="l02082"></a><span class="lineno"> 2082</span>                        std::make_pair(secondary_node, secondary_node_neighbors[snn]);</div>
<div class="line"><a id="l02083" name="l02083"></a><span class="lineno"> 2083</span>                    <span class="keyword">auto</span> primary_val = std::make_pair(xi2, primary_node_neighbors[mnn]);</div>
<div class="line"><a id="l02084" name="l02084"></a><span class="lineno"> 2084</span>                    <a class="code hl_variable" href="classAutomaticMortarGeneration.html#abb4cc3e3102675e52675a95347ad8e95">_secondary_node_and_elem_to_xi2_primary_elem</a>.emplace(secondary_key,</div>
<div class="line"><a id="l02085" name="l02085"></a><span class="lineno"> 2085</span>                                                                         primary_val);</div>
<div class="line"><a id="l02086" name="l02086"></a><span class="lineno"> 2086</span> </div>
<div class="line"><a id="l02087" name="l02087"></a><span class="lineno"> 2087</span>                    <span class="comment">// Also map in the other direction.</span></div>
<div class="line"><a id="l02088" name="l02088"></a><span class="lineno"> 2088</span>                    Real xi1 =</div>
<div class="line"><a id="l02089" name="l02089"></a><span class="lineno"> 2089</span>                        (secondary_node == secondary_node_neighbors[snn]-&gt;node_ptr(0)) ? -1 : +1;</div>
<div class="line"><a id="l02090" name="l02090"></a><span class="lineno"> 2090</span> </div>
<div class="line"><a id="l02091" name="l02091"></a><span class="lineno"> 2091</span>                    <span class="keyword">auto</span> primary_key = std::make_tuple(</div>
<div class="line"><a id="l02092" name="l02092"></a><span class="lineno"> 2092</span>                        primary_node-&gt;id(), primary_node, primary_node_neighbors[mnn]);</div>
<div class="line"><a id="l02093" name="l02093"></a><span class="lineno"> 2093</span>                    <span class="keyword">auto</span> secondary_val = std::make_pair(xi1, secondary_node_neighbors[snn]);</div>
<div class="line"><a id="l02094" name="l02094"></a><span class="lineno"> 2094</span>                    <a class="code hl_variable" href="classAutomaticMortarGeneration.html#ac174eedb02e9681baf439360903700d4">_primary_node_and_elem_to_xi1_secondary_elem</a>.emplace(primary_key,</div>
<div class="line"><a id="l02095" name="l02095"></a><span class="lineno"> 2095</span>                                                                         secondary_val);</div>
<div class="line"><a id="l02096" name="l02096"></a><span class="lineno"> 2096</span>                  }</div>
<div class="line"><a id="l02097" name="l02097"></a><span class="lineno"> 2097</span> </div>
<div class="line"><a id="l02098" name="l02098"></a><span class="lineno"> 2098</span>              <span class="keywordflow">if</span> (!found_match)</div>
<div class="line"><a id="l02099" name="l02099"></a><span class="lineno"> 2099</span>              {</div>
<div class="line"><a id="l02100" name="l02100"></a><span class="lineno"> 2100</span>                <span class="comment">// There could be coincident nodes and this might be a bad primary candidate (see</span></div>
<div class="line"><a id="l02101" name="l02101"></a><span class="lineno"> 2101</span>                <span class="comment">// issue #21680). Instead of giving up, let&#39;s try continuing</span></div>
<div class="line"><a id="l02102" name="l02102"></a><span class="lineno"> 2102</span>                rejected_primary_elem_candidates.insert(primary_elem_candidate);</div>
<div class="line"><a id="l02103" name="l02103"></a><span class="lineno"> 2103</span>                <span class="keywordflow">continue</span>;</div>
<div class="line"><a id="l02104" name="l02104"></a><span class="lineno"> 2104</span>              }</div>
<div class="line"><a id="l02105" name="l02105"></a><span class="lineno"> 2105</span> </div>
<div class="line"><a id="l02106" name="l02106"></a><span class="lineno"> 2106</span>              <span class="comment">// We need to handle the case where we&#39;ve exactly projected a secondary node onto a</span></div>
<div class="line"><a id="l02107" name="l02107"></a><span class="lineno"> 2107</span>              <span class="comment">// primary node, but our secondary node is at one of the secondary face endpoints and</span></div>
<div class="line"><a id="l02108" name="l02108"></a><span class="lineno"> 2108</span>              <span class="comment">// our primary node is not.</span></div>
<div class="line"><a id="l02109" name="l02109"></a><span class="lineno"> 2109</span>              <span class="keywordflow">if</span> (secondary_node_neighbors.size() == 1 &amp;&amp; primary_node_neighbors.size() == 2)</div>
<div class="line"><a id="l02110" name="l02110"></a><span class="lineno"> 2110</span>                <span class="keywordflow">for</span> (<span class="keyword">auto</span> it = primary_elems_mapped.begin(); it != primary_elems_mapped.end(); ++it)</div>
<div class="line"><a id="l02111" name="l02111"></a><span class="lineno"> 2111</span>                  <span class="keywordflow">if</span> (*it == <span class="keyword">false</span>)</div>
<div class="line"><a id="l02112" name="l02112"></a><span class="lineno"> 2112</span>                  {</div>
<div class="line"><a id="l02113" name="l02113"></a><span class="lineno"> 2113</span>                    <span class="keyword">auto</span> index = std::distance(primary_elems_mapped.begin(), it);</div>
<div class="line"><a id="l02114" name="l02114"></a><span class="lineno"> 2114</span>                    <a class="code hl_variable" href="classAutomaticMortarGeneration.html#ac174eedb02e9681baf439360903700d4">_primary_node_and_elem_to_xi1_secondary_elem</a>.emplace(</div>
<div class="line"><a id="l02115" name="l02115"></a><span class="lineno"> 2115</span>                        std::make_tuple(</div>
<div class="line"><a id="l02116" name="l02116"></a><span class="lineno"> 2116</span>                            primary_node-&gt;id(), primary_node, primary_node_neighbors[index]),</div>
<div class="line"><a id="l02117" name="l02117"></a><span class="lineno"> 2117</span>                        std::make_pair(1, <span class="keyword">nullptr</span>));</div>
<div class="line"><a id="l02118" name="l02118"></a><span class="lineno"> 2118</span>                  }</div>
<div class="line"><a id="l02119" name="l02119"></a><span class="lineno"> 2119</span>            }</div>
<div class="line"><a id="l02120" name="l02120"></a><span class="lineno"> 2120</span>            <span class="keywordflow">else</span> <span class="comment">// Point falls somewhere in the middle of the Elem.</span></div>
<div class="line"><a id="l02121" name="l02121"></a><span class="lineno"> 2121</span>            {</div>
<div class="line"><a id="l02122" name="l02122"></a><span class="lineno"> 2122</span>              <span class="comment">// Add two entries to secondary_node_and_elem_to_xi2_primary_elem.</span></div>
<div class="line"><a id="l02123" name="l02123"></a><span class="lineno"> 2123</span>              <span class="keywordflow">for</span> (MooseIndex(secondary_node_neighbors) nn = 0;</div>
<div class="line"><a id="l02124" name="l02124"></a><span class="lineno"> 2124</span>                   nn &lt; secondary_node_neighbors.size();</div>
<div class="line"><a id="l02125" name="l02125"></a><span class="lineno"> 2125</span>                   ++nn)</div>
<div class="line"><a id="l02126" name="l02126"></a><span class="lineno"> 2126</span>              {</div>
<div class="line"><a id="l02127" name="l02127"></a><span class="lineno"> 2127</span>                <span class="keyword">const</span> Elem * neigh = secondary_node_neighbors[nn];</div>
<div class="line"><a id="l02128" name="l02128"></a><span class="lineno"> 2128</span>                <span class="keywordflow">for</span> (MooseIndex(neigh-&gt;n_vertices()) nid = 0; nid &lt; neigh-&gt;n_vertices(); ++nid)</div>
<div class="line"><a id="l02129" name="l02129"></a><span class="lineno"> 2129</span>                {</div>
<div class="line"><a id="l02130" name="l02130"></a><span class="lineno"> 2130</span>                  <span class="keyword">const</span> Node * neigh_node = neigh-&gt;node_ptr(nid);</div>
<div class="line"><a id="l02131" name="l02131"></a><span class="lineno"> 2131</span>                  <span class="keywordflow">if</span> (secondary_node == neigh_node)</div>
<div class="line"><a id="l02132" name="l02132"></a><span class="lineno"> 2132</span>                  {</div>
<div class="line"><a id="l02133" name="l02133"></a><span class="lineno"> 2133</span>                    <span class="keyword">auto</span> key = std::make_pair(neigh_node, neigh);</div>
<div class="line"><a id="l02134" name="l02134"></a><span class="lineno"> 2134</span>                    <span class="keyword">auto</span> val = std::make_pair(xi2, primary_elem_candidate);</div>
<div class="line"><a id="l02135" name="l02135"></a><span class="lineno"> 2135</span>                    <a class="code hl_variable" href="classAutomaticMortarGeneration.html#abb4cc3e3102675e52675a95347ad8e95">_secondary_node_and_elem_to_xi2_primary_elem</a>.emplace(key, val);</div>
<div class="line"><a id="l02136" name="l02136"></a><span class="lineno"> 2136</span>                  }</div>
<div class="line"><a id="l02137" name="l02137"></a><span class="lineno"> 2137</span>                }</div>
<div class="line"><a id="l02138" name="l02138"></a><span class="lineno"> 2138</span>              }</div>
<div class="line"><a id="l02139" name="l02139"></a><span class="lineno"> 2139</span>            }</div>
<div class="line"><a id="l02140" name="l02140"></a><span class="lineno"> 2140</span> </div>
<div class="line"><a id="l02141" name="l02141"></a><span class="lineno"> 2141</span>            projection_succeeded = <span class="keyword">true</span>;</div>
<div class="line"><a id="l02142" name="l02142"></a><span class="lineno"> 2142</span>            <span class="keywordflow">break</span>; <span class="comment">// out of e-loop</span></div>
<div class="line"><a id="l02143" name="l02143"></a><span class="lineno"> 2143</span>          }</div>
<div class="line"><a id="l02144" name="l02144"></a><span class="lineno"> 2144</span>          <span class="keywordflow">else</span></div>
<div class="line"><a id="l02145" name="l02145"></a><span class="lineno"> 2145</span>            <span class="comment">// The current secondary_node is not in this Elem, so keep track of the rejects.</span></div>
<div class="line"><a id="l02146" name="l02146"></a><span class="lineno"> 2146</span>            rejected_primary_elem_candidates.insert(primary_elem_candidate);</div>
<div class="line"><a id="l02147" name="l02147"></a><span class="lineno"> 2147</span>        }</div>
<div class="line"><a id="l02148" name="l02148"></a><span class="lineno"> 2148</span> </div>
<div class="line"><a id="l02149" name="l02149"></a><span class="lineno"> 2149</span>        <span class="keywordflow">if</span> (projection_succeeded)</div>
<div class="line"><a id="l02150" name="l02150"></a><span class="lineno"> 2150</span>          <span class="keywordflow">break</span>; <span class="comment">// out of r-loop</span></div>
<div class="line"><a id="l02151" name="l02151"></a><span class="lineno"> 2151</span>      }          <span class="comment">// r-loop</span></div>
<div class="line"><a id="l02152" name="l02152"></a><span class="lineno"> 2152</span> </div>
<div class="line"><a id="l02153" name="l02153"></a><span class="lineno"> 2153</span>      <span class="keywordflow">if</span> (!projection_succeeded &amp;&amp; <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a958de5b754ec676f463c50d2f16b5d0c">_debug</a>)</div>
<div class="line"><a id="l02154" name="l02154"></a><span class="lineno"> 2154</span>        <a class="code hl_variable" href="classConsoleStreamInterface.html#acd1f259e7a3d200223164c08af3a7c13">_console</a> &lt;&lt; <span class="stringliteral">&quot;Failed to find primary Elem into which secondary node &quot;</span></div>
<div class="line"><a id="l02155" name="l02155"></a><span class="lineno"> 2155</span>                 &lt;&lt; <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>Point &amp;<span class="keyword">&gt;</span>(*secondary_node) &lt;&lt; <span class="stringliteral">&quot; was projected.&quot;</span> &lt;&lt; std::endl</div>
<div class="line"><a id="l02156" name="l02156"></a><span class="lineno"> 2156</span>                 &lt;&lt; std::endl;</div>
<div class="line"><a id="l02157" name="l02157"></a><span class="lineno"> 2157</span>    } <span class="comment">// loop over side nodes</span></div>
<div class="line"><a id="l02158" name="l02158"></a><span class="lineno"> 2158</span>  }   <span class="comment">// end loop over lower-dimensional elements</span></div>
<div class="line"><a id="l02159" name="l02159"></a><span class="lineno"> 2159</span>}</div>
<div class="line"><a id="l02160" name="l02160"></a><span class="lineno"> 2160</span> </div>
<div class="line"><a id="l02161" name="l02161"></a><span class="lineno"> 2161</span><span class="comment">// Inverse map primary nodes onto their corresponding secondary elements for each primary/secondary</span></div>
<div class="line"><a id="l02162" name="l02162"></a><span class="lineno"> 2162</span><span class="comment">// pair.</span></div>
<div class="line"><a id="l02163" name="l02163"></a><span class="lineno"> 2163</span><span class="keywordtype">void</span></div>
<div class="line"><a id="l02164" name="l02164"></a><span class="lineno"><a class="line" href="classAutomaticMortarGeneration.html#af3d7aaf216fe1d8fabc8461756312a1f"> 2164</a></span><a class="code hl_function" href="classAutomaticMortarGeneration.html#af3d7aaf216fe1d8fabc8461756312a1f">AutomaticMortarGeneration::projectPrimaryNodes</a>()</div>
<div class="line"><a id="l02165" name="l02165"></a><span class="lineno"> 2165</span>{</div>
<div class="line"><a id="l02166" name="l02166"></a><span class="lineno"> 2166</span>  <span class="comment">// For each primary/secondary boundary id pair, call the</span></div>
<div class="line"><a id="l02167" name="l02167"></a><span class="lineno"> 2167</span>  <span class="comment">// project_primary_nodes_single_pair() helper function.</span></div>
<div class="line"><a id="l02168" name="l02168"></a><span class="lineno"> 2168</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; pr : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a969d4ab038fc8d447e966cd1e1600091">_primary_secondary_subdomain_id_pairs</a>)</div>
<div class="line"><a id="l02169" name="l02169"></a><span class="lineno"> 2169</span>    <a class="code hl_function" href="classAutomaticMortarGeneration.html#accf5b2f45171eb92b58dd27d22b9715c">projectPrimaryNodesSinglePair</a>(pr.first, pr.second);</div>
<div class="line"><a id="l02170" name="l02170"></a><span class="lineno"> 2170</span>}</div>
<div class="line"><a id="l02171" name="l02171"></a><span class="lineno"> 2171</span> </div>
<div class="line"><a id="l02172" name="l02172"></a><span class="lineno"> 2172</span><span class="keywordtype">void</span></div>
<div class="line"><a id="l02173" name="l02173"></a><span class="lineno"><a class="line" href="classAutomaticMortarGeneration.html#accf5b2f45171eb92b58dd27d22b9715c"> 2173</a></span><a class="code hl_function" href="classAutomaticMortarGeneration.html#accf5b2f45171eb92b58dd27d22b9715c">AutomaticMortarGeneration::projectPrimaryNodesSinglePair</a>(</div>
<div class="line"><a id="l02174" name="l02174"></a><span class="lineno"> 2174</span>    <a class="code hl_typedef" href="AutomaticMortarGeneration_8h.html#afb1ef82fea6170b578d48ad9cd793486">SubdomainID</a> lower_dimensional_primary_subdomain_id,</div>
<div class="line"><a id="l02175" name="l02175"></a><span class="lineno"> 2175</span>    <a class="code hl_typedef" href="AutomaticMortarGeneration_8h.html#afb1ef82fea6170b578d48ad9cd793486">SubdomainID</a> lower_dimensional_secondary_subdomain_id)</div>
<div class="line"><a id="l02176" name="l02176"></a><span class="lineno"> 2176</span>{</div>
<div class="line"><a id="l02177" name="l02177"></a><span class="lineno"> 2177</span>  <span class="comment">// Build a Nanoflann object on the lower-dimensional secondary elements of the Mesh.</span></div>
<div class="line"><a id="l02178" name="l02178"></a><span class="lineno"> 2178</span>  <a class="code hl_class" href="classNanoflannMeshSubdomainAdaptor.html">NanoflannMeshSubdomainAdaptor&lt;3&gt;</a> mesh_adaptor(<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>, lower_dimensional_secondary_subdomain_id);</div>
<div class="line"><a id="l02179" name="l02179"></a><span class="lineno"> 2179</span>  <a class="code hl_typedef" href="NanoflannMeshAdaptor_8h.html#a3a70df33047194961ce21a0133717038">subdomain_kd_tree_t</a> kd_tree(</div>
<div class="line"><a id="l02180" name="l02180"></a><span class="lineno"> 2180</span>      3, mesh_adaptor, nanoflann::KDTreeSingleIndexAdaptorParams(<span class="comment">/*max leaf=*/</span>10));</div>
<div class="line"><a id="l02181" name="l02181"></a><span class="lineno"> 2181</span> </div>
<div class="line"><a id="l02182" name="l02182"></a><span class="lineno"> 2182</span>  <span class="comment">// Construct the KD tree for lower-dimensional elements in the volume mesh.</span></div>
<div class="line"><a id="l02183" name="l02183"></a><span class="lineno"> 2183</span>  kd_tree.buildIndex();</div>
<div class="line"><a id="l02184" name="l02184"></a><span class="lineno"> 2184</span> </div>
<div class="line"><a id="l02185" name="l02185"></a><span class="lineno"> 2185</span>  std::unordered_set&lt;dof_id_type&gt; primary_nodes_visited;</div>
<div class="line"><a id="l02186" name="l02186"></a><span class="lineno"> 2186</span> </div>
<div class="line"><a id="l02187" name="l02187"></a><span class="lineno"> 2187</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; primary_side_elem : <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.active_element_ptr_range())</div>
<div class="line"><a id="l02188" name="l02188"></a><span class="lineno"> 2188</span>  {</div>
<div class="line"><a id="l02189" name="l02189"></a><span class="lineno"> 2189</span>    <span class="comment">// If this is not one of the lower-dimensional primary side elements, go on to the next one.</span></div>
<div class="line"><a id="l02190" name="l02190"></a><span class="lineno"> 2190</span>    <span class="keywordflow">if</span> (primary_side_elem-&gt;subdomain_id() != lower_dimensional_primary_subdomain_id)</div>
<div class="line"><a id="l02191" name="l02191"></a><span class="lineno"> 2191</span>      <span class="keywordflow">continue</span>;</div>
<div class="line"><a id="l02192" name="l02192"></a><span class="lineno"> 2192</span> </div>
<div class="line"><a id="l02193" name="l02193"></a><span class="lineno"> 2193</span>    <span class="comment">// For each node on this side, find the nearest node on the secondary side using the KDTree,</span></div>
<div class="line"><a id="l02194" name="l02194"></a><span class="lineno"> 2194</span>    <span class="comment">// then search in nearby elements for where it projects along the nodal normal direction.</span></div>
<div class="line"><a id="l02195" name="l02195"></a><span class="lineno"> 2195</span>    <span class="keywordflow">for</span> (MooseIndex(primary_side_elem-&gt;n_vertices()) n = 0; n &lt; primary_side_elem-&gt;n_vertices();</div>
<div class="line"><a id="l02196" name="l02196"></a><span class="lineno"> 2196</span>         ++n)</div>
<div class="line"><a id="l02197" name="l02197"></a><span class="lineno"> 2197</span>    {</div>
<div class="line"><a id="l02198" name="l02198"></a><span class="lineno"> 2198</span>      <span class="comment">// Get a pointer to this node.</span></div>
<div class="line"><a id="l02199" name="l02199"></a><span class="lineno"> 2199</span>      <span class="keyword">const</span> Node * primary_node = primary_side_elem-&gt;node_ptr(n);</div>
<div class="line"><a id="l02200" name="l02200"></a><span class="lineno"> 2200</span> </div>
<div class="line"><a id="l02201" name="l02201"></a><span class="lineno"> 2201</span>      <span class="comment">// Get the nodal neighbors connected to this primary node.</span></div>
<div class="line"><a id="l02202" name="l02202"></a><span class="lineno"> 2202</span>      <span class="keyword">const</span> std::vector&lt;const Elem *&gt; &amp; primary_node_neighbors =</div>
<div class="line"><a id="l02203" name="l02203"></a><span class="lineno"> 2203</span>          <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a1ee9b6e4f8bd88603e22117085758f70">_nodes_to_primary_elem_map</a>.at(primary_node-&gt;id());</div>
<div class="line"><a id="l02204" name="l02204"></a><span class="lineno"> 2204</span> </div>
<div class="line"><a id="l02205" name="l02205"></a><span class="lineno"> 2205</span>      <span class="comment">// Check whether we have already successfully inverse mapped this primary node (whether during</span></div>
<div class="line"><a id="l02206" name="l02206"></a><span class="lineno"> 2206</span>      <span class="comment">// secondary node projection or now during primary node projection) or we have already failed</span></div>
<div class="line"><a id="l02207" name="l02207"></a><span class="lineno"> 2207</span>      <span class="comment">// to inverse map this primary node (now during primary node projection), and then skip if</span></div>
<div class="line"><a id="l02208" name="l02208"></a><span class="lineno"> 2208</span>      <span class="comment">// either of those things is true</span></div>
<div class="line"><a id="l02209" name="l02209"></a><span class="lineno"> 2209</span>      <span class="keyword">auto</span> primary_key =</div>
<div class="line"><a id="l02210" name="l02210"></a><span class="lineno"> 2210</span>          std::make_tuple(primary_node-&gt;id(), primary_node, primary_node_neighbors[0]);</div>
<div class="line"><a id="l02211" name="l02211"></a><span class="lineno"> 2211</span>      <span class="keywordflow">if</span> (!primary_nodes_visited.insert(primary_node-&gt;id()).second ||</div>
<div class="line"><a id="l02212" name="l02212"></a><span class="lineno"> 2212</span>          <a class="code hl_variable" href="classAutomaticMortarGeneration.html#ac174eedb02e9681baf439360903700d4">_primary_node_and_elem_to_xi1_secondary_elem</a>.count(primary_key))</div>
<div class="line"><a id="l02213" name="l02213"></a><span class="lineno"> 2213</span>        <span class="keywordflow">continue</span>;</div>
<div class="line"><a id="l02214" name="l02214"></a><span class="lineno"> 2214</span> </div>
<div class="line"><a id="l02215" name="l02215"></a><span class="lineno"> 2215</span>      <span class="comment">// Data structure for performing Nanoflann searches.</span></div>
<div class="line"><a id="l02216" name="l02216"></a><span class="lineno"> 2216</span>      Real query_pt[3] = {(*primary_node)(0), (*primary_node)(1), (*primary_node)(2)};</div>
<div class="line"><a id="l02217" name="l02217"></a><span class="lineno"> 2217</span> </div>
<div class="line"><a id="l02218" name="l02218"></a><span class="lineno"> 2218</span>      <span class="comment">// The number of results we want to get.  We&#39;ll look for a</span></div>
<div class="line"><a id="l02219" name="l02219"></a><span class="lineno"> 2219</span>      <span class="comment">// &quot;few&quot; nearest nodes, hopefully that is enough to let us</span></div>
<div class="line"><a id="l02220" name="l02220"></a><span class="lineno"> 2220</span>      <span class="comment">// figure out which lower-dimensional Elem on the secondary side</span></div>
<div class="line"><a id="l02221" name="l02221"></a><span class="lineno"> 2221</span>      <span class="comment">// we are across from.</span></div>
<div class="line"><a id="l02222" name="l02222"></a><span class="lineno"> 2222</span>      <span class="keyword">const</span> <span class="keywordtype">size_t</span> num_results = 3;</div>
<div class="line"><a id="l02223" name="l02223"></a><span class="lineno"> 2223</span> </div>
<div class="line"><a id="l02224" name="l02224"></a><span class="lineno"> 2224</span>      <span class="comment">// Initialize result_set and do the search.</span></div>
<div class="line"><a id="l02225" name="l02225"></a><span class="lineno"> 2225</span>      std::vector&lt;size_t&gt; ret_index(num_results);</div>
<div class="line"><a id="l02226" name="l02226"></a><span class="lineno"> 2226</span>      std::vector&lt;Real&gt; out_dist_sqr(num_results);</div>
<div class="line"><a id="l02227" name="l02227"></a><span class="lineno"> 2227</span>      nanoflann::KNNResultSet&lt;Real&gt; result_set(num_results);</div>
<div class="line"><a id="l02228" name="l02228"></a><span class="lineno"> 2228</span>      result_set.init(&amp;ret_index[0], &amp;out_dist_sqr[0]);</div>
<div class="line"><a id="l02229" name="l02229"></a><span class="lineno"> 2229</span>      kd_tree.findNeighbors(result_set, &amp;query_pt[0], <a class="code hl_typedef" href="namespacenanoflann.html#a7475277cf1d06434e352ade6f35de645">nanoflann::SearchParameters</a>());</div>
<div class="line"><a id="l02230" name="l02230"></a><span class="lineno"> 2230</span> </div>
<div class="line"><a id="l02231" name="l02231"></a><span class="lineno"> 2231</span>      <span class="comment">// If this flag gets set in the loop below, we can break out of the outer r-loop as well.</span></div>
<div class="line"><a id="l02232" name="l02232"></a><span class="lineno"> 2232</span>      <span class="keywordtype">bool</span> projection_succeeded = <span class="keyword">false</span>;</div>
<div class="line"><a id="l02233" name="l02233"></a><span class="lineno"> 2233</span> </div>
<div class="line"><a id="l02234" name="l02234"></a><span class="lineno"> 2234</span>      <span class="comment">// Once we&#39;ve rejected a candidate for a given</span></div>
<div class="line"><a id="l02235" name="l02235"></a><span class="lineno"> 2235</span>      <span class="comment">// primary_node, there&#39;s no reason to check it</span></div>
<div class="line"><a id="l02236" name="l02236"></a><span class="lineno"> 2236</span>      <span class="comment">// again.</span></div>
<div class="line"><a id="l02237" name="l02237"></a><span class="lineno"> 2237</span>      std::set&lt;const Elem *&gt; rejected_secondary_elem_candidates;</div>
<div class="line"><a id="l02238" name="l02238"></a><span class="lineno"> 2238</span> </div>
<div class="line"><a id="l02239" name="l02239"></a><span class="lineno"> 2239</span>      <span class="comment">// Loop over the closest nodes, check whether the secondary node successfully projects into</span></div>
<div class="line"><a id="l02240" name="l02240"></a><span class="lineno"> 2240</span>      <span class="comment">// either of the closest neighbors, stop when the projection succeeds.</span></div>
<div class="line"><a id="l02241" name="l02241"></a><span class="lineno"> 2241</span>      <span class="keywordflow">for</span> (MooseIndex(result_set) r = 0; r &lt; result_set.size(); ++r)</div>
<div class="line"><a id="l02242" name="l02242"></a><span class="lineno"> 2242</span>      {</div>
<div class="line"><a id="l02243" name="l02243"></a><span class="lineno"> 2243</span>        <span class="comment">// Verify that the squared distance we compute is the same as nanoflann&#39;s</span></div>
<div class="line"><a id="l02244" name="l02244"></a><span class="lineno"> 2244</span>        mooseAssert(std::abs((<a class="code hl_variable" href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">_mesh</a>.point(ret_index[r]) - *primary_node).norm_sq() -</div>
<div class="line"><a id="l02245" name="l02245"></a><span class="lineno"> 2245</span>                             out_dist_sqr[r]) &lt;= TOLERANCE,</div>
<div class="line"><a id="l02246" name="l02246"></a><span class="lineno"> 2246</span>                    <span class="stringliteral">&quot;Lower-dimensional element squared distance verification failed.&quot;</span>);</div>
<div class="line"><a id="l02247" name="l02247"></a><span class="lineno"> 2247</span> </div>
<div class="line"><a id="l02248" name="l02248"></a><span class="lineno"> 2248</span>        <span class="comment">// Get a reference to the vector of lower dimensional elements from the</span></div>
<div class="line"><a id="l02249" name="l02249"></a><span class="lineno"> 2249</span>        <span class="comment">// nodes_to_secondary_elem_map.</span></div>
<div class="line"><a id="l02250" name="l02250"></a><span class="lineno"> 2250</span>        <span class="keyword">const</span> std::vector&lt;const Elem *&gt; &amp; secondary_elem_candidates =</div>
<div class="line"><a id="l02251" name="l02251"></a><span class="lineno"> 2251</span>            <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a1ad443aa196d2c81d195b29ddeee1d5e">_nodes_to_secondary_elem_map</a>.at(<span class="keyword">static_cast&lt;</span>dof_id_type<span class="keyword">&gt;</span>(ret_index[r]));</div>
<div class="line"><a id="l02252" name="l02252"></a><span class="lineno"> 2252</span> </div>
<div class="line"><a id="l02253" name="l02253"></a><span class="lineno"> 2253</span>        <span class="comment">// Print the Elems connected to this node on the secondary mesh side.</span></div>
<div class="line"><a id="l02254" name="l02254"></a><span class="lineno"> 2254</span>        <span class="keywordflow">for</span> (MooseIndex(secondary_elem_candidates) e = 0; e &lt; secondary_elem_candidates.size(); ++e)</div>
<div class="line"><a id="l02255" name="l02255"></a><span class="lineno"> 2255</span>        {</div>
<div class="line"><a id="l02256" name="l02256"></a><span class="lineno"> 2256</span>          <span class="keyword">const</span> Elem * secondary_elem_candidate = secondary_elem_candidates[e];</div>
<div class="line"><a id="l02257" name="l02257"></a><span class="lineno"> 2257</span> </div>
<div class="line"><a id="l02258" name="l02258"></a><span class="lineno"> 2258</span>          <span class="comment">// If we&#39;ve already rejected this candidate, we don&#39;t need to check it again.</span></div>
<div class="line"><a id="l02259" name="l02259"></a><span class="lineno"> 2259</span>          <span class="keywordflow">if</span> (rejected_secondary_elem_candidates.count(secondary_elem_candidate))</div>
<div class="line"><a id="l02260" name="l02260"></a><span class="lineno"> 2260</span>            <span class="keywordflow">continue</span>;</div>
<div class="line"><a id="l02261" name="l02261"></a><span class="lineno"> 2261</span> </div>
<div class="line"><a id="l02262" name="l02262"></a><span class="lineno"> 2262</span>          std::vector&lt;Point&gt; nodal_normals(secondary_elem_candidate-&gt;n_nodes());</div>
<div class="line"><a id="l02263" name="l02263"></a><span class="lineno"> 2263</span>          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> n : make_range(secondary_elem_candidate-&gt;n_nodes()))</div>
<div class="line"><a id="l02264" name="l02264"></a><span class="lineno"> 2264</span>            nodal_normals[n] =</div>
<div class="line"><a id="l02265" name="l02265"></a><span class="lineno"> 2265</span>                <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a06fb539aea2e63f3b48a6e1d41a2f568">_secondary_node_to_nodal_normal</a>.at(secondary_elem_candidate-&gt;node_ptr(n));</div>
<div class="line"><a id="l02266" name="l02266"></a><span class="lineno"> 2266</span> </div>
<div class="line"><a id="l02267" name="l02267"></a><span class="lineno"> 2267</span>          <span class="comment">// Use equation 2.4.6 from Bin Yang&#39;s dissertation to try and solve for</span></div>
<div class="line"><a id="l02268" name="l02268"></a><span class="lineno"> 2268</span>          <span class="comment">// the position on the secondary element where this primary came from.  This</span></div>
<div class="line"><a id="l02269" name="l02269"></a><span class="lineno"> 2269</span>          <span class="comment">// requires a Newton iteration in general.</span></div>
<div class="line"><a id="l02270" name="l02270"></a><span class="lineno"> 2270</span>          <a class="code hl_class" href="classMetaPhysicL_1_1DualNumber.html">DualNumber&lt;Real&gt;</a> xi1_dn{0, 1}; <span class="comment">// initial guess</span></div>
<div class="line"><a id="l02271" name="l02271"></a><span class="lineno"> 2271</span>          <span class="keyword">auto</span> &amp;&amp; order = secondary_elem_candidate-&gt;default_order();</div>
<div class="line"><a id="l02272" name="l02272"></a><span class="lineno"> 2272</span>          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> current_iterate = 0, max_iterates = 10;</div>
<div class="line"><a id="l02273" name="l02273"></a><span class="lineno"> 2273</span> </div>
<div class="line"><a id="l02274" name="l02274"></a><span class="lineno"> 2274</span>          <a class="code hl_class" href="classlibMesh_1_1VectorValue.html">VectorValue&lt;DualNumber&lt;Real&gt;</a>&gt; normals(0);</div>
<div class="line"><a id="l02275" name="l02275"></a><span class="lineno"> 2275</span> </div>
<div class="line"><a id="l02276" name="l02276"></a><span class="lineno"> 2276</span>          <span class="comment">// Newton iteration loop - this to converge in 1 iteration when it</span></div>
<div class="line"><a id="l02277" name="l02277"></a><span class="lineno"> 2277</span>          <span class="comment">// succeeds, and possibly two iterations when it converges to a</span></div>
<div class="line"><a id="l02278" name="l02278"></a><span class="lineno"> 2278</span>          <span class="comment">// xi outside the reference element. I don&#39;t know any reason why it should</span></div>
<div class="line"><a id="l02279" name="l02279"></a><span class="lineno"> 2279</span>          <span class="comment">// only take 1 iteration -- the Jacobian is not constant in general...</span></div>
<div class="line"><a id="l02280" name="l02280"></a><span class="lineno"> 2280</span>          <span class="keywordflow">do</span></div>
<div class="line"><a id="l02281" name="l02281"></a><span class="lineno"> 2281</span>          {</div>
<div class="line"><a id="l02282" name="l02282"></a><span class="lineno"> 2282</span>            <a class="code hl_class" href="classlibMesh_1_1VectorValue.html">VectorValue&lt;DualNumber&lt;Real&gt;</a>&gt; x1(0);</div>
<div class="line"><a id="l02283" name="l02283"></a><span class="lineno"> 2283</span>            <span class="keywordflow">for</span> (MooseIndex(secondary_elem_candidate-&gt;n_nodes()) n = 0;</div>
<div class="line"><a id="l02284" name="l02284"></a><span class="lineno"> 2284</span>                 n &lt; secondary_elem_candidate-&gt;n_nodes();</div>
<div class="line"><a id="l02285" name="l02285"></a><span class="lineno"> 2285</span>                 ++n)</div>
<div class="line"><a id="l02286" name="l02286"></a><span class="lineno"> 2286</span>            {</div>
<div class="line"><a id="l02287" name="l02287"></a><span class="lineno"> 2287</span>              <span class="keyword">const</span> <span class="keyword">auto</span> phi = <a class="code hl_function" href="namespaceMoose.html#a9ed3373b5072c07f1f010afb75ac20c9">Moose::fe_lagrange_1D_shape</a>(order, n, xi1_dn);</div>
<div class="line"><a id="l02288" name="l02288"></a><span class="lineno"> 2288</span>              x1 += phi * secondary_elem_candidate-&gt;point(n);</div>
<div class="line"><a id="l02289" name="l02289"></a><span class="lineno"> 2289</span>              normals += phi * nodal_normals[n];</div>
<div class="line"><a id="l02290" name="l02290"></a><span class="lineno"> 2290</span>            }</div>
<div class="line"><a id="l02291" name="l02291"></a><span class="lineno"> 2291</span> </div>
<div class="line"><a id="l02292" name="l02292"></a><span class="lineno"> 2292</span>            <span class="keyword">const</span> <span class="keyword">auto</span> u = x1 - (*primary_node);</div>
<div class="line"><a id="l02293" name="l02293"></a><span class="lineno"> 2293</span> </div>
<div class="line"><a id="l02294" name="l02294"></a><span class="lineno"> 2294</span>            <span class="keyword">const</span> <span class="keyword">auto</span> F = u(0) * normals(1) - u(1) * normals(0);</div>
<div class="line"><a id="l02295" name="l02295"></a><span class="lineno"> 2295</span> </div>
<div class="line"><a id="l02296" name="l02296"></a><span class="lineno"> 2296</span>            <span class="keywordflow">if</span> (std::abs(F) &lt; <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a04e775677691747d25e1a5f05496fa5a">_newton_tolerance</a>)</div>
<div class="line"><a id="l02297" name="l02297"></a><span class="lineno"> 2297</span>              <span class="keywordflow">break</span>;</div>
<div class="line"><a id="l02298" name="l02298"></a><span class="lineno"> 2298</span> </div>
<div class="line"><a id="l02299" name="l02299"></a><span class="lineno"> 2299</span>            <span class="comment">// Unlike for projection of nodal normals onto primary surfaces, we should never have a</span></div>
<div class="line"><a id="l02300" name="l02300"></a><span class="lineno"> 2300</span>            <span class="comment">// case where the nodal normal is completely orthogonal to the secondary surface, so we</span></div>
<div class="line"><a id="l02301" name="l02301"></a><span class="lineno"> 2301</span>            <span class="comment">// do not have to guard against F.derivatives() == 0 here</span></div>
<div class="line"><a id="l02302" name="l02302"></a><span class="lineno"> 2302</span>            Real dxi1 = -F.value() / F.derivatives();</div>
<div class="line"><a id="l02303" name="l02303"></a><span class="lineno"> 2303</span> </div>
<div class="line"><a id="l02304" name="l02304"></a><span class="lineno"> 2304</span>            xi1_dn += dxi1;</div>
<div class="line"><a id="l02305" name="l02305"></a><span class="lineno"> 2305</span> </div>
<div class="line"><a id="l02306" name="l02306"></a><span class="lineno"> 2306</span>            normals = 0;</div>
<div class="line"><a id="l02307" name="l02307"></a><span class="lineno"> 2307</span>          } <span class="keywordflow">while</span> (++current_iterate &lt; max_iterates);</div>
<div class="line"><a id="l02308" name="l02308"></a><span class="lineno"> 2308</span> </div>
<div class="line"><a id="l02309" name="l02309"></a><span class="lineno"> 2309</span>          Real xi1 = xi1_dn.value();</div>
<div class="line"><a id="l02310" name="l02310"></a><span class="lineno"> 2310</span> </div>
<div class="line"><a id="l02311" name="l02311"></a><span class="lineno"> 2311</span>          <span class="comment">// Check for convergence to a valid solution... The last condition checks for obliqueness</span></div>
<div class="line"><a id="l02312" name="l02312"></a><span class="lineno"> 2312</span>          <span class="comment">// of the projection</span></div>
<div class="line"><a id="l02313" name="l02313"></a><span class="lineno"> 2313</span>          <span class="keywordflow">if</span> ((current_iterate &lt; max_iterates) &amp;&amp; (std::abs(xi1) &lt;= 1. + <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a25f6f147b1b0a4b00e7c6739dd17b98c">_xi_tolerance</a>) &amp;&amp;</div>
<div class="line"><a id="l02314" name="l02314"></a><span class="lineno"> 2314</span>              (std::abs((primary_side_elem-&gt;point(0) - primary_side_elem-&gt;point(1)).unit() *</div>
<div class="line"><a id="l02315" name="l02315"></a><span class="lineno"> 2315</span>                        <a class="code hl_function" href="namespaceMetaPhysicL.html#a1c0a19c861d5f7813f7fb6825d8fe146">MetaPhysicL::raw_value</a>(normals).unit()) &lt;</div>
<div class="line"><a id="l02316" name="l02316"></a><span class="lineno"> 2316</span>               std::cos(<a class="code hl_variable" href="classAutomaticMortarGeneration.html#af5ca257dd4090b3a8d801a439dcae0ca">_minimum_projection_angle</a> * libMesh::pi / 180.0)))</div>
<div class="line"><a id="l02317" name="l02317"></a><span class="lineno"> 2317</span>          {</div>
<div class="line"><a id="l02318" name="l02318"></a><span class="lineno"> 2318</span>            <span class="keywordflow">if</span> (std::abs(std::abs(xi1) - 1.) &lt; <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a25f6f147b1b0a4b00e7c6739dd17b98c">_xi_tolerance</a>)</div>
<div class="line"><a id="l02319" name="l02319"></a><span class="lineno"> 2319</span>            {</div>
<div class="line"><a id="l02320" name="l02320"></a><span class="lineno"> 2320</span>              <span class="comment">// Special case: xi1=+/-1.</span></div>
<div class="line"><a id="l02321" name="l02321"></a><span class="lineno"> 2321</span>              <span class="comment">// It is unlikely that we get here, because this primary node should already</span></div>
<div class="line"><a id="l02322" name="l02322"></a><span class="lineno"> 2322</span>              <span class="comment">// have been mapped during the project_secondary_nodes() routine, but</span></div>
<div class="line"><a id="l02323" name="l02323"></a><span class="lineno"> 2323</span>              <span class="comment">// there is still a chance since the tolerances are applied to</span></div>
<div class="line"><a id="l02324" name="l02324"></a><span class="lineno"> 2324</span>              <span class="comment">// the xi coordinate and that value may be different on a primary element and a</span></div>
<div class="line"><a id="l02325" name="l02325"></a><span class="lineno"> 2325</span>              <span class="comment">// secondary element since they may have different sizes.</span></div>
<div class="line"><a id="l02326" name="l02326"></a><span class="lineno"> 2326</span>              <span class="keywordflow">throw</span> <a class="code hl_class" href="classMooseException.html">MooseException</a>(<span class="stringliteral">&quot;Nodes on primary and secondary surfaces are aligned. This is &quot;</span></div>
<div class="line"><a id="l02327" name="l02327"></a><span class="lineno"> 2327</span>                                   <span class="stringliteral">&quot;causing trouble when identifying projections from secondary &quot;</span></div>
<div class="line"><a id="l02328" name="l02328"></a><span class="lineno"> 2328</span>                                   <span class="stringliteral">&quot;nodes when performing primary node projections.&quot;</span>);</div>
<div class="line"><a id="l02329" name="l02329"></a><span class="lineno"> 2329</span>            }</div>
<div class="line"><a id="l02330" name="l02330"></a><span class="lineno"> 2330</span>            <span class="keywordflow">else</span> <span class="comment">// somewhere in the middle of the Elem</span></div>
<div class="line"><a id="l02331" name="l02331"></a><span class="lineno"> 2331</span>            {</div>
<div class="line"><a id="l02332" name="l02332"></a><span class="lineno"> 2332</span>              <span class="comment">// Add entry to primary_node_and_elem_to_xi1_secondary_elem</span></div>
<div class="line"><a id="l02333" name="l02333"></a><span class="lineno"> 2333</span>              <span class="comment">//</span></div>
<div class="line"><a id="l02334" name="l02334"></a><span class="lineno"> 2334</span>              <span class="comment">// Note: we originally duplicated the map values for the keys (node, left_neighbor)</span></div>
<div class="line"><a id="l02335" name="l02335"></a><span class="lineno"> 2335</span>              <span class="comment">// and (node, right_neighbor) but I don&#39;t think that should be necessary. Instead we</span></div>
<div class="line"><a id="l02336" name="l02336"></a><span class="lineno"> 2336</span>              <span class="comment">// just do it for neighbor 0, but really maybe we don&#39;t even need to do that since</span></div>
<div class="line"><a id="l02337" name="l02337"></a><span class="lineno"> 2337</span>              <span class="comment">// we can always look up the neighbors later given the Node... keeping it like this</span></div>
<div class="line"><a id="l02338" name="l02338"></a><span class="lineno"> 2338</span>              <span class="comment">// helps to maintain the &quot;symmetry&quot; of the two containers.</span></div>
<div class="line"><a id="l02339" name="l02339"></a><span class="lineno"> 2339</span>              <span class="keyword">const</span> Elem * neigh = primary_node_neighbors[0];</div>
<div class="line"><a id="l02340" name="l02340"></a><span class="lineno"> 2340</span>              <span class="keywordflow">for</span> (MooseIndex(neigh-&gt;n_vertices()) nid = 0; nid &lt; neigh-&gt;n_vertices(); ++nid)</div>
<div class="line"><a id="l02341" name="l02341"></a><span class="lineno"> 2341</span>              {</div>
<div class="line"><a id="l02342" name="l02342"></a><span class="lineno"> 2342</span>                <span class="keyword">const</span> Node * neigh_node = neigh-&gt;node_ptr(nid);</div>
<div class="line"><a id="l02343" name="l02343"></a><span class="lineno"> 2343</span>                <span class="keywordflow">if</span> (primary_node == neigh_node)</div>
<div class="line"><a id="l02344" name="l02344"></a><span class="lineno"> 2344</span>                {</div>
<div class="line"><a id="l02345" name="l02345"></a><span class="lineno"> 2345</span>                  <span class="keyword">auto</span> key = std::make_tuple(neigh_node-&gt;id(), neigh_node, neigh);</div>
<div class="line"><a id="l02346" name="l02346"></a><span class="lineno"> 2346</span>                  <span class="keyword">auto</span> val = std::make_pair(xi1, secondary_elem_candidate);</div>
<div class="line"><a id="l02347" name="l02347"></a><span class="lineno"> 2347</span>                  <a class="code hl_variable" href="classAutomaticMortarGeneration.html#ac174eedb02e9681baf439360903700d4">_primary_node_and_elem_to_xi1_secondary_elem</a>.emplace(key, val);</div>
<div class="line"><a id="l02348" name="l02348"></a><span class="lineno"> 2348</span>                }</div>
<div class="line"><a id="l02349" name="l02349"></a><span class="lineno"> 2349</span>              }</div>
<div class="line"><a id="l02350" name="l02350"></a><span class="lineno"> 2350</span>            }</div>
<div class="line"><a id="l02351" name="l02351"></a><span class="lineno"> 2351</span> </div>
<div class="line"><a id="l02352" name="l02352"></a><span class="lineno"> 2352</span>            projection_succeeded = <span class="keyword">true</span>;</div>
<div class="line"><a id="l02353" name="l02353"></a><span class="lineno"> 2353</span>            <span class="keywordflow">break</span>; <span class="comment">// out of e-loop</span></div>
<div class="line"><a id="l02354" name="l02354"></a><span class="lineno"> 2354</span>          }</div>
<div class="line"><a id="l02355" name="l02355"></a><span class="lineno"> 2355</span>          <span class="keywordflow">else</span></div>
<div class="line"><a id="l02356" name="l02356"></a><span class="lineno"> 2356</span>          {</div>
<div class="line"><a id="l02357" name="l02357"></a><span class="lineno"> 2357</span>            <span class="comment">// The current primary_point is not in this Elem, so keep track of the rejects.</span></div>
<div class="line"><a id="l02358" name="l02358"></a><span class="lineno"> 2358</span>            rejected_secondary_elem_candidates.insert(secondary_elem_candidate);</div>
<div class="line"><a id="l02359" name="l02359"></a><span class="lineno"> 2359</span>          }</div>
<div class="line"><a id="l02360" name="l02360"></a><span class="lineno"> 2360</span>        } <span class="comment">// end e-loop over candidate elems</span></div>
<div class="line"><a id="l02361" name="l02361"></a><span class="lineno"> 2361</span> </div>
<div class="line"><a id="l02362" name="l02362"></a><span class="lineno"> 2362</span>        <span class="keywordflow">if</span> (projection_succeeded)</div>
<div class="line"><a id="l02363" name="l02363"></a><span class="lineno"> 2363</span>          <span class="keywordflow">break</span>; <span class="comment">// out of r-loop</span></div>
<div class="line"><a id="l02364" name="l02364"></a><span class="lineno"> 2364</span>      }          <span class="comment">// r-loop</span></div>
<div class="line"><a id="l02365" name="l02365"></a><span class="lineno"> 2365</span> </div>
<div class="line"><a id="l02366" name="l02366"></a><span class="lineno"> 2366</span>      <span class="keywordflow">if</span> (!projection_succeeded &amp;&amp; <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a958de5b754ec676f463c50d2f16b5d0c">_debug</a>)</div>
<div class="line"><a id="l02367" name="l02367"></a><span class="lineno"> 2367</span>      {</div>
<div class="line"><a id="l02368" name="l02368"></a><span class="lineno"> 2368</span>        <a class="code hl_variable" href="classConsoleStreamInterface.html#acd1f259e7a3d200223164c08af3a7c13">_console</a> &lt;&lt; <span class="stringliteral">&quot;Failed to find point from which primary node &quot;</span></div>
<div class="line"><a id="l02369" name="l02369"></a><span class="lineno"> 2369</span>                 &lt;&lt; <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>Point &amp;<span class="keyword">&gt;</span>(*primary_node) &lt;&lt; <span class="stringliteral">&quot; was projected.&quot;</span> &lt;&lt; std::endl</div>
<div class="line"><a id="l02370" name="l02370"></a><span class="lineno"> 2370</span>                 &lt;&lt; std::endl;</div>
<div class="line"><a id="l02371" name="l02371"></a><span class="lineno"> 2371</span>      }</div>
<div class="line"><a id="l02372" name="l02372"></a><span class="lineno"> 2372</span>    } <span class="comment">// loop over side nodes</span></div>
<div class="line"><a id="l02373" name="l02373"></a><span class="lineno"> 2373</span>  }   <span class="comment">// end loop over elements for finding where primary points would have projected from.</span></div>
<div class="line"><a id="l02374" name="l02374"></a><span class="lineno"> 2374</span>}</div>
<div class="line"><a id="l02375" name="l02375"></a><span class="lineno"> 2375</span> </div>
<div class="line"><a id="l02376" name="l02376"></a><span class="lineno"> 2376</span>std::vector&lt;AutomaticMortarGeneration::MortarFilterIter&gt;</div>
<div class="line"><a id="l02377" name="l02377"></a><span class="lineno"><a class="line" href="classAutomaticMortarGeneration.html#a3b69cbfeaf6799a4094c8ca1676759d6"> 2377</a></span><a class="code hl_function" href="classAutomaticMortarGeneration.html#af11d3acd4a241fb531e4fa9ef227f469">AutomaticMortarGeneration::secondariesToMortarSegments</a>(<span class="keyword">const</span> Node &amp; node)<span class="keyword"> const</span></div>
<div class="line"><a id="l02378" name="l02378"></a><span class="lineno"> 2378</span><span class="keyword"></span>{</div>
<div class="line"><a id="l02379" name="l02379"></a><span class="lineno"> 2379</span>  <span class="keyword">auto</span> secondary_it = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a1ad443aa196d2c81d195b29ddeee1d5e">_nodes_to_secondary_elem_map</a>.find(node.id());</div>
<div class="line"><a id="l02380" name="l02380"></a><span class="lineno"> 2380</span>  <span class="keywordflow">if</span> (secondary_it == <a class="code hl_variable" href="classAutomaticMortarGeneration.html#a1ad443aa196d2c81d195b29ddeee1d5e">_nodes_to_secondary_elem_map</a>.end())</div>
<div class="line"><a id="l02381" name="l02381"></a><span class="lineno"> 2381</span>    <span class="keywordflow">return</span> {};</div>
<div class="line"><a id="l02382" name="l02382"></a><span class="lineno"> 2382</span> </div>
<div class="line"><a id="l02383" name="l02383"></a><span class="lineno"> 2383</span>  <span class="keyword">const</span> <span class="keyword">auto</span> &amp; secondary_elems = secondary_it-&gt;second;</div>
<div class="line"><a id="l02384" name="l02384"></a><span class="lineno"> 2384</span>  std::vector&lt;MortarFilterIter&gt; ret;</div>
<div class="line"><a id="l02385" name="l02385"></a><span class="lineno"> 2385</span>  ret.reserve(secondary_elems.size());</div>
<div class="line"><a id="l02386" name="l02386"></a><span class="lineno"> 2386</span> </div>
<div class="line"><a id="l02387" name="l02387"></a><span class="lineno"> 2387</span>  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : index_range(secondary_elems))</div>
<div class="line"><a id="l02388" name="l02388"></a><span class="lineno"> 2388</span>  {</div>
<div class="line"><a id="l02389" name="l02389"></a><span class="lineno"> 2389</span>    <span class="keyword">auto</span> * <span class="keyword">const</span> secondary_elem = secondary_elems[i];</div>
<div class="line"><a id="l02390" name="l02390"></a><span class="lineno"> 2390</span>    <span class="keyword">auto</span> msm_it = <a class="code hl_variable" href="classAutomaticMortarGeneration.html#af0da3b7d9e404238718805e12452d74d">_secondary_elems_to_mortar_segments</a>.find(secondary_elem-&gt;id());</div>
<div class="line"><a id="l02391" name="l02391"></a><span class="lineno"> 2391</span>    <span class="keywordflow">if</span> (msm_it == <a class="code hl_variable" href="classAutomaticMortarGeneration.html#af0da3b7d9e404238718805e12452d74d">_secondary_elems_to_mortar_segments</a>.end())</div>
<div class="line"><a id="l02392" name="l02392"></a><span class="lineno"> 2392</span>      <span class="comment">// We may have removed this element key from this map</span></div>
<div class="line"><a id="l02393" name="l02393"></a><span class="lineno"> 2393</span>      <span class="keywordflow">continue</span>;</div>
<div class="line"><a id="l02394" name="l02394"></a><span class="lineno"> 2394</span> </div>
<div class="line"><a id="l02395" name="l02395"></a><span class="lineno"> 2395</span>    mooseAssert(secondary_elem-&gt;active(),</div>
<div class="line"><a id="l02396" name="l02396"></a><span class="lineno"> 2396</span>                <span class="stringliteral">&quot;We loop over active elements when building the mortar segment mesh, so we golly &quot;</span></div>
<div class="line"><a id="l02397" name="l02397"></a><span class="lineno"> 2397</span>                <span class="stringliteral">&quot;well hope this is active.&quot;</span>);</div>
<div class="line"><a id="l02398" name="l02398"></a><span class="lineno"> 2398</span>    mooseAssert(!msm_it-&gt;second.empty(),</div>
<div class="line"><a id="l02399" name="l02399"></a><span class="lineno"> 2399</span>                <span class="stringliteral">&quot;We should have removed all secondaries from this map if they do not have any &quot;</span></div>
<div class="line"><a id="l02400" name="l02400"></a><span class="lineno"> 2400</span>                <span class="stringliteral">&quot;mortar segments associated with them.&quot;</span>);</div>
<div class="line"><a id="l02401" name="l02401"></a><span class="lineno"> 2401</span>    ret.push_back(msm_it);</div>
<div class="line"><a id="l02402" name="l02402"></a><span class="lineno"> 2402</span>  }</div>
<div class="line"><a id="l02403" name="l02403"></a><span class="lineno"> 2403</span> </div>
<div class="line"><a id="l02404" name="l02404"></a><span class="lineno"> 2404</span>  <span class="keywordflow">return</span> ret;</div>
<div class="line"><a id="l02405" name="l02405"></a><span class="lineno"> 2405</span>}</div>
<div class="ttc" id="aAutomaticMortarGeneration_8h_html"><div class="ttname"><a href="AutomaticMortarGeneration_8h.html">AutomaticMortarGeneration.h</a></div></div>
<div class="ttc" id="aAutomaticMortarGeneration_8h_html_afb1ef82fea6170b578d48ad9cd793486"><div class="ttname"><a href="AutomaticMortarGeneration_8h.html#afb1ef82fea6170b578d48ad9cd793486">SubdomainID</a></div><div class="ttdeci">subdomain_id_type SubdomainID</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00050">AutomaticMortarGeneration.h:50</a></div></div>
<div class="ttc" id="aDisplacedProblem_8h_html"><div class="ttname"><a href="DisplacedProblem_8h.html">DisplacedProblem.h</a></div></div>
<div class="ttc" id="aFEProblemBase_8h_html"><div class="ttname"><a href="FEProblemBase_8h.html">FEProblemBase.h</a></div></div>
<div class="ttc" id="aFormattedTable_8h_html"><div class="ttname"><a href="FormattedTable_8h.html">FormattedTable.h</a></div></div>
<div class="ttc" id="aMooseError_8h_html"><div class="ttname"><a href="MooseError_8h.html">MooseError.h</a></div></div>
<div class="ttc" id="aMooseError_8h_html_a3d351254665674621ecbd38f57bb28ae"><div class="ttname"><a href="MooseError_8h.html#a3d351254665674621ecbd38f57bb28ae">mooseWarning</a></div><div class="ttdeci">void mooseWarning(Args &amp;&amp;... args)</div><div class="ttdoc">Emit a warning message with the given stringified, concatenated args.</div><div class="ttdef"><b>Definition:</b> <a href="MooseError_8h_source.html#l00296">MooseError.h:296</a></div></div>
<div class="ttc" id="aMooseError_8h_html_aa959168eed29caa7aaa85ffc1319a9ad"><div class="ttname"><a href="MooseError_8h.html#aa959168eed29caa7aaa85ffc1319a9ad">mooseError</a></div><div class="ttdeci">void mooseError(Args &amp;&amp;... args)</div><div class="ttdoc">Emit an error message with the given stringified, concatenated args and terminate the application.</div><div class="ttdef"><b>Definition:</b> <a href="MooseError_8h_source.html#l00284">MooseError.h:284</a></div></div>
<div class="ttc" id="aMooseLagrangeHelpers_8h_html"><div class="ttname"><a href="MooseLagrangeHelpers_8h.html">MooseLagrangeHelpers.h</a></div></div>
<div class="ttc" id="aMooseTypes_8h_html"><div class="ttname"><a href="MooseTypes_8h.html">MooseTypes.h</a></div></div>
<div class="ttc" id="aMortarSegmentHelper_8h_html"><div class="ttname"><a href="MortarSegmentHelper_8h.html">MortarSegmentHelper.h</a></div></div>
<div class="ttc" id="aMortarSegmentInfo_8h_html"><div class="ttname"><a href="MortarSegmentInfo_8h.html">MortarSegmentInfo.h</a></div></div>
<div class="ttc" id="aNanoflannMeshAdaptor_8h_html"><div class="ttname"><a href="NanoflannMeshAdaptor_8h.html">NanoflannMeshAdaptor.h</a></div></div>
<div class="ttc" id="aNanoflannMeshAdaptor_8h_html_a3a70df33047194961ce21a0133717038"><div class="ttname"><a href="NanoflannMeshAdaptor_8h.html#a3a70df33047194961ce21a0133717038">subdomain_kd_tree_t</a></div><div class="ttdeci">nanoflann::KDTreeSingleIndexAdaptor&lt; subdomain_adatper_t, NanoflannMeshSubdomainAdaptor&lt; 3 &gt;, 3 &gt; subdomain_kd_tree_t</div><div class="ttdef"><b>Definition:</b> <a href="NanoflannMeshAdaptor_8h_source.html#l00209">NanoflannMeshAdaptor.h:209</a></div></div>
<div class="ttc" id="aOutput_8h_html"><div class="ttname"><a href="Output_8h.html">Output.h</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html"><div class="ttname"><a href="classAutomaticMortarGeneration.html">AutomaticMortarGeneration</a></div><div class="ttdoc">This class is a container/interface for the objects involved in automatic generation of mortar spaces...</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00056">AutomaticMortarGeneration.h:57</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a02fad9659b03bfd39cc92b30a4a988d6"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a02fad9659b03bfd39cc92b30a4a988d6">AutomaticMortarGeneration::getSecondaryLowerdElemFromSecondaryElem</a></div><div class="ttdeci">const Elem * getSecondaryLowerdElemFromSecondaryElem(dof_id_type secondary_elem_id) const</div><div class="ttdoc">Return lower dimensional secondary element given its interior parent.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8C_source.html#l00332">AutomaticMortarGeneration.C:332</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a04e775677691747d25e1a5f05496fa5a"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a04e775677691747d25e1a5f05496fa5a">AutomaticMortarGeneration::_newton_tolerance</a></div><div class="ttdeci">Real _newton_tolerance</div><div class="ttdoc">Newton solve tolerance for node projections.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00490">AutomaticMortarGeneration.h:490</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a06fb539aea2e63f3b48a6e1d41a2f568"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a06fb539aea2e63f3b48a6e1d41a2f568">AutomaticMortarGeneration::_secondary_node_to_nodal_normal</a></div><div class="ttdeci">std::unordered_map&lt; const Node *, Point &gt; _secondary_node_to_nodal_normal</div><div class="ttdoc">Container for storing the nodal normal vector associated with each secondary node.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00430">AutomaticMortarGeneration.h:430</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a169550fc1a82fca976e386edae0d254d"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a169550fc1a82fca976e386edae0d254d">AutomaticMortarGeneration::_lower_elem_to_side_id</a></div><div class="ttdeci">std::unordered_map&lt; const Elem *, unsigned int &gt; _lower_elem_to_side_id</div><div class="ttdoc">Keeps track of the mapping between lower-dimensional elements and the side_id of the interior_parent ...</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00408">AutomaticMortarGeneration.h:408</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a1ad443aa196d2c81d195b29ddeee1d5e"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a1ad443aa196d2c81d195b29ddeee1d5e">AutomaticMortarGeneration::_nodes_to_secondary_elem_map</a></div><div class="ttdeci">std::unordered_map&lt; dof_id_type, std::vector&lt; const Elem * &gt; &gt; _nodes_to_secondary_elem_map</div><div class="ttdoc">Map from nodes to connected lower-dimensional elements on the secondary/primary subdomains.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00366">AutomaticMortarGeneration.h:366</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a1d4166e27bcb186c75c320b232652cf1"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a1d4166e27bcb186c75c320b232652cf1">AutomaticMortarGeneration::_secondary_requested_boundary_ids</a></div><div class="ttdeci">std::set&lt; BoundaryID &gt; _secondary_requested_boundary_ids</div><div class="ttdoc">The boundary ids corresponding to all the secondary surfaces.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00356">AutomaticMortarGeneration.h:356</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a1ee9b6e4f8bd88603e22117085758f70"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a1ee9b6e4f8bd88603e22117085758f70">AutomaticMortarGeneration::_nodes_to_primary_elem_map</a></div><div class="ttdeci">std::unordered_map&lt; dof_id_type, std::vector&lt; const Elem * &gt; &gt; _nodes_to_primary_elem_map</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00367">AutomaticMortarGeneration.h:367</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a25f6f147b1b0a4b00e7c6739dd17b98c"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a25f6f147b1b0a4b00e7c6739dd17b98c">AutomaticMortarGeneration::_xi_tolerance</a></div><div class="ttdeci">Real _xi_tolerance</div><div class="ttdoc">Tolerance for checking projection xi values.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00495">AutomaticMortarGeneration.h:495</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a2d9c7320cc6d9a995eaee8bd021397b7"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a2d9c7320cc6d9a995eaee8bd021397b7">AutomaticMortarGeneration::computeNodalGeometry</a></div><div class="ttdeci">void computeNodalGeometry()</div><div class="ttdoc">Computes and stores the nodal normal/tangent vectors in a local data structure instead of using the E...</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8C_source.html#l01709">AutomaticMortarGeneration.C:1709</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a345cd37f09eebfb0b829c15f7fd4a441"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a345cd37f09eebfb0b829c15f7fd4a441">AutomaticMortarGeneration::msmStatistics</a></div><div class="ttdeci">void msmStatistics()</div><div class="ttdoc">Outputs mesh statistics for mortar segment mesh.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8C_source.html#l01421">AutomaticMortarGeneration.C:1421</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a36e1a5b919de8cfdc39c8af4098fb450"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a36e1a5b919de8cfdc39c8af4098fb450">AutomaticMortarGeneration::_primary_secondary_boundary_id_pairs</a></div><div class="ttdeci">std::vector&lt; std::pair&lt; BoundaryID, BoundaryID &gt; &gt; _primary_secondary_boundary_id_pairs</div><div class="ttdoc">A list of primary/secondary boundary id pairs corresponding to each side of the mortar interface.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00363">AutomaticMortarGeneration.h:363</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a3a19330f38987cd9318f38d932c5a2ad"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a3a19330f38987cd9318f38d932c5a2ad">AutomaticMortarGeneration::_output_params</a></div><div class="ttdeci">std::unique_ptr&lt; InputParameters &gt; _output_params</div><div class="ttdoc">Storage for the input parameters used by the mortar nodal geometry output.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00508">AutomaticMortarGeneration.h:508</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a3a49a5fc49ca76d1e89b938d3b3a202e"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a3a49a5fc49ca76d1e89b938d3b3a202e">AutomaticMortarGeneration::buildMortarSegmentMesh</a></div><div class="ttdeci">void buildMortarSegmentMesh()</div><div class="ttdoc">Builds the mortar segment mesh once the secondary and primary node projections have been completed.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8C_source.html#l00433">AutomaticMortarGeneration.C:433</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a3c757e0025c7dbfb78485e79067fb138"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a3c757e0025c7dbfb78485e79067fb138">AutomaticMortarGeneration::_inactive_local_lm_nodes</a></div><div class="ttdeci">std::unordered_set&lt; const Node * &gt; _inactive_local_lm_nodes</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00440">AutomaticMortarGeneration.h:440</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a509e5164f1c4cd0f981eaa901c37c632"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a509e5164f1c4cd0f981eaa901c37c632">AutomaticMortarGeneration::_periodic</a></div><div class="ttdeci">const bool _periodic</div><div class="ttdoc">Whether this object will be generating a mortar segment mesh for periodic constraints.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00484">AutomaticMortarGeneration.h:484</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a51ac6050a6f320045d286c92bffba156"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a51ac6050a6f320045d286c92bffba156">AutomaticMortarGeneration::projectSecondaryNodes</a></div><div class="ttdeci">void projectSecondaryNodes()</div><div class="ttdoc">Project secondary nodes (find xi^(2) values) to the closest points on the primary surface.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8C_source.html#l01848">AutomaticMortarGeneration.C:1848</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a533e6ee50c2892de7d5e436f524bcb83"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a533e6ee50c2892de7d5e436f524bcb83">AutomaticMortarGeneration::buildMortarSegmentMesh3d</a></div><div class="ttdeci">void buildMortarSegmentMesh3d()</div><div class="ttdoc">Builds the mortar segment mesh once the secondary and primary node projections have been completed.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8C_source.html#l00930">AutomaticMortarGeneration.C:930</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a545496202789a72da1ffc639dedf322a"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a545496202789a72da1ffc639dedf322a">AutomaticMortarGeneration::computeInactiveLMElems</a></div><div class="ttdeci">void computeInactiveLMElems()</div><div class="ttdoc">Get list of secondary elems without any corresponding primary elements.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8C_source.html#l01661">AutomaticMortarGeneration.C:1661</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a59c6fd297125023195e7bfb3714846c5"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a59c6fd297125023195e7bfb3714846c5">AutomaticMortarGeneration::_secondary_boundary_subdomain_ids</a></div><div class="ttdeci">std::set&lt; SubdomainID &gt; _secondary_boundary_subdomain_ids</div><div class="ttdoc">The secondary/primary lower-dimensional boundary subdomain ids are the secondary/primary boundary ids...</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00416">AutomaticMortarGeneration.h:416</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a689b49e6bae35fa2ba975b844c4ec82e"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a689b49e6bae35fa2ba975b844c4ec82e">AutomaticMortarGeneration::_correct_edge_dropping</a></div><div class="ttdeci">const bool _correct_edge_dropping</div><div class="ttdoc">Flag to enable regressed treatment of edge dropping where all LM DoFs on edge dropping element are st...</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00499">AutomaticMortarGeneration.h:499</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a6dfaa66a5dc83c679a3c4dd7aa0bf1ab"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a6dfaa66a5dc83c679a3c4dd7aa0bf1ab">AutomaticMortarGeneration::buildCouplingInformation</a></div><div class="ttdeci">void buildCouplingInformation()</div><div class="ttdoc">build the _mortar_interface_coupling data</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8C_source.html#l01350">AutomaticMortarGeneration.C:1350</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a71119b033756571f4345f912300b182d"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a71119b033756571f4345f912300b182d">AutomaticMortarGeneration::householderOrthogolization</a></div><div class="ttdeci">void householderOrthogolization(const Point &amp;normal, Point &amp;tangent_one, Point &amp;tangent_two) const</div><div class="ttdoc">Householder orthogonalization procedure to obtain proper basis for tangent and binormal vectors.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8C_source.html#l01802">AutomaticMortarGeneration.C:1802</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a71eb5cecb4437a9a0edfe8d5ce38007e"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a71eb5cecb4437a9a0edfe8d5ce38007e">AutomaticMortarGeneration::getNormals</a></div><div class="ttdeci">std::vector&lt; Point &gt; getNormals(const Elem &amp;secondary_elem, const std::vector&lt; Point &gt; &amp;xi1_pts) const</div><div class="ttdoc">Compute the normals at given reference points on a secondary element.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8C_source.html#l00404">AutomaticMortarGeneration.C:404</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a7254faea651acd63b60b408ab560a0e5"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a7254faea651acd63b60b408ab560a0e5">AutomaticMortarGeneration::_secondary_ip_sub_ids</a></div><div class="ttdeci">std::set&lt; SubdomainID &gt; _secondary_ip_sub_ids</div><div class="ttdoc">All the secondary interior parent subdomain IDs associated with the mortar mesh.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00452">AutomaticMortarGeneration.h:452</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a7b7d494bc9dfe051e07cbbdeacc9a28d"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a7b7d494bc9dfe051e07cbbdeacc9a28d">AutomaticMortarGeneration::initOutput</a></div><div class="ttdeci">void initOutput()</div><div class="ttdoc">initialize mortar-mesh based output</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8C_source.html#l00247">AutomaticMortarGeneration.C:247</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a8120c89f18fdff39621fa512087a2da3"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a8120c89f18fdff39621fa512087a2da3">AutomaticMortarGeneration::_secondary_node_to_hh_nodal_tangents</a></div><div class="ttdeci">std::unordered_map&lt; const Node *, std::array&lt; Point, 2 &gt; &gt; _secondary_node_to_hh_nodal_tangents</div><div class="ttdoc">Container for storing the nodal tangent/binormal vectors associated with each secondary node (Househo...</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00434">AutomaticMortarGeneration.h:434</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a8aa99d7524d7b1ae972fe152fd0dc61e"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a8aa99d7524d7b1ae972fe152fd0dc61e">AutomaticMortarGeneration::projectSecondaryNodesSinglePair</a></div><div class="ttdeci">void projectSecondaryNodesSinglePair(SubdomainID lower_dimensional_primary_subdomain_id, SubdomainID lower_dimensional_secondary_subdomain_id)</div><div class="ttdoc">Helper function responsible for projecting secondary nodes onto primary elements for a single primary...</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8C_source.html#l01857">AutomaticMortarGeneration.C:1857</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a933e2cc029eab5574d2afcac61acf4e7"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a933e2cc029eab5574d2afcac61acf4e7">AutomaticMortarGeneration::_mesh</a></div><div class="ttdeci">MeshBase &amp; _mesh</div><div class="ttdoc">Reference to the mesh stored in equation_systems.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00353">AutomaticMortarGeneration.h:353</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a958de5b754ec676f463c50d2f16b5d0c"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a958de5b754ec676f463c50d2f16b5d0c">AutomaticMortarGeneration::_debug</a></div><div class="ttdeci">const bool _debug</div><div class="ttdoc">Whether to print debug output.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00478">AutomaticMortarGeneration.h:478</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a969d4ab038fc8d447e966cd1e1600091"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a969d4ab038fc8d447e966cd1e1600091">AutomaticMortarGeneration::_primary_secondary_subdomain_id_pairs</a></div><div class="ttdeci">std::vector&lt; std::pair&lt; SubdomainID, SubdomainID &gt; &gt; _primary_secondary_subdomain_id_pairs</div><div class="ttdoc">A list of primary/secondary subdomain id pairs corresponding to each side of the mortar interface.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00412">AutomaticMortarGeneration.h:412</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a9a41db0dea91a39a5ec0e1356b544d23"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a9a41db0dea91a39a5ec0e1356b544d23">AutomaticMortarGeneration::getSecondaryIpToLowerElementMap</a></div><div class="ttdeci">std::map&lt; unsigned int, unsigned int &gt; getSecondaryIpToLowerElementMap(const Elem &amp;lower_secondary_elem) const</div><div class="ttdoc">Compute on-the-fly mapping from secondary interior parent nodes to lower dimensional nodes.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8C_source.html#l00342">AutomaticMortarGeneration.C:342</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a9b366747e19933f0beae2fbb9c0d969b"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a9b366747e19933f0beae2fbb9c0d969b">AutomaticMortarGeneration::buildNodeToElemMaps</a></div><div class="ttdeci">void buildNodeToElemMaps()</div><div class="ttdoc">Once the secondary_requested_boundary_ids and primary_requested_boundary_ids containers have been fil...</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8C_source.html#l00284">AutomaticMortarGeneration.C:284</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a9c3bb17ea3f054b18cc8044bb10d55d9"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a9c3bb17ea3f054b18cc8044bb10d55d9">AutomaticMortarGeneration::_mortar_segment_mesh</a></div><div class="ttdeci">std::unique_ptr&lt; MeshBase &gt; _mortar_segment_mesh</div><div class="ttdoc">1D Mesh of mortar segment elements which gets built by the call to build_mortar_segment_mesh().</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00399">AutomaticMortarGeneration.h:399</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_a9f5f8acc9b0a8749aaa3d0f32302c8a6"><div class="ttname"><a href="classAutomaticMortarGeneration.html#a9f5f8acc9b0a8749aaa3d0f32302c8a6">AutomaticMortarGeneration::AutomaticMortarGeneration</a></div><div class="ttdeci">AutomaticMortarGeneration(MooseApp &amp;app, MeshBase &amp;mesh_in, const std::pair&lt; BoundaryID, BoundaryID &gt; &amp;boundary_key, const std::pair&lt; SubdomainID, SubdomainID &gt; &amp;subdomain_key, bool on_displaced, bool periodic, const bool debug, const bool correct_edge_dropping, const Real minimum_projection_angle)</div><div class="ttdoc">Must be constructed with a reference to the Mesh we are generating mortar spaces for.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8C_source.html#l00213">AutomaticMortarGeneration.C:213</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_aa871943ba7a8761cc220e90af9c716a0"><div class="ttname"><a href="classAutomaticMortarGeneration.html#aa871943ba7a8761cc220e90af9c716a0">AutomaticMortarGeneration::clear</a></div><div class="ttdeci">void clear()</div><div class="ttdoc">Clears the mortar segment mesh and accompanying data structures.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8C_source.html#l00265">AutomaticMortarGeneration.C:265</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_aaad114f9251de54152c04ef277441578"><div class="ttname"><a href="classAutomaticMortarGeneration.html#aaad114f9251de54152c04ef277441578">AutomaticMortarGeneration::_app</a></div><div class="ttdeci">MooseApp &amp; _app</div><div class="ttdoc">The Moose app.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00350">AutomaticMortarGeneration.h:350</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_ab2357a3aacfa2cae90078e3b6293bf26"><div class="ttname"><a href="classAutomaticMortarGeneration.html#ab2357a3aacfa2cae90078e3b6293bf26">AutomaticMortarGeneration::_mortar_interface_coupling</a></div><div class="ttdeci">std::unordered_map&lt; dof_id_type, std::unordered_set&lt; dof_id_type &gt; &gt; _mortar_interface_coupling</div><div class="ttdoc">Used by the AugmentSparsityOnInterface functor to determine whether a given Elem is coupled to any ot...</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00427">AutomaticMortarGeneration.h:427</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_ab8f33d0072ce0d896b4f058980640488"><div class="ttname"><a href="classAutomaticMortarGeneration.html#ab8f33d0072ce0d896b4f058980640488">AutomaticMortarGeneration::getPrimaryIpToLowerElementMap</a></div><div class="ttdeci">std::map&lt; unsigned int, unsigned int &gt; getPrimaryIpToLowerElementMap(const Elem &amp;primary_elem, const Elem &amp;primary_elem_ip, const Elem &amp;lower_secondary_elem) const</div><div class="ttdoc">Compute on-the-fly mapping from primary interior parent nodes to its corresponding lower dimensional ...</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8C_source.html#l00358">AutomaticMortarGeneration.C:358</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_abb4cc3e3102675e52675a95347ad8e95"><div class="ttname"><a href="classAutomaticMortarGeneration.html#abb4cc3e3102675e52675a95347ad8e95">AutomaticMortarGeneration::_secondary_node_and_elem_to_xi2_primary_elem</a></div><div class="ttdeci">std::unordered_map&lt; std::pair&lt; const Node *, const Elem * &gt;, std::pair&lt; Real, const Elem * &gt; &gt; _secondary_node_and_elem_to_xi2_primary_elem</div><div class="ttdoc">Similar to the map above, but associates a (Secondary Node, Secondary Elem) pair to a (xi^(2),...</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00387">AutomaticMortarGeneration.h:387</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_abbd91d3cf8bef528976fe6f932622d2d"><div class="ttname"><a href="classAutomaticMortarGeneration.html#abbd91d3cf8bef528976fe6f932622d2d">AutomaticMortarGeneration::_msm_elem_to_info</a></div><div class="ttdeci">std::unordered_map&lt; const Elem *, MortarSegmentInfo &gt; _msm_elem_to_info</div><div class="ttdoc">Map between Elems in the mortar segment mesh and their info structs.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00404">AutomaticMortarGeneration.h:404</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_ac174eedb02e9681baf439360903700d4"><div class="ttname"><a href="classAutomaticMortarGeneration.html#ac174eedb02e9681baf439360903700d4">AutomaticMortarGeneration::_primary_node_and_elem_to_xi1_secondary_elem</a></div><div class="ttdeci">std::map&lt; std::tuple&lt; dof_id_type, const Node *, const Elem * &gt;, std::pair&lt; Real, const Elem * &gt; &gt; _primary_node_and_elem_to_xi1_secondary_elem</div><div class="ttdoc">Same type of container, but for mapping (Primary Node ID, Primary Node, Primary Elem) -&gt; (xi^(1),...</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00395">AutomaticMortarGeneration.h:395</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_ac1faa015bf0201e49ab822e50b713fc1"><div class="ttname"><a href="classAutomaticMortarGeneration.html#ac1faa015bf0201e49ab822e50b713fc1">AutomaticMortarGeneration::_on_displaced</a></div><div class="ttdeci">const bool _on_displaced</div><div class="ttdoc">Whether this object is on the displaced mesh.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00481">AutomaticMortarGeneration.h:481</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_ac3445ab0b94ce0dc9c01a1234321ebaa"><div class="ttname"><a href="classAutomaticMortarGeneration.html#ac3445ab0b94ce0dc9c01a1234321ebaa">AutomaticMortarGeneration::_inactive_local_lm_elems</a></div><div class="ttdeci">std::unordered_set&lt; const Elem * &gt; _inactive_local_lm_elems</div><div class="ttdoc">List of inactive lagrange multiplier nodes (for elemental variables)</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00443">AutomaticMortarGeneration.h:443</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_ac36806c971038a5d13d2e5ea2c9e7f54"><div class="ttname"><a href="classAutomaticMortarGeneration.html#ac36806c971038a5d13d2e5ea2c9e7f54">AutomaticMortarGeneration::computeIncorrectEdgeDroppingInactiveLMNodes</a></div><div class="ttdeci">void computeIncorrectEdgeDroppingInactiveLMNodes()</div><div class="ttdoc">Computes inactive secondary nodes when incorrect edge dropping behavior is enabled (any node touching...</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8C_source.html#l01485">AutomaticMortarGeneration.C:1485</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_ac4462365906bd50aeb9a76b07a5ff34d"><div class="ttname"><a href="classAutomaticMortarGeneration.html#ac4462365906bd50aeb9a76b07a5ff34d">AutomaticMortarGeneration::_distributed</a></div><div class="ttdeci">const bool _distributed</div><div class="ttdoc">Whether the mortar segment mesh is distributed.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00487">AutomaticMortarGeneration.h:487</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_ac9594ceb9068d6cf33b6e1ca2f5951fe"><div class="ttname"><a href="classAutomaticMortarGeneration.html#ac9594ceb9068d6cf33b6e1ca2f5951fe">AutomaticMortarGeneration::getNodalTangents</a></div><div class="ttdeci">std::array&lt; MooseUtils::SemidynamicVector&lt; Point, 9 &gt;, 2 &gt; getNodalTangents(const Elem &amp;secondary_elem) const</div><div class="ttdoc">Compute the two nodal tangents, which are built on-the-fly.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8C_source.html#l00375">AutomaticMortarGeneration.C:375</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_ac99e408cefd4da80efa2649ef1d32e93"><div class="ttname"><a href="classAutomaticMortarGeneration.html#ac99e408cefd4da80efa2649ef1d32e93">AutomaticMortarGeneration::_primary_ip_sub_ids</a></div><div class="ttdeci">std::set&lt; SubdomainID &gt; _primary_ip_sub_ids</div><div class="ttdoc">All the primary interior parent subdomain IDs associated with the mortar mesh.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00455">AutomaticMortarGeneration.h:455</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_acb676f79ae207404fb5d224ac768df42"><div class="ttname"><a href="classAutomaticMortarGeneration.html#acb676f79ae207404fb5d224ac768df42">AutomaticMortarGeneration::_secondary_element_to_secondary_lowerd_element</a></div><div class="ttdeci">std::unordered_map&lt; dof_id_type, const Elem * &gt; _secondary_element_to_secondary_lowerd_element</div><div class="ttdoc">Map from full dimensional secondary element id to lower dimensional secondary element.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00437">AutomaticMortarGeneration.h:437</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_acbe701da36a67d2d9546f9db735b1faf"><div class="ttname"><a href="classAutomaticMortarGeneration.html#acbe701da36a67d2d9546f9db735b1faf">AutomaticMortarGeneration::_primary_boundary_subdomain_ids</a></div><div class="ttdeci">std::set&lt; SubdomainID &gt; _primary_boundary_subdomain_ids</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00417">AutomaticMortarGeneration.h:417</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_accf5b2f45171eb92b58dd27d22b9715c"><div class="ttname"><a href="classAutomaticMortarGeneration.html#accf5b2f45171eb92b58dd27d22b9715c">AutomaticMortarGeneration::projectPrimaryNodesSinglePair</a></div><div class="ttdeci">void projectPrimaryNodesSinglePair(SubdomainID lower_dimensional_primary_subdomain_id, SubdomainID lower_dimensional_secondary_subdomain_id)</div><div class="ttdoc">Helper function used internally by AutomaticMortarGeneration::project_primary_nodes().</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8C_source.html#l02173">AutomaticMortarGeneration.C:2173</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_ad0031e96df8f32e5c456a98532509404"><div class="ttname"><a href="classAutomaticMortarGeneration.html#ad0031e96df8f32e5c456a98532509404">AutomaticMortarGeneration::dim</a></div><div class="ttdeci">int dim() const</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00279">AutomaticMortarGeneration.h:279</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_ad67507605b6ed18765d5ffd1243ff619"><div class="ttname"><a href="classAutomaticMortarGeneration.html#ad67507605b6ed18765d5ffd1243ff619">AutomaticMortarGeneration::_primary_requested_boundary_ids</a></div><div class="ttdeci">std::set&lt; BoundaryID &gt; _primary_requested_boundary_ids</div><div class="ttdoc">The boundary ids corresponding to all the primary surfaces.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00359">AutomaticMortarGeneration.h:359</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_ae200397e9841242f1bc2438b2156f253"><div class="ttname"><a href="classAutomaticMortarGeneration.html#ae200397e9841242f1bc2438b2156f253">AutomaticMortarGeneration::getNodalNormals</a></div><div class="ttdeci">std::vector&lt; Point &gt; getNodalNormals(const Elem &amp;secondary_elem) const</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8C_source.html#l00322">AutomaticMortarGeneration.C:322</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_af0da3b7d9e404238718805e12452d74d"><div class="ttname"><a href="classAutomaticMortarGeneration.html#af0da3b7d9e404238718805e12452d74d">AutomaticMortarGeneration::_secondary_elems_to_mortar_segments</a></div><div class="ttdeci">std::unordered_map&lt; dof_id_type, std::set&lt; Elem *, CompareDofObjectsByID &gt; &gt; _secondary_elems_to_mortar_segments</div><div class="ttdoc">We maintain a mapping from lower-dimensional secondary elements in the original mesh to (sets of) ele...</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00449">AutomaticMortarGeneration.h:449</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_af11d3acd4a241fb531e4fa9ef227f469"><div class="ttname"><a href="classAutomaticMortarGeneration.html#af11d3acd4a241fb531e4fa9ef227f469">AutomaticMortarGeneration::secondariesToMortarSegments</a></div><div class="ttdeci">const std::unordered_map&lt; dof_id_type, std::set&lt; Elem *, CompareDofObjectsByID &gt; &gt; &amp; secondariesToMortarSegments() const</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00315">AutomaticMortarGeneration.h:315</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_af3d7aaf216fe1d8fabc8461756312a1f"><div class="ttname"><a href="classAutomaticMortarGeneration.html#af3d7aaf216fe1d8fabc8461756312a1f">AutomaticMortarGeneration::projectPrimaryNodes</a></div><div class="ttdeci">void projectPrimaryNodes()</div><div class="ttdoc">(Inverse) project primary nodes to the points on the secondary surface where they would have come fro...</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8C_source.html#l02164">AutomaticMortarGeneration.C:2164</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_af55157330468f97bbf6905ffbb92fbea"><div class="ttname"><a href="classAutomaticMortarGeneration.html#af55157330468f97bbf6905ffbb92fbea">AutomaticMortarGeneration::computeInactiveLMNodes</a></div><div class="ttdeci">void computeInactiveLMNodes()</div><div class="ttdoc">Get list of secondary nodes that don't contribute to interaction with any primary element.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8C_source.html#l01577">AutomaticMortarGeneration.C:1577</a></div></div>
<div class="ttc" id="aclassAutomaticMortarGeneration_html_af5ca257dd4090b3a8d801a439dcae0ca"><div class="ttname"><a href="classAutomaticMortarGeneration.html#af5ca257dd4090b3a8d801a439dcae0ca">AutomaticMortarGeneration::_minimum_projection_angle</a></div><div class="ttdeci">const Real _minimum_projection_angle</div><div class="ttdoc">Parameter to control which angle (in degrees) is admissible for the creation of mortar segments.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8h_source.html#l00505">AutomaticMortarGeneration.h:505</a></div></div>
<div class="ttc" id="aclassConsoleStreamInterface_html"><div class="ttname"><a href="classConsoleStreamInterface.html">ConsoleStreamInterface</a></div><div class="ttdoc">An inteface for the _console for outputting to the Console object.</div><div class="ttdef"><b>Definition:</b> <a href="ConsoleStreamInterface_8h_source.html#l00021">ConsoleStreamInterface.h:22</a></div></div>
<div class="ttc" id="aclassConsoleStreamInterface_html_acd1f259e7a3d200223164c08af3a7c13"><div class="ttname"><a href="classConsoleStreamInterface.html#acd1f259e7a3d200223164c08af3a7c13">ConsoleStreamInterface::_console</a></div><div class="ttdeci">const ConsoleStream _console</div><div class="ttdoc">An instance of helper class to write streams to the Console objects.</div><div class="ttdef"><b>Definition:</b> <a href="ConsoleStreamInterface_8h_source.html#l00031">ConsoleStreamInterface.h:31</a></div></div>
<div class="ttc" id="aclassFEProblemBase_html"><div class="ttname"><a href="classFEProblemBase.html">FEProblemBase</a></div><div class="ttdoc">Specialization of SubProblem for solving nonlinear equations plus auxiliary equations.</div><div class="ttdef"><b>Definition:</b> <a href="FEProblemBase_8h_source.html#l00145">FEProblemBase.h:146</a></div></div>
<div class="ttc" id="aclassFormattedTable_html"><div class="ttname"><a href="classFormattedTable.html">FormattedTable</a></div><div class="ttdoc">This class is used for building, formatting, and outputting tables of numbers.</div><div class="ttdef"><b>Definition:</b> <a href="FormattedTable_8h_source.html#l00109">FormattedTable.h:110</a></div></div>
<div class="ttc" id="aclassFormattedTable_html_a17854e65f279e180420146fa570ed36a"><div class="ttname"><a href="classFormattedTable.html#a17854e65f279e180420146fa570ed36a">FormattedTable::clear</a></div><div class="ttdeci">void clear()</div><div class="ttdef"><b>Definition:</b> <a href="FormattedTable_8C_source.html#l00563">FormattedTable.C:563</a></div></div>
<div class="ttc" id="aclassFormattedTable_html_a69a8eb1233d213541c3e74d5de3cd882"><div class="ttname"><a href="classFormattedTable.html#a69a8eb1233d213541c3e74d5de3cd882">FormattedTable::printTable</a></div><div class="ttdeci">void printTable(std::ostream &amp;out, unsigned int last_n_entries=0)</div><div class="ttdoc">Methods for dumping the table to the stream - either by filename or by stream handle.</div><div class="ttdef"><b>Definition:</b> <a href="FormattedTable_8C_source.html#l00242">FormattedTable.C:242</a></div></div>
<div class="ttc" id="aclassFormattedTable_html_aa3a67ad3a70d2ac160f76b605a415853"><div class="ttname"><a href="classFormattedTable.html#aa3a67ad3a70d2ac160f76b605a415853">FormattedTable::addData</a></div><div class="ttdeci">void addData(const std::string &amp;name, const T &amp;value)</div><div class="ttdoc">Method for adding data to the output table.</div><div class="ttdef"><b>Definition:</b> <a href="FormattedTable_8h_source.html#l00327">FormattedTable.h:327</a></div></div>
<div class="ttc" id="aclassFormattedTable_html_ad88c8d5f300a569a9bc4844223d39612"><div class="ttname"><a href="classFormattedTable.html#ad88c8d5f300a569a9bc4844223d39612">FormattedTable::addRow</a></div><div class="ttdeci">void addRow(Real time)</div><div class="ttdoc">Force a new row in the table with the passed in time.</div><div class="ttdef"><b>Definition:</b> <a href="FormattedTable_8C_source.html#l00186">FormattedTable.C:186</a></div></div>
<div class="ttc" id="aclassInputParameters_html"><div class="ttname"><a href="classInputParameters.html">InputParameters</a></div><div class="ttdoc">The main MOOSE class responsible for handling user-defined parameters in almost every MOOSE system.</div><div class="ttdef"><b>Definition:</b> <a href="InputParameters_8h_source.html#l00047">InputParameters.h:48</a></div></div>
<div class="ttc" id="aclassMetaPhysicL_1_1DualNumber_html"><div class="ttname"><a href="classMetaPhysicL_1_1DualNumber.html">MetaPhysicL::DualNumber</a></div><div class="ttdef"><b>Definition:</b> <a href="ChainedReal_8h_source.html#l00021">ChainedReal.h:21</a></div></div>
<div class="ttc" id="aclassMooseApp_html"><div class="ttname"><a href="classMooseApp.html">MooseApp</a></div><div class="ttdoc">Base class for MOOSE-based applications.</div><div class="ttdef"><b>Definition:</b> <a href="MooseApp_8h_source.html#l00068">MooseApp.h:71</a></div></div>
<div class="ttc" id="aclassMooseApp_html_a446e24d786a991471cfc3a1f0aeccaea"><div class="ttname"><a href="classMooseApp.html#a446e24d786a991471cfc3a1f0aeccaea">MooseApp::getOutputWarehouse</a></div><div class="ttdeci">OutputWarehouse &amp; getOutputWarehouse()</div><div class="ttdoc">Get the OutputWarehouse objects.</div><div class="ttdef"><b>Definition:</b> <a href="MooseApp_8C_source.html#l01734">MooseApp.C:1734</a></div></div>
<div class="ttc" id="aclassMooseApp_html_a9901a98a17c8276cc00b4841584bb561"><div class="ttname"><a href="classMooseApp.html#a9901a98a17c8276cc00b4841584bb561">MooseApp::feProblem</a></div><div class="ttdeci">FEProblemBase &amp; feProblem() const</div><div class="ttdef"><b>Definition:</b> <a href="MooseApp_8C_source.html#l01305">MooseApp.C:1305</a></div></div>
<div class="ttc" id="aclassMooseBaseErrorInterface_html_add080f0d929c93db62fe02eac6f7f5da"><div class="ttname"><a href="classMooseBaseErrorInterface.html#add080f0d929c93db62fe02eac6f7f5da">MooseBaseErrorInterface::mooseError</a></div><div class="ttdeci">void mooseError(Args &amp;&amp;... args) const</div><div class="ttdoc">Emits an error prefixed with object name and type.</div><div class="ttdef"><b>Definition:</b> <a href="MooseBaseErrorInterface_8h_source.html#l00038">MooseBaseErrorInterface.h:38</a></div></div>
<div class="ttc" id="aclassMooseBaseParameterInterface_html_a518f1157d948ba2f02807f76f102849e"><div class="ttname"><a href="classMooseBaseParameterInterface.html#a518f1157d948ba2f02807f76f102849e">MooseBaseParameterInterface::getCheckedPointerParam</a></div><div class="ttdeci">T getCheckedPointerParam(const std::string &amp;name, const std::string &amp;error_string=&quot;&quot;) const</div><div class="ttdoc">Verifies that the requested parameter exists and is not NULL and returns it to the caller.</div><div class="ttdef"><b>Definition:</b> <a href="MooseBaseParameterInterface_8h_source.html#l00264">MooseBaseParameterInterface.h:264</a></div></div>
<div class="ttc" id="aclassMooseException_html"><div class="ttname"><a href="classMooseException.html">MooseException</a></div><div class="ttdoc">Provides a way for users to bail out of the current solve.</div><div class="ttdef"><b>Definition:</b> <a href="MooseException_8h_source.html#l00020">MooseException.h:21</a></div></div>
<div class="ttc" id="aclassMooseObject_html_a7e7be2880d321492519ec806996ed365"><div class="ttname"><a href="classMooseObject.html#a7e7be2880d321492519ec806996ed365">MooseObject::_app</a></div><div class="ttdeci">MooseApp &amp; _app</div><div class="ttdoc">The MOOSE application this is associated with.</div><div class="ttdef"><b>Definition:</b> <a href="MooseBase_8h_source.html#l00060">MooseBase.h:60</a></div></div>
<div class="ttc" id="aclassMooseUtils_1_1SemidynamicVector_html"><div class="ttname"><a href="classMooseUtils_1_1SemidynamicVector.html">MooseUtils::SemidynamicVector</a></div><div class="ttdoc">Utility class template for a semidynamic vector with a maximum size N and a chosen dynamic size.</div><div class="ttdef"><b>Definition:</b> <a href="MooseUtils_8h_source.html#l01084">MooseUtils.h:1085</a></div></div>
<div class="ttc" id="aclassMooseUtils_1_1SemidynamicVector_html_af16f5c51b00a9051eb61ccdefcf905c9"><div class="ttname"><a href="classMooseUtils_1_1SemidynamicVector.html#af16f5c51b00a9051eb61ccdefcf905c9">MooseUtils::SemidynamicVector::push_back</a></div><div class="ttdeci">void push_back(const T &amp;v)</div><div class="ttdef"><b>Definition:</b> <a href="MooseUtils_8h_source.html#l01108">MooseUtils.h:1108</a></div></div>
<div class="ttc" id="aclassMortarNodalGeometryOutput_html"><div class="ttname"><a href="classMortarNodalGeometryOutput.html">MortarNodalGeometryOutput</a></div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8C_source.html#l00061">AutomaticMortarGeneration.C:62</a></div></div>
<div class="ttc" id="aclassMortarNodalGeometryOutput_html_a0c5e0029e42c789ca8af364a7fe59564"><div class="ttname"><a href="classMortarNodalGeometryOutput.html#a0c5e0029e42c789ca8af364a7fe59564">MortarNodalGeometryOutput::MortarNodalGeometryOutput</a></div><div class="ttdeci">MortarNodalGeometryOutput(const InputParameters &amp;params)</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8C_source.html#l00073">AutomaticMortarGeneration.C:73</a></div></div>
<div class="ttc" id="aclassMortarNodalGeometryOutput_html_a0eb71ab627d8028efeb1bbf05212dc9e"><div class="ttname"><a href="classMortarNodalGeometryOutput.html#a0eb71ab627d8028efeb1bbf05212dc9e">MortarNodalGeometryOutput::_t1z_var_num</a></div><div class="ttdeci">unsigned int _t1z_var_num</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8C_source.html#l00205">AutomaticMortarGeneration.C:205</a></div></div>
<div class="ttc" id="aclassMortarNodalGeometryOutput_html_a0ffdd24bb6e71f5af85dba0950d9e47f"><div class="ttname"><a href="classMortarNodalGeometryOutput.html#a0ffdd24bb6e71f5af85dba0950d9e47f">MortarNodalGeometryOutput::_t1x_var_num</a></div><div class="ttdeci">unsigned int _t1x_var_num</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8C_source.html#l00203">AutomaticMortarGeneration.C:203</a></div></div>
<div class="ttc" id="aclassMortarNodalGeometryOutput_html_a43a1532163c9c3ae49af3368d14c9a5b"><div class="ttname"><a href="classMortarNodalGeometryOutput.html#a43a1532163c9c3ae49af3368d14c9a5b">MortarNodalGeometryOutput::_t2z_var_num</a></div><div class="ttdeci">unsigned int _t2z_var_num</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8C_source.html#l00209">AutomaticMortarGeneration.C:209</a></div></div>
<div class="ttc" id="aclassMortarNodalGeometryOutput_html_a59e55d699cc43d82ea14eb460f66bc92"><div class="ttname"><a href="classMortarNodalGeometryOutput.html#a59e55d699cc43d82ea14eb460f66bc92">MortarNodalGeometryOutput::_nny_var_num</a></div><div class="ttdeci">unsigned int _nny_var_num</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8C_source.html#l00200">AutomaticMortarGeneration.C:200</a></div></div>
<div class="ttc" id="aclassMortarNodalGeometryOutput_html_a5e5bd72ed60f43ecc163b6dd89ef1681"><div class="ttname"><a href="classMortarNodalGeometryOutput.html#a5e5bd72ed60f43ecc163b6dd89ef1681">MortarNodalGeometryOutput::_t2y_var_num</a></div><div class="ttdeci">unsigned int _t2y_var_num</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8C_source.html#l00208">AutomaticMortarGeneration.C:208</a></div></div>
<div class="ttc" id="aclassMortarNodalGeometryOutput_html_a6bf8458c621e9dba746029f0f658eab1"><div class="ttname"><a href="classMortarNodalGeometryOutput.html#a6bf8458c621e9dba746029f0f658eab1">MortarNodalGeometryOutput::validParams</a></div><div class="ttdeci">static InputParameters validParams()</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8C_source.html#l00064">AutomaticMortarGeneration.C:64</a></div></div>
<div class="ttc" id="aclassMortarNodalGeometryOutput_html_aa3ca853594cf98bdd87e5315b4357c9b"><div class="ttname"><a href="classMortarNodalGeometryOutput.html#aa3ca853594cf98bdd87e5315b4357c9b">MortarNodalGeometryOutput::_amg</a></div><div class="ttdeci">AutomaticMortarGeneration &amp; _amg</div><div class="ttdoc">The mortar generation object that we will query for nodal normal and tangent information.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8C_source.html#l00194">AutomaticMortarGeneration.C:194</a></div></div>
<div class="ttc" id="aclassMortarNodalGeometryOutput_html_ab203b6ac1578045882f4076cce002b30"><div class="ttname"><a href="classMortarNodalGeometryOutput.html#ab203b6ac1578045882f4076cce002b30">MortarNodalGeometryOutput::_nnz_var_num</a></div><div class="ttdeci">unsigned int _nnz_var_num</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8C_source.html#l00201">AutomaticMortarGeneration.C:201</a></div></div>
<div class="ttc" id="aclassMortarNodalGeometryOutput_html_abacf3fe882f67ac24674bb7617a266a8"><div class="ttname"><a href="classMortarNodalGeometryOutput.html#abacf3fe882f67ac24674bb7617a266a8">MortarNodalGeometryOutput::_nnx_var_num</a></div><div class="ttdeci">unsigned int _nnx_var_num</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8C_source.html#l00199">AutomaticMortarGeneration.C:199</a></div></div>
<div class="ttc" id="aclassMortarNodalGeometryOutput_html_ac1921976fee38185201ab182c5b56f26"><div class="ttname"><a href="classMortarNodalGeometryOutput.html#ac1921976fee38185201ab182c5b56f26">MortarNodalGeometryOutput::_t2x_var_num</a></div><div class="ttdeci">unsigned int _t2x_var_num</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8C_source.html#l00207">AutomaticMortarGeneration.C:207</a></div></div>
<div class="ttc" id="aclassMortarNodalGeometryOutput_html_ad80dfc2071b28d414b231b585612ee1b"><div class="ttname"><a href="classMortarNodalGeometryOutput.html#ad80dfc2071b28d414b231b585612ee1b">MortarNodalGeometryOutput::_nodal_normals_system</a></div><div class="ttdeci">libMesh::System * _nodal_normals_system</div><div class="ttdoc">Member variables for geometry debug output.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8C_source.html#l00198">AutomaticMortarGeneration.C:198</a></div></div>
<div class="ttc" id="aclassMortarNodalGeometryOutput_html_af12ccab062fed7c8002825344263f546"><div class="ttname"><a href="classMortarNodalGeometryOutput.html#af12ccab062fed7c8002825344263f546">MortarNodalGeometryOutput::_t1y_var_num</a></div><div class="ttdeci">unsigned int _t1y_var_num</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8C_source.html#l00204">AutomaticMortarGeneration.C:204</a></div></div>
<div class="ttc" id="aclassMortarNodalGeometryOutput_html_af9de64b107fd3822520533f33cd74b67"><div class="ttname"><a href="classMortarNodalGeometryOutput.html#af9de64b107fd3822520533f33cd74b67">MortarNodalGeometryOutput::output</a></div><div class="ttdeci">void output() override</div><div class="ttdoc">Overload this function with the desired output activities.</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8C_source.html#l00078">AutomaticMortarGeneration.C:78</a></div></div>
<div class="ttc" id="aclassNanoflannMeshSubdomainAdaptor_html"><div class="ttname"><a href="classNanoflannMeshSubdomainAdaptor.html">NanoflannMeshSubdomainAdaptor</a></div><div class="ttdoc">Special adaptor that works with subdomains of the Mesh.</div><div class="ttdef"><b>Definition:</b> <a href="NanoflannMeshAdaptor_8h_source.html#l00118">NanoflannMeshAdaptor.h:119</a></div></div>
<div class="ttc" id="aclassOutputWarehouse_html_af1e105715b5393f3341b24fdc4f31627"><div class="ttname"><a href="classOutputWarehouse.html#af1e105715b5393f3341b24fdc4f31627">OutputWarehouse::addOutput</a></div><div class="ttdeci">void addOutput(std::shared_ptr&lt; Output &gt; output)</div><div class="ttdoc">Adds an existing output object to the warehouse.</div><div class="ttdef"><b>Definition:</b> <a href="OutputWarehouse_8C_source.html#l00102">OutputWarehouse.C:102</a></div></div>
<div class="ttc" id="aclassOutput_html"><div class="ttname"><a href="classOutput.html">Output</a></div><div class="ttdoc">Based class for output objects.</div><div class="ttdef"><b>Definition:</b> <a href="Output_8h_source.html#l00041">Output.h:50</a></div></div>
<div class="ttc" id="aclassOutput_html_a56c3206b7b50dfec2c3ca0745399cee3"><div class="ttname"><a href="classOutput.html#a56c3206b7b50dfec2c3ca0745399cee3">Output::validParams</a></div><div class="ttdeci">static InputParameters validParams()</div><div class="ttdef"><b>Definition:</b> <a href="Output_8C_source.html#l00032">Output.C:32</a></div></div>
<div class="ttc" id="aclassSubProblem_html"><div class="ttname"><a href="classSubProblem.html">SubProblem</a></div><div class="ttdoc">Generic class for solving transient nonlinear problems.</div><div class="ttdef"><b>Definition:</b> <a href="SubProblem_8h_source.html#l00075">SubProblem.h:76</a></div></div>
<div class="ttc" id="aclassSubProblem_html_aaf79a48be31726ec7871a85918735d26"><div class="ttname"><a href="classSubProblem.html#aaf79a48be31726ec7871a85918735d26">SubProblem::es</a></div><div class="ttdeci">virtual EquationSystems &amp; es()=0</div></div>
<div class="ttc" id="aclasslibMesh_1_1TypeVector_html"><div class="ttname"><a href="classlibMesh_1_1TypeVector.html">libMesh::TypeVector</a></div><div class="ttdef"><b>Definition:</b> <a href="MooseTypes_8h_source.html#l00143">MooseTypes.h:143</a></div></div>
<div class="ttc" id="aclasslibMesh_1_1VectorValue_html"><div class="ttname"><a href="classlibMesh_1_1VectorValue.html">libMesh::VectorValue</a></div><div class="ttdef"><b>Definition:</b> <a href="Assembly_8h_source.html#l00037">Assembly.h:37</a></div></div>
<div class="ttc" id="anamespaceMetaPhysicL_html_a1c0a19c861d5f7813f7fb6825d8fe146"><div class="ttname"><a href="namespaceMetaPhysicL.html#a1c0a19c861d5f7813f7fb6825d8fe146">MetaPhysicL::raw_value</a></div><div class="ttdeci">auto raw_value(const Eigen::Map&lt; T &gt; &amp;in)</div><div class="ttdef"><b>Definition:</b> <a href="ADReal_8h_source.html#l00073">ADReal.h:73</a></div></div>
<div class="ttc" id="anamespaceMooseUtils_html_ad9865895ce5bb2c18722efa26d5c7693"><div class="ttname"><a href="namespaceMooseUtils.html#ad9865895ce5bb2c18722efa26d5c7693">MooseUtils::absoluteFuzzyEqual</a></div><div class="ttdeci">bool absoluteFuzzyEqual(const T &amp;var1, const T2 &amp;var2, const T3 &amp;tol=libMesh::TOLERANCE *libMesh::TOLERANCE)</div><div class="ttdoc">Function to check whether two variables are equal within an absolute tolerance.</div><div class="ttdef"><b>Definition:</b> <a href="MooseUtils_8h_source.html#l00337">MooseUtils.h:337</a></div></div>
<div class="ttc" id="anamespaceMoose_html_a5fd6a33e7b0246beaf68f64045de310c"><div class="ttname"><a href="namespaceMoose.html#a5fd6a33e7b0246beaf68f64045de310c">Moose::fe_lagrange_2D_shape</a></div><div class="ttdeci">T fe_lagrange_2D_shape(const ElemType type, const Order order, const unsigned int i, const VectorType&lt; T &gt; &amp;p)</div><div class="ttdef"><b>Definition:</b> <a href="MooseLagrangeHelpers_8h_source.html#l00171">MooseLagrangeHelpers.h:171</a></div></div>
<div class="ttc" id="anamespaceMoose_html_a9ed3373b5072c07f1f010afb75ac20c9"><div class="ttname"><a href="namespaceMoose.html#a9ed3373b5072c07f1f010afb75ac20c9">Moose::fe_lagrange_1D_shape</a></div><div class="ttdeci">T fe_lagrange_1D_shape(const Order order, const unsigned int i, const T &amp;xi)</div><div class="ttdef"><b>Definition:</b> <a href="MooseLagrangeHelpers_8h_source.html#l00022">MooseLagrangeHelpers.h:22</a></div></div>
<div class="ttc" id="anamespacelibMesh_html"><div class="ttname"><a href="namespacelibMesh.html">libMesh</a></div><div class="ttdoc">The following methods are specializations for using the libMesh::Parallel::packed_range_* routines fo...</div><div class="ttdef"><b>Definition:</b> <a href="JsonIO_8C_source.html#l00047">JsonIO.C:48</a></div></div>
<div class="ttc" id="anamespacenanoflann_html"><div class="ttname"><a href="namespacenanoflann.html">nanoflann</a></div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8C_source.html#l00055">AutomaticMortarGeneration.C:56</a></div></div>
<div class="ttc" id="anamespacenanoflann_html_a7475277cf1d06434e352ade6f35de645"><div class="ttname"><a href="namespacenanoflann.html#a7475277cf1d06434e352ade6f35de645">nanoflann::SearchParameters</a></div><div class="ttdeci">SearchParams SearchParameters</div><div class="ttdef"><b>Definition:</b> <a href="AutomaticMortarGeneration_8C_source.html#l00057">AutomaticMortarGeneration.C:57</a></div></div>
<div class="ttc" id="astructMortarSegmentInfo_html"><div class="ttname"><a href="structMortarSegmentInfo.html">MortarSegmentInfo</a></div><div class="ttdoc">Holds xi^(1), xi^(2), and other data for a given mortar segment.</div><div class="ttdef"><b>Definition:</b> <a href="MortarSegmentInfo_8h_source.html#l00031">MortarSegmentInfo.h:32</a></div></div>
<div class="ttc" id="astructMortarSegmentInfo_html_a3316fbff8584e06e3c973d3f3e6ff05f"><div class="ttname"><a href="structMortarSegmentInfo.html#a3316fbff8584e06e3c973d3f3e6ff05f">MortarSegmentInfo::primary_elem</a></div><div class="ttdeci">const Elem * primary_elem</div><div class="ttdef"><b>Definition:</b> <a href="MortarSegmentInfo_8h_source.html#l00068">MortarSegmentInfo.h:68</a></div></div>
<div class="ttc" id="astructMortarSegmentInfo_html_a4fe559d3196b77718c1052ab7c1aa4d3"><div class="ttname"><a href="structMortarSegmentInfo.html#a4fe559d3196b77718c1052ab7c1aa4d3">MortarSegmentInfo::xi2_b</a></div><div class="ttdeci">Real xi2_b</div><div class="ttdef"><b>Definition:</b> <a href="MortarSegmentInfo_8h_source.html#l00066">MortarSegmentInfo.h:66</a></div></div>
<div class="ttc" id="astructMortarSegmentInfo_html_a648c7f480b2ce6404b1db1d21642b919"><div class="ttname"><a href="structMortarSegmentInfo.html#a648c7f480b2ce6404b1db1d21642b919">MortarSegmentInfo::xi1_b</a></div><div class="ttdeci">Real xi1_b</div><div class="ttdef"><b>Definition:</b> <a href="MortarSegmentInfo_8h_source.html#l00065">MortarSegmentInfo.h:65</a></div></div>
<div class="ttc" id="astructMortarSegmentInfo_html_abcfb0183363f3e21b43f9ffd3dc477b4"><div class="ttname"><a href="structMortarSegmentInfo.html#abcfb0183363f3e21b43f9ffd3dc477b4">MortarSegmentInfo::xi2_a</a></div><div class="ttdeci">Real xi2_a</div><div class="ttdef"><b>Definition:</b> <a href="MortarSegmentInfo_8h_source.html#l00066">MortarSegmentInfo.h:66</a></div></div>
<div class="ttc" id="astructMortarSegmentInfo_html_ad4205fbab31bbda066622c55c8e93b87"><div class="ttname"><a href="structMortarSegmentInfo.html#ad4205fbab31bbda066622c55c8e93b87">MortarSegmentInfo::xi1_a</a></div><div class="ttdeci">Real xi1_a</div><div class="ttdef"><b>Definition:</b> <a href="MortarSegmentInfo_8h_source.html#l00065">MortarSegmentInfo.h:65</a></div></div>
<div class="ttc" id="astructMortarSegmentInfo_html_ae240d424b2112e4d23e66597318160ca"><div class="ttname"><a href="structMortarSegmentInfo.html#ae240d424b2112e4d23e66597318160ca">MortarSegmentInfo::invalid_xi</a></div><div class="ttdeci">static const Real invalid_xi</div><div class="ttdef"><b>Definition:</b> <a href="MortarSegmentInfo_8h_source.html#l00072">MortarSegmentInfo.h:72</a></div></div>
<div class="ttc" id="astructMortarSegmentInfo_html_afa8c2918a473f0dad90d5c68dad00eb4"><div class="ttname"><a href="structMortarSegmentInfo.html#afa8c2918a473f0dad90d5c68dad00eb4">MortarSegmentInfo::secondary_elem</a></div><div class="ttdeci">const Elem * secondary_elem</div><div class="ttdef"><b>Definition:</b> <a href="MortarSegmentInfo_8h_source.html#l00067">MortarSegmentInfo.h:67</a></div></div>
</div><!-- fragment --></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Dec 24 2023 00:18:11 for Zapdos by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5
</small></address>
</body>
</html>
